# 07. 연산자 오버로딩과 기타 관례

## 7.1 산술 연산자 오버로딩

> 자바에서는 원시타입과 String에 대해서만 산술 연산자를 사용할 수 있다.
> 하지만 산술 연산자를 사용하면 메소드를 명시적으로 호출하는 것보다 좋은 가독성을 제공한다.
> 코틀린에서는 산술연산자를 개발자가 정의 가능하다.

### 7.1.1 이항 산술 연산 오버로딩

```kotlin
data class Point(val x: Int, val y: Int) {
	operator fun plus(other: Point): Point {
		return Point(x + other.x, y + other.y)
	}
}
```

> 이처럼 plus 함수 앞에 operator 키워드를 붙여야 한다. 연산자를 오버로딩 하는 함수 앞에는 꼭 operator가 있어야한다.
> operator 키워드를 붙임으로써 어떤 함수가 관례(convention)를 따르는 함수임을 명확히 할 수 있다.
> 만약 operator 키워드 없이 관례에서 사용하는 함수 이름을 쓰고 우연히 그 이름에 해당하는 기능을 사용한다면 오류가 발생한다.

`a + b -> a.plus(b)`
> + 연산자는 plus 함수 호출로 컴파일 된다.

```kotlin
operator fun Point.plus(other: Point) Point {
	return Point(x + other.x, y + other.y)
}
```

> 위처럼 확장함수도 잘 작동한다.

> 코틀린에서는 프로그래머가 직접 연산자를 만들어 사용할 수 없고 언어에서 미리 정해둔 연산자만 오버로딩할 수 있으며, 관례에 따르기 위해 클래스에서 정의해야 하는 이름이 연산자별로 정해져 있다.

| 식     | 함수 이름    |
| ----- | -------- |
| a + b | plus     |
| a - b | minus    |
| a * b | times    |
| a / b | div      |
| a % b | mod(rem) |
> 직접 정의한 함수를 통해 구현하더라도 연산자 우선순위는 언제나 표준 숫자 타입에 대한 연산자 우선순위와 같다.

> 코틀린 연산자가 자동으로 교환 법칙을 지원하지는 않음을 주의하라.

> 일반 함수와 마찬가지로 operator 함수도 오버로딩할 수 있다. 따라서 이름은 같지만 파라미터 타입이 서로 다른 연산자 함수를 여럿 만들 수 있다.

### 7.1.2 복합 대입 연산자 오버로딩

> plus와 같은 연산자를 오버로딩하면 코틀린은 + 연산자뿐 아니라 그와 관련 있는 연산자인 +=도 자동으로 함꼐 지원한다.
> +=, -=등의 연산자는 복합 대입 연산자(compound assignment)로 불린다.

> 객체에 +=연산자를 사용하면 새로운 객체를 반환하기 때문에 결국에 참조가 변경된다.

> 변경 가능한 컬렉션에 원소를 추가하는 경우처럼 내부 상태를 변경시키게도 할 수 있다.

```kotlin
val numbers = ArrayList<Int>()
numbers += 42
println(numbers[0])
// 42
```

> 코틀린 표준 라이브러리는 변경 가능한 컬렉션에 대해 plusAssign을 정의하며, 앞의 예제는 그 plusAssign을 사용한다.

```kotlin
operator fun <T> MutableCollection<T>.plusAssign(element: T) {
	this.add(element)
}
```

> plus와 plusAssign 연산을 동시에 정의하지 말라.
> 읽기 전용 객체라면 plus로 새로운 객체를 생성하는 방향으로 그 반대는 plusAssign을 사용하면 된다.

```kotlin
val list = arrayListOf(1, 2)
list += 3
val newList = list + listOf(4, 5)
println(list)
// [1, 2, 3]
println(newList)
// [1, 2, 3, 4, 5]
```

### 7.1.3 단항 연산자 오버로딩

> 이항 연산자와 마찬가지로 operator 키워드로 정의한다.

| 식    | 함수 이름      |
|-------|---------------|
| +a    | unaryPlus     |
| -a    | unaryMinus    |
| !a    | not           |
| a++   | inc           |
| a--   | dec           |
## 7.2 비교 연산자 오버로딩

### 7.2.1 동등성 연산자 equals

> == 도 마찬가지로 equals 호출로 컴파일된다.

> equals는 상위 클래스 Any로부터 상속 받은걸 override 하는 것이라 operator 변경자가 필요없다.

> 만약 직접 구현한다면 === 참조 비교를 통해 최적화를 하자.

> Any에서 받은 equals가 확장 함수보다 우선순위가 높기 때문에 equals를 확장 함수로 정의할 수 없다는 사실에 유의하자.

### 7.2.2 순서 연산자: compareTo

> 자바에서 정렬이나 최댓값, 최솟값 등 값을 비교해야 하는 알고리즘에 사용할 클래스는 Comparable 인터페이스를 구현해야 한다.
> 코틀린도 똑같은 Comparable 인터페이스를 지원한다. 게다가 코틀린은 Comparable 인터페이스 안에 있는 compareTo 메소드를 호출하는 관례를 제공한다.
> 따라서 비교 연산자(<, >, <=, >=)는 compareTo 호출로 컴파일 된다.

```kotlin
class Person(
	val firstName: String, val lastName: String
): Comparable<Person> {
	override fun compareTo(other: Person): Int {
		return compareValuesBy(this, other, Person::lastName, Person::firstName)
	}
}
```

> compareValuesBy 함수를 사용해 compareTo를 쉽고 간결하게 정의할 수 있다.
> 하지만 성능상으로는 필드를 직접 비교하는 방식이 비교속도는 훨씬 빠르다.

```kotlin
@Test  
fun `CompareValueBy 함수는 필드를 직접 정의하는 것보다 느리다.`() {  
    val p1 = Person(age = 20, name = "Garland Alford")  
    val p2 = Person(age = 20, name = "Farmer")  
    val compareValuesByTime = measureTimeMillis {  
        repeat(100000000) {  
            compareValuesBy(p1, p2, Person::age, Person::name)  
        }  
    }  
    val ifElseTime= measureTimeMillis {  
        repeat(100000000) {  
            if (p1.age > p2.age) {  
                1  
            } else if(p1.age < p2.age) {  
                -1  
            } else {  
                if (p1.name > p2.name) {  
                    1  
                } else if (p1.name < p2.name) {  
                    -1  
                } else {  
                    0  
                }  
            }  
        }  
    }  
    println(compareValuesByTime)
    // 882
    println(ifElseTime)  
    // 144

	assertTrue(compareValuesByTime > ifElseTime)
}
```

> **언제나 그렇듯 처음에는 성능에 신경쓰지 말고 이해하기 쉽고 간결하게 코드를 작성하고, 나중에 그 코드가 자주 호출됨에 따라 성능이 문제가 되면 성능을 개선하라!**
