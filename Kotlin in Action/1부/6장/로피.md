# 6장 코틀린 타입 시스템

## 6.1 널 가능성

널 가능성(nullability)

- NullPointerException 오류를 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성

최신 언어에서 null에 대한 접근방법은 가능한 한 이 문제를 실행시점에서 컴파일 시점으로 옮기는 것

→ 널이 될 수 있는지 여부를 타입 시스템에 추가함으로써 컴파일러가 여러 가지 오류를 컴파일 시 미리 감지해서 실행 시점에 발생할 수 있는 예외의 가능성을 줄일 수 있다.

### 6.1.1 널이 될 수 있는 타입

코틀린은 널이 될 수 있는 타입을 명시적으로 지원한다.

→ 널이 될 수 있는 타입은 프로그램 안의 프로퍼티나 변수에 null을 허용하게 만드는 방법이다.

→ 코틀린은 NullPointerException을 발생시키는 메서드 호출을 금지함으로써 많은 오류를 방지한다.

```kotlin
int strLen(String s) {
	return s.length();
}
```

→ 이 함수에 null을 넘기면 NullPointerException이 발생

In Kotlin

널이 인자로 들어올 수 없다면 

```kotlin
fun strLen(s: String) = s.length
```

→ strLen에 null이거나 널이 될 수 있는 인자를 넘기는 것은 금지되며, 혹시 그런 값을 넘기면 컴파일 시 오류가 발생한다.

널과 문자열을 인자로 받을 수 있게 하려면

```kotlin
fun strLenSafe(s: String?) = ...
```

→ 어떤 타입이든 타입 이름 뒤에 물음표를 붙이면 그 타입의 변수나 프로퍼티에 null 참조를 저장할 수 있다.

널이 될 수 있는 타입의 변수가 있다면 그에 대해 수행할 수 있는 연산이 제한된다.

- 널이 될 수 있는 타입인 변수에 대해 변수.메소드()처럼 메소드를 직접 호출할 수 없다.
    
    ```kotlin
    fun strLenSafe(s: String?) = s.length() --> X
    ```
    
- 널이 될 수 있는 값을 널이 될 수 없는 타입의 변수에 대입할 수 없다.
    
    ```kotlin
    val x: String? = null
    var y: String = x
    ```
    
- 널이 될 수 있는 타입의 값을 널이 될 수 없는 타입의 파라미터를 받는 함수에 전달할 수 없다,
    
    ```kotlin
    strLen(x)
    ```
    

널이 될 수 있는 타입의 값을 사용하려면 null과 비교해야한다.

→ null과 비교하고 나면 컴파일러는 그 사실을 기억하고 null이 아님이 확실한 영역에서는 해당 값을 널이 될 수 없는 타입의 값처럼 사용할 수 있다.

```kotlin
fun strLenSafe(s: String?): Int = 
	if(s != null) s.length else 0
```

### 6.1.2 타입의 의미

타입

- 분류로 어떤 값을이 가능한지와 그 타입에 대해 수행할 수 있는 연산의 종류를 결정한다.

자바의 타입 시스템

→ 널을 제대로 다루지 못한다.

→ 변수에 선언된 타입이 있지만 널 여부를 추가로 검사하기 전에는 그 변수에 대해 어떤 연산을 수행할 수 있을지 알 수 없다.

<aside>
💡

NullPointerException 오류를 다루는 다른 방법

애노테이션을 사용해 값이 널이 될 수 있는지 여부를 표시하기도 한다.

null 값을 코드에서 절대로 쓰지 않는 것이다.

</aside>

코틀린의 널이 될 수 있는 타입은 이런 문제에 대해 종합적인 해법을 제공한다.

→ 널이 될 수 있는 타입과 널이 될 수 없는 타입을 구분하면 각 타입의 값에 대해 어떤 연산이 가능할지 명확히 이해할 수 있고, 실행 시점에 예외를 발생시킬 수 있는 연산을 판단할 수 있다.

→ 그런 연산을 아예 금지시킬 수 있다.

> 실행 시점에 널이 될 수 있는 타입이나 널이 될 수 없는 타입의 객체는 같다.
코틀린에서는 널이 될 수 있는 타입을 처리하는데 별도의 실행 시점 부가 비용이 들지 않는다.
> 

### 6.1.3 안전한 호출 연산자: ?.

?.

- null 검사와 메소드 호출을 한 번의 연산으로 수행한다.
- 호출하려는 값이 null이 아니라면 ?.은 일반 메소드 호출처럼 작동한다.
- 호출하려는 값이 null이면 이 호출은 무시되고 null이 결과 값이 된다.

![IMG_7FA5B3D98E3A-1.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/a73f38a2-2307-47f5-8a1d-4993f31fb956/IMG_7FA5B3D98E3A-1.jpeg)

메소드 호출뿐 아니라 프로퍼티를 읽거나 쓸 때도 안전한 호출을 사용할 수 있다.

### 6.1.4 엘비스 연산자: ?:

엘비스 연산자

- null 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있는 연산자

```kotlin
fun foo(s: String?) {
	val t: String = s ?: ""
}
```

→ 이항 연산자로 좌항을 계산한 값이 널인지 검사한다. 좌항 값이 널이 아니면 좌항 값을 결과로 하고, 좌항 값이 널이면 우항 값을 결과로 한다.

코틀린에서는 return이나 throw등의 연산도 식이다.

따라서 엘비스 연산자의 우항에 return, throw 등의 연산을 넣을 수 있고, 엘비스 연산자를 더욱 편하게 사용할 수 있다.

→ 함수의 전제조건을 검사하는 경우 유용하다.

### 6.1.5 안전한 캐스트: as?

as?

- 어떤 값을 지정한 타입으로 캐스트한다.
- 값을 대상 타입으로 변환할 수 없으면 null을 반환한다.

![IMG_04260454D8BC-1.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/c7ac6f0a-48fe-4803-af79-1f6d69fee878/IMG_04260454D8BC-1.jpeg)

- 안전한 캐스트를 사용할 때 일반 적인 패턴은 캐스트를 수행한 뒤에 엘비스 연산자를 사용하는 것이다.

```kotlin
class Person(val firstName: String, val lastName: String) {
	override fun equals(o: Any?): Boolean {
		val otherPerson = o as? Person ?: return false
		
		return otherPerson.fistName == firstName && otherPerson.lastName == lastName
	}
	
	override fun hashCode(): Int = 
		firstName.hashCode() * 37 + lastName.hashCode()
}
```

### 6.1.6 널 아님 단언: !!

!!

→ 어떤 값이든 널이 될 수 없는 타입으로 (강제로) 바꿀 수 있다.

→ 실제 널에 대해 !!를 적용하면 NPE가 발생한다.

![IMG_CA4AB7F6EFE1-1.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/b413233f-64f5-4108-b19a-d3d4e55367bc/IMG_CA4AB7F6EFE1-1.jpeg)

널 아닌 단언문이 더 나은 해법인 경우

- 호출된 함수가 언제나 다른 함수에서 널이 아닌 값을 전달받는다는 사실이 분명해서 굳이 널 검사를 다시 수행하고 싶지 않을 때 사용

!!를 널에 대해 사용해서 발생하는 예외의 스택 트레이스에는 어떤 파일의 몇 번째 줄인지에 대한 정보는 들어있지만 어떤 식에서 예외가 발생했는지에 대한 정보는 들어있지 않다.

→ 어떤 값이 널이었는지 확실히 하기 위해 여러 !! 단언문을 한줄에 함께 쓰는 일을 피해라.

### 6.1.7 let 함수

let 함수

- 안전한 호출 연산자와 함께 사용하면 원하는 식을 평가해서 결과가 널인지 검사한 다음에 그 결과를 변수에 넣는 작업을 간단한 식을 사용해 한꺼번에 처리할 수 있다.
- 자신의 수신 객체를 인자로 전달받은 람다에게 넘긴다.
- 널이 될 수 있는 값에 대해 안전한 ㅌ호출 구문을 사용해 let을 호출하되 널이 될 수 없는 타입을 인자로 받는 람다를 let에 전달한다.

![IMG_55B8EBD796A2-1.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/bb4d1eff-8612-4419-a1de-0b11bb53404c/IMG_55B8EBD796A2-1.jpeg)

- 여러 값이 널인지 검사해야 한다면 let 호출을 중쳡시켜서 처리할 수 있다.
    - 하지만 그런 경우 if를 사용해 모든 값을 한꺼번에 검사하는 편이 더 낫다.

### 6.1.8 나중에 초기화할 프로퍼티

나중에 초기화하는 프로퍼티

- lateinit 변경자 사용
- 항상 var
    - val 프로퍼티는 final 필드로 컴파일되며, 생성자 안에서 반드시 초기화해야한다.
- 널이 될 수 없는 타입이라 해도 더 이상 생성자 안에서 초기화 할 필요가 없다.
- 프로퍼티를 초기화하기 전에 프로퍼티에 접근하면 lateinit property has not been initialized라는 예외 발생한다.

### 6.1.9 널이 될 수 있는 타입 확장

널이 될 수 있는 타입에 대한 확장 함수를 정의하면 null 값을 다루는 강력한 도구로 활용할 수 있다.

→ 어떤 메소드를 호출하기 전에 수신 객체 역할을 하는 변수가 널이 될 수 없다고 보장하는 대신, 직접 변수에 대해 메소드를 호출해도 확장 함수인 메소드가 알아서 널을 처리해준다. 

→ 이런 처리는 확장 함수에서만 가능하다.

→ 일반 멤버 호출은 객체 인스턴스를 통해 디스패치 되므로 그 인스턴스가 널인지 여부를 검사하지 않는다.

- 일반 멤버 호출은 객체가 `null`인지 여부를 자동으로 체크하지 않으며, 호출 전에 `null` 확인이 필요합니다

안전한 호출 없이도 널이 될 수 있는 수신 객체 타입에 대해 선언된 확장 함수를 호출 가능하다.

![IMG_4D233D3AA640-1.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/3b314a4b-bec6-4ec1-bc5a-923d33d7e32e/IMG_4D233D3AA640-1.jpeg)

```kotlin
fun String?.isNullOrBlank(): Boolean = 
	this == null || this.isBlank()
```

- 널이 될 수 있는 타입에 대한 확장을 정의하면 널이 될 수 있는 값에 대해 그 확장 함수를 호출할 수 있다.
- 그 함수의 내부에서 this는 널이 될 수 있다.

> 직접 확장 함수를 작성한다면 그 확장함수를 널이 될 수 있는 타입에 대해 정의할지 여부를 고민할 필요가 있다.

처음에는 널이 될 수 있는 타입에 대한 확장함수를 정의하라
나중에 확장함수 안에서 널을 제대로 처리해라.
> 

### 6.1.10 타입 파라미터의 널 가능성

타입 파라미터 T를 클래스나 함수 안에서 타입 이름으로 사용하면 이름 끝에 물음표가 없더라도 T가 널이 될 수 있는 타입이다.

```kotlin
fun <T> printHashCode(t: T) {
	println(t?.hashCode())
}
```

타입 파라미터가 널이 아님을 확실히 하려면 널이 될 수 없는 타입 상한을 지정해야 한다.

→ 널이 될 수 없는 타입 상한을 지정하면 널이 될 수 있는 값을 거부하게 된다.

```kotlin
fun <T: Any> printHashCode(t: T) {
	println(t.hashCode())
}

```

### 6.1.11 널 가능성과 자바

자바와 코틀린 호환 시 null 문제

- 자바 코드에도 애노테이션으로 표시된 널 가능성 정보가 있다.
    - 이런 정보가 코드에 있으면 코틀린도 그 정보를 활용한다.
    - @Nullable String == String?

**플랫폼 타입**

- 코틀린이 널 관련 정보를 알 수 없는 타입을 말한다.
- 그 타입은 널이 될 수 있는 타입으로 처리해도 되고 널이 될 수 없는 타입으로 처리해도 된다.
- 컴파일러는 모든 연산을 허용한다.
- 널 안정성 검사를 중복 수행해도 아무 경고도 표시하지 않는다.
- 어떤 플랫폼 타입의 값이 널이 될 수도 있음을 알고 있다면 그 값을 사용하기 전에 널인지 검사할 수 있다.
- 어떤 플랫폼 타입의 값이 널이 아님을 알고 있다면 아무 널 검사 없이 그 값을 직접 사용해도 된다.

![IMG_F7882799B5C2-1.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/31ff58bc-b856-4476-b335-54afd03f47b2/IMG_F7882799B5C2-1.jpeg)

```kotlin
public class Person {
	private final String name;
	
	public Person(String name) {
		this.name = name;
	}
	
	public String getName() {
		return name;
	}
}
```

→ 코틀린 컴파일러는 이 경우 String 타입의 널 가능성에 대해 전혀 알지 못하기 때문에 널 가능성을 직접 처리해야 한다.

```kotlin
fun yellAt(person: Person) {
	println(person.name.toUpperCase() + "!!!")
}

yellAt(Person(null))
```

→ toUpperCase()가 수신 객체로 널을 받을 수 없다는 더 자세한 예외가 발생함.

코틀린 컴파일러는 공개 가시성인 코틀린 함수의 널이 아닌 타입인 파라미터와 수신 객체에 대한 널 검사를 추가해준다.

→ 공개 가시성 함수에 널 값을 사용하면 즉시 예외가 발생한다.

파라미터 값 검사는 함수 내부에서 파라미터를 사용하는 시점이 아니라 함수 호출 시점에 이뤄진다.

→ 잘못된 인자로 함수를 호출해도 그 인자가 여러 함수에 전달 돼 전혀 엉뚱한 위치에서 예외가 발생하지 않고 가능한 빨리 예외가 발생하기 때문에 예외가 발생해도 더 원인을 파악 가능하다.

<aside>
💡

코틀린이 왜 플랫폼 타입을 도입했는가?

모든 자바 타입을 널이 될 수 있는 타입으로 다루면 결코 널이 될 수 없는 값에 대해서도 불필요한 널 검사가 들어간다.
특히 제네릭을 다룰 때 널 안정성으로 얻는 이익보다 검사에 드는 비용이 훨씬 더 커진다. 따라서 코틀린 설계자들은 자바의 타입을 가져온 경우 프로그래머에게 그 타입을 제대로 처리할 책임을 부여하는 실용적인 접근 방법을 택했다.

</aside>

코틀린에서 플랫폼 타입을 선언할 수는 없다.

자바 코드에서 가져온 타입만 플랫폼 타입이 된다.

→ ! 표기는 String! 타입의 널 가능성에 대해 아무런 정보도 없다는 뜻이다.

**상속**

코틀린에서 자바 메소드를 오버라이드할 때 그 메소드의 파라미터와 반환 타입을 널이 될 수 있는 타입으로 선언할지 널이 될 수 없는 타입으로 선언할지 결정해야 한다.

자바 클래스나 인터페이스를 코틀린에서 구현할 경우 널 가능성을 제대로 처리하는 일이 중요한다.

→ 구현 메소드를 다른 코틀린 코드가 호출할 수 있으므로 코틀린 컴파일러는 널이 될 수 없는 타입으로 선언한 모든 파라미터에 대해 널이 아님을 검사하는 단언문을 만들어준다.

→ 자바 코드가 그 메소드에게 널 값을 넘기면 이 단언문이 발동돼 예외가 발생한다.
