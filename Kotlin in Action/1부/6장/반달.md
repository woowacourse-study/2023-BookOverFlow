# 06. 코틀린 타입 시스템

## 6.1 널 가능성

> 코틀린을 비롯한 최신 언어에서 **null에 대한 접근 방법은 가능한 한 이 문제를 실행시점에서 컴파일 시점으로 옮기는 것**이다.
> null이 될 수 있는지 여부를 타입 시스템에 추가함으로써 컴파일러가 여러 가지 오류를 컴파일 시 미리 감지해서 실행 시점에 발생할 수 있는 예외의 가능성을 줄일 수 있다.

### 6.1.1 널이 될 수 있는 타입

> 자바와는 다르게 코틀린에서는 `String?`, `Int?`, `MyCustomType?` 등 어떤 타입이든 타입 이름 뒤에 물음표를 붙이면 그 타입의 변수나 프로퍼티에 null 참조를 저장할 수 있다는 뜻이 된다.

> nullable 타입을 if 검사를 통해 null 이 아님을 검사하면 그 이후론 컴파일러가 알아서 null이 될 수 없는 타입으로 간주한다.


### 6.1.2 타입의 의미

> 타입은 분류(classification)로... 타입은 어떤 값들이 가능한지와 그 타입에 대해 수행할 수 있는 연산의 종류를 결정한다.

> 널이 될 수 있는 타입과 널이 될 수 없는 타입을 구분하면 각 타입의 값에 대해 어떤 연산이 가능할지 명확하게 이해할 수 있고, 실행 시점에 예외를 발생시킬 수 있는 연산은 판단할 수 있다. 따라서 그러한 연산을 아예 금지 시킬 수 있다.

> 실행 시점에 널이 될 수 있는 타입이나 널이 될 수 없는 타입의 객체는 같다.
> 널이 될 수 있는 타입은 널이 될 수 없는 타입을 감싼 래퍼 타입이 아니다.
> 모든 검사는 컴파일 시점에 수행된다.
> 다라서 코틀린에서는 널이 될 수 있는 타입을 처리하는 데 별도의 실행 시점 부가 비용이 들지 않는다.

### 6.1.3 안전한 호출 연산자: ?.

> `?.`은 null 검사와 메소드 호출을 한 번의 연산으로 수행한다.

```kotlin
string?.toUpperCase()
// 아래와 같다.
if(string != null) string.toUpperCase() else null
```

> 호출하려는 값이 null이 아니라면 일반 메서드 호출처럼 작동한다.
> 호출하려는 값이 null이면 이 호출은 무시되고 null이 결과 값이 된다.

> **안전한 호출의 결과 타입도 널이 될 수 있는 타입이다.**
> `string?.toUpperCase()`의 결과 타입은 `String?`이다.
> 따라서 체이닝을 하면 중간마다 ?가 들어있는 형태를 볼 수 있다.
> `this.company?.address?.country`

### 6.1.4 엘비스 연산자: ?:

> null 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있는 연산자인 엘비스 연산자(?:)를 제공한다.
> `person?.company ?: "백수"`

> 코틀린에서는 return이나 throw 등의 연산도 식이다.
> 따라서 엘비스 연산자의 우항에 return, throw 등의 연산을 넣을 수 있고, 엘비스 연산자를 더욱 편하게 사용할 수 있다.
> 이런 패턴은 함수의 전제 조건을 검사하는 경우 특히 유용하다.

### 6.1.5 안전한 캐스트: as?

> 코틀린의 as 는 자바 타입 캐스트와 마찬가지로 대상 값을 as로 지정한 타입으로 바꿀 수 없다면 `ClassCastException`이 발생한다.
> 물론 as를 사용할 때마다 is를 통해 미리 as로 변환 가능한 타입인지 검사해볼 수도 있다.
> 하지만 as?를 통해 간편하게 미리 검사할 수 있다.

```kotlin
if (object !is Person) return
object as Person

// 아래와 같다.

object as? Person ?: return
```

### 6.1.6 널 아님 단언: !!

> 널 아님 단언(non-null assertion)은 코틀린에서 널이 될 수 있는 타입의 값을 다룰 때 사용할 수 있는 도구 중에서 가장 단순하면서도 무딘 도구다.
> 느낌표를 이중으로 사용하면 어떤 값이든 널이 될 수 없는 타입으로 바꿀 수 있다.
> 실제 널에 대해 !!를 적용하면 NPE가 발생한다.

> 널 아님 단언 문이 더 나은 해법인 경우도 있다.
> 어떤 함수가 값이 널인지 검사한 다음에 다른 함수를 호출한다고 해도 컴파일러는 호출된 함수 안에서 안전하게 그 값을 사용할 수 있음을 인식할 수 없다.
> 호출된 함수가 언제나 다른 함수에서 널이 아닌 값을 전달받는다는 사실이 분명하다면 굳이 널 검사를 다시 수행하고 싶지는 않을 것이다.

> !!를 널에대해 사용해서 발생하는 에외의 스택트레이스에는 어떤 파일의 몇 번째 줄인지에 대한 정보는 들어있지만 어떤 식에서 예외가 발생했는지에 대한 정보는 들어있지 않다.
> 어떤 값이 널이었는지 확실히 하기 위해 여러 !! 단언문을 한 줄에 함께 쓰는 일을 피하라!
> `person.company!!.address!!.country` <- 이렇게 쓰면 어디가 예외인지 알기 힘들다.

### 6.1.7 let 함수

> let 함수를 안전한 호출 연산자와 함께 사용하면 원하는 식을 평가해서 결과가 널인지 검사한 다음에 그 결과를 변수에 넣는 작업을 간단한 식을 사용해 한꺼번에 처리할 수 있다.

> let을 사용하는 가장 흔한 용례는 널이 될 수 있는 값을 널이 아닌 값만 인자로 받는 함수에 넘기는 경우다.
> let 함수는 자신의 수신 객체를 인자로 전달받은 람다로 넘긴다.
> 널이 될 수 있는 값에 대해 안전한 호출 구문을 사용해 let을 호출하되 널이 될 수 없는 타입을 인자로 받는 람다를 let에 전달한다.
> 이렇게 하면 널이 될 수 있는 타입을 널이 될 수 없는 타입으로 바꿔서 람다에게 전달하게 되고,
> 만약 정말로 null이라면 아무 일도 일어나지 않는다.
> `email?.let { sendEmailTo(it) }`

### 6.1.8 나중에 초기화할 프로퍼티

> 프로퍼티를 나중에 초기화 하고 싶을 때 `lateinit` 변경자를 붙이면 프로퍼티를 나중에 초기화 할 수 있다.

> 나중에 초기화 하는 프로퍼티는 항상 var로 선언되어야 한다.

### 6.1.9 널이 될 수 있는 타입 확장

> 널이 될 수 있는 타입에 대한 확장 함수를 정의하면 null 값을 다루는 강력한 도구로 활용할 수 있다.
> 어떤 메서드를 호출하기 전에 수신 객체 역할을 하는 변수가 널이 될 수 없다고 보장하는 대신, 직접 변수에 대해 메서드를 호출해도 확장 함수인 메서드가 알아서 널을 처리해준다.
> 이런 처리는 확장 함수에서만 가능하다.

> `String?.isNullOrBlank` 이 딱 그런 케이스이다.

```kotlin
fun verifyUserInput(input: String?) {
	if (input.isNullOrBlank()) {
		println("값이 비었습니다.")
	}
}

verifyUserInput(null) // 아무런 예외가 발생하지 않는다.
```

> `input.isNullOrBlank()`
> 이처럼 안전한 호출 없이도 널이 될 수 있는 수신 객체 타입에 대해 선언된 확장 함수를 호출 가능하다.
> 함수는 null 값이 들어오는 경우 이를 적절히 처리한다.

```kotlin
fun String?.isNullOrBlank(): Boolean = this == null || this.isBlank() 
// 두번째 this 부턴 스마트 캐스트가 적용 되어있다.
```

### 6.1.10 타입 파라미터의 널 가능성

> 코틀린에서 함수나 클래스의 모든 타입 파라미터는 기본적으로 널이 될 수 있다.
> 널이 될 수 있는 타입을 포함하는 어떤 타입이라도 타입 파라미터를 대신할 수 있다.
> 따라서 **타입 파라미터 T를 클래스나 함수 안에서 타입 이름으로 사용하면 이름 끝에 물음표가 없더라도 T가 널이 될 수 있는 타입**이다.

```kotlin
fun <T> printHashCode(t: T) {
	println(t?.hashCode()) // T가 널이 될 수 있는 타입이라 안전한 호출을 사용
}

printHashCode(null) // T의 타입은 Any?로 추론된다.
// null
```

> 타입 파라미터가 널이 아님을 확실히 하려면 널이 될 수 없는 타입 상한을 지정해야한다.

```kotlin
fun <T: Any> printHashCode(t: T) {
	println(t.hashCode())
}

printHashCode(null)
// Error: Type parameter bound for T is not satisfied
```

### 6.1.11 널 가능성과 자바

> 자바의 어노테이션으로 표시된 널 가능성 정보에 따라 코틀린에서의 타입도 다르다.
> `@Nullable String`은 코틀린에서 `String?`이고 `@NotNull String`은 코틀린에서 `String`이다.
> 만약 이러한 널 가능성 어노테이션이 소스코드에 없는 경우는 자바의 타입이 코틀린의 플랫폼 타입이 된다.

#### 플랫폼 타입

> 플랫폼 타입은 코틀린이 널 관련 정보를 알 수 없는 타입을 말한다.
> 타입을 널이 될 수 있는 타입으로 처리해도 되고 널이 될 수 없는 타입으로 처리해도 된다.
> 이는 자바와 마찬가지로 플랫폼 타입에 대해 수행하는 모든 연산에 대한 책임은 온전히 여러분에게 있다는 뜻이다.
> 컴파일러는 모든 연산을 허용한다. 그치만 큰 힘에는 큰 책임이 따르듯 틀렸다면 NPE를 맞이한다.

> 대부분의 라이브러리는 널 관련 어노테이션을 쓰지 않는다.
> 그러니 널 검사 잘하자.

> 모든 자바 타입을 널이 될 수 있는 타입으로 간주하면 어떨까 하는 생각이 들 수 있겠지만,
> 그렇게 하면 계속 해서 널검사 혹은 안전한 캐스트를 수행해야하는데 이 비용이 더크다.

> 플랫폼 타입은 String! 이라는 표시처럼 !을 붙인 타입으로 추론되는데, 이건 타입의 널 가능성에 대해 아무 정보도 없다는 뜻이다.
> 개발자가 String?으로 사용하거나 String으로 타입을 바꿔 사용해도 된다.

#### 상속

> 코틀린에서 자바 메서드를 오버라이드할 때 그 메서드의 파라미터와 반환 타입을 널이 될 수 있는 타입으로 선언할지 널이 될 수 없는 타입으로 선언할지 결정해야한다.

```java
interface StringProcessor {
	void process(String value);
}
```

> 코틀린 컴파일러는 다음 두 구현을 다 받아들인다.

```kotlin
class StringPrinter: StringProcessor {
	override fun process(value: String) {
		println(value)
	}
}

class NullableStringPrinter: StringProcessor {
	override fun process(value: String?) {
		if (value != null) {
			println(value)
		}
	}
}
```

> 자바 클래스나 인터페이스를 코틀린에서 구현할 경우 널 가능성을 제대로 처리하는 일이 중요하다.
> 구현 메서드를 다른 코틀린 코드가 호출할 수 있으므로 코틀린 컴파일러는 널이 될 수 없는 타입으로 선언한 모든 파라미터에 대해 널이 아님을 검사하는 단언문을 만들어 준다.
> 설령 파라미터를 메서드 안에서 결코 사용하지 않아도 이런 예외는 피할 수 없다.


## 6.2 코틀린의 원시 타입

### 6.2.1 원시타입

> 원시타입의 변수에는 그 값이 직접 들어가지만, 참조 타입의 변수에는 메모리상의 객체 위치가 들어간다.
> 코틀린에서는 원시타입과 래퍼타입을 구분하지 않는다.

> Int와 같은 코틀린 타입에는 널 참조가 들어갈 수 없기 때문에 쉽게 상응하는 자바 원시 타입으로 컴파일할 수 있다.
> 마찬가지로 반대로 자바 원시 타입의 값은 결코 널이 될 수 없으므로 자바 원시타입을 코틀린에서 사용할 때도 널이 될 수 없는 타입으로 취급할 수 있다.

### 6.2.2 널이 될 수 있는 원시 타입

> null 참조를 자바의 참조 타입의 변수에만 대입할 수 있기 때문에 널이 될 수 있는 코틀린 타입은 자바 원시 타입으로 표현할 수 없어서 자바의 래퍼 타입으로 컴파일 된다.
> 제네릭 클래스의 경우에도 래퍼 타입을 사용한다.
> JVM은 타입 인자로 원시 타입을 허용하지 않는다. 따라서 자바나 코틀린 모두에서 제네릭 클래스는 항상 래퍼 타입을 사용해야 한다.
> 원시 타입의 컬렉션을 원한다면 배열을 사용해야한다.


### 6.2.3 숫자 변환

> 코틀린은 한 타입의 숫자를 다른 타입의 숫자로 자동 변환하지 않는다. 결과 타입이 허용하는 숫자의 범위가 원래 타입의 범위보다 넓은 경우조차도 자동 변환은 불가능하다.
> 개발자의 혼란을 피하기 위해 타입 변환을 명시하기로 결정한 것이다.
> 자바에서 두 박스 타입 간의 equals 메서드는 그안의 들어있는 값이 아니라 박스 타입 객체를 비교한다.
> `new Integer(42).equals(new Long(42))`는 false다.

> `42L` 이나 `42.0f` 처럼 상수 뒤에 타입을 표현하는 문자를 붙이면 변환이 필요없다.
> 개발자가 직접 변환하지 않아도 숫자 리터럴을 타입이 알려진 변수에 대입하거나 함수에게 인자로 넘기면 컴파일러가 필요한 변환을 자동으로 해준다.


### 6.2.4 Any, Any?

> 자바에서는 Object가 클래스 계층의 최상위 타입이듯 코틀린에서는 Any 타입이 모든 널이 될 수 없는 타입의 조상 타입이다.
> 하지만 자바에서는 참조 타입만 Object를 정점으로 하는 타입 계층에 포함되며, 원시 타입은 그런 계층에 들어있지 않다.
> 코틀린에서는 Any가 Int 등의 원시 타입을 포함한 모든 타입의 조상 타입이다.
> 자바와 마찬가지로 코틀린에서도 원시 타입 값을 Any 타입의 변수에 대입하면 자동으로 값을 객체로 감싼다.

`val answer: Any = 42`

> 내부에서 Any는 java.lang.Object에 대응한다.
> 자바 메서드에서 Object를 인자로 받거나 반환하면 코틀린에서는 Any로 그 타입을 취급한다.

> toString, equals, hashCode라는 세 메서드는 Any에 정의되어있으며 서브 클래스들이 상속받아 사용하는것이다.

### 6.2.5 Unit 타입

> 코틀린의 Unit 타입은 자바 void와 같은 기능을 한다.
> 관심을 가질만한 내용을 전혀 반환하지 않는 함수의 반환 타입으로 Unit을 쓸 수 있다.

`fun f(): Unit { ... }`

> 이는 반환 타입 선언 없이 정의한 블록이 본문인 함수와 같다.

`fun f() { ... }`

#### 코틀린의 Unit과 자바 void의 차이?

- Unit은 모든 기능을 갖는 일반적인 타입이며, void와 달리 Unit을 타입 인자로 쓸 수 있다.
- Unit 타입에 속한 값은 단 하나 뿐이며, 그 이름도 Unit이다.
- Unit 타입의 함수는 Unit 값을 묵시적으로 반환한다.

## 6.2.6 Nothing 타입

> 코틀린에는 결코 성공적으로 값을 돌려주는 일이 없으므로 반환값이라는 개념 자체가 의미 없는 함수가 일부 존재한다.
> 그런 함수를 호출하는 코드를 분석하는 경우 함수가 정상적으로 끝나지 않는다는 사실을 알면 유용하다.
> 그런 경우를 표현하기 위해 코틀린에는 Nothing이라는 특별한 반환 타입이 있다.

```kotlin
fun fail(message: String): Nothing {
	throw IllegalStateException(message)
}
```

> Nothing 타입은 아무 값도 포함하지 않는다.
> 따라서 Nothing은 함수의 반환 타입이나 반환 타입으로 쓰일 타입 파라미터로만 쓸 수 있다.

> Nothing을 반환하는 함수를 엘비스 연산자의 우항에 사용해서 전제조건을 검사할 수 있다.

```kotlin
val address = company.address ?: fail("No address")
```


## 6.3 컬렉션과 배열

### 6.3.1 널 가능성과 컬렉션

> `List<Int?>` 와 `List<Int>?` 는 엄연히 다르다.
> 왼쪽은 원소가 널이 될 수 있는 타입, 오른쪽은 리스트 자체가 널이 될 수 있는 타입이다.

> 만일 널이 될 수 있는 원소를 가진 리스트에서 널이 아닌 값만 솎아내고 싶다면 `filterNotNull` 함수를 사용하자

### 6.3.2 읽기 전용과 변경 가능한 컬렉션

> 코틀린 컬렉션과 자바 컬렉션을 나누는 가장 중요한 특성 하나는 코틀린에선 컬렉션 안의 데이터에 접근하는 인터페이스와 컬렉션 안의 데이터를 변경하는 인터페이스를 분리했다는 점이다.

`kotlin.collections.Collection`
- 원소 이터레이션
- 컬렉션 크기
- 값이 컬렉션 안에 들어있는지 검사
- 그외 컬렉션에서의 데이터를 읽는 여러 다른 연산을 수행할 수 있다.

`kotlin.collections.MutableCollection`
- Collection을 확장
- 원소 추가
- 원소 삭제
- 원소 모두 지우기

> 어떤 동일한 컬렉션 객체를 가리키는 다른 타입의 참조들(읽기 전용, 변경 가능 리스트)이 존재할 때 이 컬렉션을 참조하는 다른 코드를 호출하거나 병렬 실행한다면 컬렉션을 사용하는 도중에 다른 컬렉션이 그 컬렉션의 내용을 변경하는 상황이 생길 수 있고, 이런 상황에서는 `ConcurrentModificationException` 이나 다른 오류가 발생할 수 있다.
>
> 따라서 읽기 전용 컬렉션이 항상 스레드 안전하지 않다는 점을 명심해야한다.
> 다중 스레드 환경에서 데이터를 다루는 경우 그 데이터를 적절히 동기화 하거나 동시 접근을 허용하는 데이터 구조를 활용해야 한다.

### 6.3.3 코틀린 컬렉션과 자바

> 모든 코틀린 컬렉션은 그에 상응하는 자바 컬렉션 인터페이스의 인스턴스라는 점은 사실이다.
> 따라서 코틀린과 자바 사이를 오갈 때 아무 변환도 필요 없다.
> 또한 래퍼 클래스를 만들거나 데이터를 복사할 필요도 없다.

> 자바 메서드를 호출하되 컬렉션을 인자로 넘겨야 한다면 따로 변환하거나 복사하는 등의 추가 작업 없이 직접 컬렉션을 넘기면 된다.
> 하지만 이렇게 되면 컬렉션의 변경 가능성과 관련해 중요한 문제가 생긴다.
> 자바는 읽기 전용 컬렉션과 변경 가능 컬렉션을 구분하지 않으므로, 코틀린에서 읽기 전용 객체라도 자바 코드에서는 그 컬렉션 객체의 내용을 변경할 수 있다.
> 따라서 컬렉션을 자바로 넘기는 코틀린 프로그램을 작성한다면 호출하려는 자바 코드가 컬렉션을 변경할지 여부에 따라 올바른 파라미터 타입을 사용할 책임은 개발자에게 있다.


### 6.3.4 컬렉션을 플랫폼 타입으로 다루기

> 자바 코드에서 정의한 타입을 코틀린에서는 플랫폼 타입으로 간주한다.
> 플랫폼 타입의 경우 코틀린 쪽에는 널 관련 정보가 없다.
> 따라서 컴파일러는 코틀린 코드가 그 타입을 널이 될 수 있는 타입이나 널이 될 수 없는 타입 어느 쪽으로든 사용할 수 있게 허용한다.

> 컬렉션 타입이 시그니처에 들어간 자바 메소드 구현을 오버라이드하려는 경우 읽기 전용 컬렉션과 변경 가능 컬렉션의 차이가 문제가 된다
> 플랫폼 타입에서 널 가능성을 다룰 때처럼 이런 경우에도 오버라이드하려는 메소드의 자바 컬렉션 타입을 어떤 코틀린 컬렉션 타입으로 표현할지 결정해야 한다.

> 다음과 같은 조건을 판단하여 결정하면 된다.

- 컬렉션이 널이 될 수 있는가?
- 컬렉션의 원소가 널이 될 수 있는가?
- 오버라이드하는 메소드가 컬렉션을 변경할 수 있는가?

### 6.3.5 객체의 배열과 원시 타입의 배열

코틀린에서 배열을 만드는 방법은 다양하다.
- arrayOf
- arrayOfNulls
- Array(생성자)

> 코틀린에서는 배열을 인자로 받는 자바 함수를 호출하거나 vararg 파라미터를 받는 코틀린 함수를 호출하기 위해 가장 자주 배열을 만든다.
> 하지만 이때 데이터가 이미 컬렉션에 들어 있다면 컬렉션을 배열로 변환해야 한다.
> `toTypedArray` 메서드를 사용하면 쉽게 컬렉션을 배열로 바꿀 수 있다.

> 코틀린은 원시 타입의 배열을 표현하는 별도 클래스를 각 원시타입 마다 하나씩 제공한다.
> ex. IntArray, BooleanArray
> 이 모든 타입은 자바 원시 타입 배열인 `int[], byte[]` 등으로 컴파일 된다.

```kotlin
val strings = listOf("a", "b", "c")
println("%s/%s/%s".format(*strings.toTypedArray())) 
// vararg 인자를 넘기기 위해 스프레드 연산자 사용
```

