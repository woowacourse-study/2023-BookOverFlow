# 06. 코틀린 타입 시스템

## 6.1 널 가능성

> 코틀린을 비롯한 최신 언어에서 **null에 대한 접근 방법은 가능한 한 이 문제를 실행시점에서 컴파일 시점으로 옮기는 것**이다.
> null이 될 수 있는지 여부를 타입 시스템에 추가함으로써 컴파일러가 여러 가지 오류를 컴파일 시 미리 감지해서 실행 시점에 발생할 수 있는 예외의 가능성을 줄일 수 있다.

### 6.1.1 널이 될 수 있는 타입

> 자바와는 다르게 코틀린에서는 `String?`, `Int?`, `MyCustomType?` 등 어떤 타입이든 타입 이름 뒤에 물음표를 붙이면 그 타입의 변수나 프로퍼티에 null 참조를 저장할 수 있다는 뜻이 된다.

> nullable 타입을 if 검사를 통해 null 이 아님을 검사하면 그 이후론 컴파일러가 알아서 null이 될 수 없는 타입으로 간주한다.


### 6.1.2 타입의 의미

> 타입은 분류(classification)로... 타입은 어떤 값들이 가능한지와 그 타입에 대해 수행할 수 있는 연산의 종류를 결정한다.

> 널이 될 수 있는 타입과 널이 될 수 없는 타입을 구분하면 각 타입의 값에 대해 어떤 연산이 가능할지 명확하게 이해할 수 있고, 실행 시점에 예외를 발생시킬 수 있는 연산은 판단할 수 있다. 따라서 그러한 연산을 아예 금지 시킬 수 있다.

> 실행 시점에 널이 될 수 있는 타입이나 널이 될 수 없는 타입의 객체는 같다.
> 널이 될 수 있는 타입은 널이 될 수 없는 타입을 감싼 래퍼 타입이 아니다.
> 모든 검사는 컴파일 시점에 수행된다.
> 다라서 코틀린에서는 널이 될 수 있는 타입을 처리하는 데 별도의 실행 시점 부가 비용이 들지 않는다.

### 6.1.3 안전한 호출 연산자: ?.

> `?.`은 null 검사와 메소드 호출을 한 번의 연산으로 수행한다.

```kotlin
string?.toUpperCase()
// 아래와 같다.
if(string != null) string.toUpperCase() else null
```

> 호출하려는 값이 null이 아니라면 일반 메서드 호출처럼 작동한다.
> 호출하려는 값이 null이면 이 호출은 무시되고 null이 결과 값이 된다.

> **안전한 호출의 결과 타입도 널이 될 수 있는 타입이다.**
> `string?.toUpperCase()`의 결과 타입은 `String?`이다.
> 따라서 체이닝을 하면 중간마다 ?가 들어있는 형태를 볼 수 있다.
> `this.company?.address?.country`

### 6.1.4 엘비스 연산자: ?:

> null 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있는 연산자인 엘비스 연산자(?:)를 제공한다.
> `person?.company ?: "백수"`

> 코틀린에서는 return이나 throw 등의 연산도 식이다.
> 따라서 엘비스 연산자의 우항에 return, throw 등의 연산을 넣을 수 있고, 엘비스 연산자를 더욱 편하게 사용할 수 있다.
> 이런 패턴은 함수의 전제 조건을 검사하는 경우 특히 유용하다.

### 6.1.5 안전한 캐스트: as?

> 코틀린의 as 는 자바 타입 캐스트와 마찬가지로 대상 값을 as로 지정한 타입으로 바꿀 수 없다면 `ClassCastException`이 발생한다.
> 물론 as를 사용할 때마다 is를 통해 미리 as로 변환 가능한 타입인지 검사해볼 수도 있다.
> 하지만 as?를 통해 간편하게 미리 검사할 수 있다.

```kotlin
if (object !is Person) return
object as Person

// 아래와 같다.

object as? Person ?: return
```

### 6.1.6 널 아님 단언: !!

> 널 아님 단언(non-null assertion)은 코틀린에서 널이 될 수 있는 타입의 값을 다룰 때 사용할 수 있는 도구 중에서 가장 단순하면서도 무딘 도구다.
> 느낌표를 이중으로 사용하면 어떤 값이든 널이 될 수 없는 타입으로 바꿀 수 있다.
> 실제 널에 대해 !!를 적용하면 NPE가 발생한다.

> 널 아님 단언 문이 더 나은 해법인 경우도 있다.
> 어떤 함수가 값이 널인지 검사한 다음에 다른 함수를 호출한다고 해도 컴파일러는 호출된 함수 안에서 안전하게 그 값을 사용할 수 있음을 인식할 수 없다.
> 호출된 함수가 언제나 다른 함수에서 널이 아닌 값을 전달받는다는 사실이 분명하다면 굳이 널 검사를 다시 수행하고 싶지는 않을 것이다.

> !!를 널에대해 사용해서 발생하는 에외의 스택트레이스에는 어떤 파일의 몇 번째 줄인지에 대한 정보는 들어있지만 어떤 식에서 예외가 발생했는지에 대한 정보는 들어있지 않다.
> 어떤 값이 널이었는지 확실히 하기 위해 여러 !! 단언문을 한 줄에 함께 쓰는 일을 피하라!
> `person.company!!.address!!.country` <- 이렇게 쓰면 어디가 예외인지 알기 힘들다.

### 6.1.7 let 함수

> let 함수를 안전한 호출 연산자와 함께 사용하면 원하는 식을 평가해서 결과가 널인지 검사한 다음에 그 결과를 변수에 넣는 작업을 간단한 식을 사용해 한꺼번에 처리할 수 있다.

> let을 사용하는 가장 흔한 용례는 널이 될 수 있는 값을 널이 아닌 값만 인자로 받는 함수에 넘기는 경우다.
> let 함수는 자신의 수신 객체를 인자로 전달받은 람다로 넘긴다.
> 널이 될 수 있는 값에 대해 안전한 호출 구문을 사용해 let을 호출하되 널이 될 수 없는 타입을 인자로 받는 람다를 let에 전달한다.
> 이렇게 하면 널이 될 수 있는 타입을 널이 될 수 없는 타입으로 바꿔서 람다에게 전달하게 되고,
> 만약 정말로 null이라면 아무 일도 일어나지 않는다.
> `email?.let { sendEmailTo(it) }`

### 6.1.8 나중에 초기화할 프로퍼티

> 프로퍼티를 나중에 초기화 하고 싶을 때 `lateinit` 변경자를 붙이면 프로퍼티를 나중에 초기화 할 수 있다.

> 나중에 초기화 하는 프로퍼티는 항상 var로 선언되어야 한다.

### 6.1.9 널이 될 수 있는 타입 확장

> 널이 될 수 있는 타입에 대한 확장 함수를 정의하면 null 값을 다루는 강력한 도구로 활용할 수 있다.
> 어떤 메서드를 호출하기 전에 수신 객체 역할을 하는 변수가 널이 될 수 없다고 보장하는 대신, 직접 변수에 대해 메서드를 호출해도 확장 함수인 메서드가 알아서 널을 처리해준다.
> 이런 처리는 확장 함수에서만 가능하다.

> `String?.isNullOrBlank` 이 딱 그런 케이스이다.

```kotlin
fun verifyUserInput(input: String?) {
	if (input.isNullOrBlank()) {
		println("값이 비었습니다.")
	}
}

verifyUserInput(null) // 아무런 예외가 발생하지 않는다.
```

> `input.isNullOrBlank()`
> 이처럼 안전한 호출 없이도 널이 될 수 있는 수신 객체 타입에 대해 선언된 확장 함수를 호출 가능하다.
> 함수는 null 값이 들어오는 경우 이를 적절히 처리한다.

```kotlin
fun String?.isNullOrBlank(): Boolean = this == null || this.isBlank() 
// 두번째 this 부턴 스마트 캐스트가 적용 되어있다.
```

### 6.1.10 타입 파라미터의 널 가능성

> 코틀린에서 함수나 클래스의 모든 타입 파라미터는 기본적으로 널이 될 수 있다.
> 널이 될 수 있는 타입을 포함하는 어떤 타입이라도 타입 파라미터를 대신할 수 있다.
> 따라서 **타입 파라미터 T를 클래스나 함수 안에서 타입 이름으로 사용하면 이름 끝에 물음표가 없더라도 T가 널이 될 수 있는 타입**이다.

```kotlin
fun <T> printHashCode(t: T) {
	println(t?.hashCode()) // T가 널이 될 수 있는 타입이라 안전한 호출을 사용
}

printHashCode(null) // T의 타입은 Any?로 추론된다.
// null
```

> 타입 파라미터가 널이 아님을 확실히 하려면 널이 될 수 없는 타입 상한을 지정해야한다.

```kotlin
fun <T: Any> printHashCode(t: T) {
	println(t.hashCode())
}

printHashCode(null)
// Error: Type parameter bound for T is not satisfied
```

### 6.1.11 널 가능성과 자바

> 자바의 어노테이션으로 표시된 널 가능성 정보에 따라 코틀린에서의 타입도 다르다.
> `@Nullable String`은 코틀린에서 `String?`이고 `@NotNull String`은 코틀린에서 `String`이다.
> 만약 이러한 널 가능성 어노테이션이 소스코드에 없는 경우는 자바의 타입이 코틀린의 플랫폼 타입이 된다.

#### 플랫폼 타입

> 플랫폼 타입은 코틀린이 널 관련 정보를 알 수 없는 타입을 말한다.
> 타입을 널이 될 수 있는 타입으로 처리해도 되고 널이 될 수 없는 타입으로 처리해도 된다.
> 이는 자바와 마찬가지로 플랫폼 타입에 대해 수행하는 모든 연산에 대한 책임은 온전히 여러분에게 있다는 뜻이다.
> 컴파일러는 모든 연산을 허용한다. 그치만 큰 힘에는 큰 책임이 따르듯 틀렸다면 NPE를 맞이한다.

> 대부분의 라이브러리는 널 관련 어노테이션을 쓰지 않는다.
> 그러니 널 검사 잘하자.

> 모든 자바 타입을 널이 될 수 있는 타입으로 간주하면 어떨까 하는 생각이 들 수 있겠지만,
> 그렇게 하면 계속 해서 널검사 혹은 안전한 캐스트를 수행해야하는데 이 비용이 더크다.

> 플랫폼 타입은 String! 이라는 표시처럼 !을 붙인 타입으로 추론되는데, 이건 타입의 널 가능성에 대해 아무 정보도 없다는 뜻이다.
> 개발자가 String?으로 사용하거나 String으로 타입을 바꿔 사용해도 된다.

#### 상속

> 코틀린에서 자바 메서드를 오버라이드할 때 그 메서드의 파라미터와 반환 타입을 널이 될 수 있는 타입으로 선언할지 널이 될 수 없는 타입으로 선언할지 결정해야한다.

```java
interface StringProcessor {
	void process(String value);
}
```

> 코틀린 컴파일러는 다음 두 구현을 다 받아들인다.

```kotlin
class StringPrinter: StringProcessor {
	override fun process(value: String) {
		println(value)
	}
}

class NullableStringPrinter: StringProcessor {
	override fun process(value: String?) {
		if (value != null) {
			println(value)
		}
	}
}
```

> 자바 클래스나 인터페이스를 코틀린에서 구현할 경우 널 가능성을 제대로 처리하는 일이 중요하다.
> 구현 메서드를 다른 코틀린 코드가 호출할 수 있으므로 코틀린 컴파일러는 널이 될 수 없는 타입으로 선언한 모든 파라미터에 대해 널이 아님을 검사하는 단언문을 만들어 준다.
> 설령 파라미터를 메서드 안에서 결코 사용하지 않아도 이런 예외는 피할 수 없다.