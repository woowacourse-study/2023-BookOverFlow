# 3장 함수 정의와 호출

## 3.1 코틀린에서 컬렉션 만들기

```kotlin
val set = hashSetOf(1, 7, 53)
val list = arrayListOf(1, 7, 53)
val map = hashMapOf(1 to "one", 7 to "seven", 53 to "fifty-three")

>>> println(set.javaClass)
class java.util.HashSet
>>> println(list.javaClass)
class java.util.ArrayList
>>> println(map.javaClass)
class java.util.HashMap
```

→ 코틀린이 자신만의 컬렉션 기능을 제공하지 않는다.

코틀린이 자체 컬렉션을 제공하지 않는 이유

- 표준 자바 컬렉션을 활용하면 자바 코드와 상호작용하기가 훨씬 더 쉽다.

→ 자바에서 코틀린 함수를 호출하거나 코틀린에서 자바 함수를 호출할 때 자바와 코틀린 컬렉션을 서로 변환할 필요가 없다.

코틀린 컬렉션은 자바 컬렉션과 똑같은 클래스지만 자바보다 더 많은 기능을 쓸 수 있다.

ex) last(), max()

## 3.2 함수를 호출하기 쉽게 만들기

자바 컬렉션에는 디폴트 toString 구현이 들어있다. 하지만 그 디폴트 toString의 출력 형식은 고정되어 있다.

```kotlin
val list = listOf(1, 2, 3)
println(list)
// [1, 2, 3]
```

코틀린으로 컬렉션을 원하는 대로 출력할 수 있는 함수를 구현(코틀린에서 지원하는 기능을 사용하지 않고)

```kotlin
fun <T> joinToString(
	collection: Collection<T>,
	seperator: String,
	prefix: String,
	postfix: String
) : String {
	val result = StringBuilder(prefix)
	
	for ((index, element) in collection.withIndex()) {
		if (index > 0) result.append(seperator)
		result.append(element)
	}
	
	result.append(postfix)
	return result.toString()
}
```

→ 이 함수는 제네릭하다. ( 어떤 타입의 값을 원소로 하는 컬렉션이든 처리할 수 있다.)

### 3.2.1 이름 붙인 인자

함수 호출 부분의 가독성을 높이기 위해 코틀린에서는 다음과 같이 할 수 있다.

```kotlin
joinToString(collection, seperator = " ", prefix = " ", postfix = " ")
```

→ 코틀린으로 작성한 함수를 호출할 때는 함수에 전달하는 인자 중 일부 이름을 명시할 수 있다.

→ 호출 시 인자 중 어느 하나라도 이름을 명시하고 나면 혼동을 막기 위해 그 뒤에 오는 모든 인자는 이름을 꼭 명시해야한다.

### 3.2.2 디폴트 파라미터 값

코틀린에서는 함수 선언에서 파라미터의 디폴트 값을 지정할 수 있다.

```kotlin
fun <T> joinToString(
	collection: Collection<T>,
	separator: String = ", ",
	prefix: String = "".
	postfix: String = ""
): String
```

→ 함수를 호출할 때 모든 인자를 쓸 수도 있고, 일부를 생략할 수도 있다.

```kotlin
>>> joinToString(list, ", ", "", "")
1, 2, 3
>>> joinToString(list)
1, 2, 3
>>> joinToString(list, "; ")
1; 2; 3
```

일반 호출 문법을 사용하려면 함수를 선언할 때와 같은 순서로 인자를 지정해야 한다.

이름 붙은 인자를 사용하는 경우에는 인자 목록의 중간에 있는 인자를 생략하고, 지정하고 싶은 인자를 이름을 붙여서 순서와 관계없이 지정할 수 있다.

```kotlin
joinToString(list, postfix = ";", prefix="# ")
// # 1, 2, 3;
```

함수의 디폴트 파라미터 값은 함수를 호출하는 쪽이 아니라 함수 선언 쪽에서 지정된다.

어떤 클래스 안에 정의된 함수의 디폴트 값을 바꾸고 그 클래스가 포함된 파일을 재컴파일하면 그 함수를 호출하는 코드 중에 값을 지정하지 않은 모든 인자는 자동으로 바뀐 디폴트 값을 적용받는다.

**@JvmOverloads**

- 함수에 추가하면 코틀린 컴파일러가 자동으로 맨 마지막 파라미터로부터 파라미터를 하나씩 생략한 오버로딩한 자바 메서드를 추가해준다.

### 3.2.3 정적인 유틸리티 클래스 없애기: 최상위 함수와 프로퍼티

자바 → 모든 코드를 클래스의 메소드로 작성해야 한다.

→ 무의미한 클래스가 발생할 수 있다.

코틀린은 함수를 직접 소스 파일의 최상위 수준, 모든 다른 클래스의 밖에 위치시키면 된다.

그런 함수들은 여전히 그 파일의 맨 앞에 정의된 패키지의 멤버 함수이므로 다른 패키지에서 그 함수를 사용하고 싶을 때는 그 함수가 정의된 패키지를 임포트해야만 한다.

```kotlin
package strings

fun joinToString(): String { }
```

JVM이 클래스 안에 들어있는 코드만을 실행할 수 있기 때문에 컴파일러는 이 파일을 컴파일할 때 새로운 클래스를 정의해준다.

```kotlin
/* 자바 */
package strings;

public class JoinKt {
	public static String joinToString() { }
}
```

코틀린 컴파일러가 생성하는 클래스의 이름은 최상위 함수가 들어있던 코틀린 소스 파일의 이름과 대응한다.

코틀린 파일의 모든 최상위 함수는 이 클래스의 정적인 메소드가 된다.

→ 자바에서 joinToString을 호출하기 쉽다.

```kotlin
/* 자바 */
import strings.joinKt;

JoinKt.joinToString(list, ", ", "","");
```

**파일에 대응하는 클래스의 이름 변경하기**

@JvmName 어노테이션 사용

→ 파일의 맨 앞, 패키지 이름 선언 이전에 위치해야 한다.

```kotlin
@file:JvmName("StringFunctions")
package strings
fun joinToString(): String { }
```

```kotlin
/* 자바 */
import strings.StringFunctions;
StringFunctions.joinToString(list, ", ", "", "");
```

**최상위 프로퍼티**

- 프로퍼티도 파일의 최상위 수준에 놓을 수 있다.

```kotlin
var opCount = 0

fun performOperation() {
	opCount++
	// ...
}

fun reportOperationCount() {
	println("Operation performed $opCount times")
}
```

→ 이런 프로퍼티의 값은 정적 필드에 저장된다.

- 접근자 메소드를 통해 자바 코드에 노출된다.
- const 변경자를 추가하면 프로퍼티를 public static final 필드로 컴파일하게 만들 수 있다.

```kotlin
const val UNIX_LINE_SEPERATOR = "\n"

/* 자바 */
public static final String UNIX_LINE_SEPERATOR = "\n";
```

## 3.3 메소드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티

확장함수

- 어떤 클래스의 멤버 메소드인 것처럼 호출할 수 있지만 그 클래스의 밖에 선언된 함수
- 확장함수 만드려면 추가하려는 함수 이름 앞에 그 함수가 확장할 클래스의 이름을 덧붙이기만 하면된다.
    - 클래스의 이름 - 수신 객체 타입(확장이 정의될 클래스의 타입),
    - 확장 함수가 호출되는 대상이 되는 값 - 수신 객체(그 클래스에 속한 인스턴스 객체)
    
    ```kotlin
    fun String.lastChar(): Char = this.get(this.length - 1)
    ```
    
- 함수 본문에도 this를 사용, 생략 가능하다.
- 일반적인 인스턴스 메소드의 내부에서와 마찬가지로 수신 객체의 메소드나 프로퍼티를 바로 사용할 수 있다.
- 캡슐화를 깨지는 않는다.
    - 확장 함수 안에서는 클래스 내부에서만 사용할 수 있는 private 멤버나 protected 멤버를 사용할 수 없다.

### 3.3.1 임포트와 확장 함수

확장 함수를 사용하기 위해서는 그 함수를 다른 클래스나 함수와 마찬가지로 임포트해야만 한다.

```kotlin
import strings.lastChar
val c = "Kotlin".lastChar()
```

```kotlin
import strings.*
val c = "Kotlin".lastChar()
```

as 키워드를 사용하면 임포트한 클래스나 함수를 다른 이름으로 부를 수 있다.

```kotlin
import strings.lastChar as last
val c = "Kotlin".last()
```

확장 함수는 코틀린 문법상 반드시 짧은 이름을 써야 하기 때문에 임포트 시 이름을 바꾸는 것이 확장 함수의 이름 충돌을 해결하는 유일한 방법이다.

### 3.3.2 자바에서 확장 함수 호출

확장함수는 수신 객체를 첫 번째 인자로 받는 정적 메소드

→ 확장 함수를 호출해도 다른 어댑터 객체나 실행 시점 부가 비용이 들지 않는다.

→ 자바에서 확장 함수 사용하기 편하다. ( 정적 메소드를 호출하면서 첫 번째 인자로 수신 객체를 넘기기만 하면 된다.)

```kotlin
char c = StringUtilKt.lastChar("Java")
```

### 3.3.3 확장 함수로 유틸리티 함수 정의

joinToString 함수의 최종 버전

```kotlin
fun <T> Collection<T>.joinToString(
	separator: String = ", ",
	prefix: String = "",
	postfix: String = ""
): String {
	val result = StringBuilder(prefix)
	
	for ((index, element) in this.withIndex()) {
		if (index > 0) result.append(separator)
		result.append(element)
	}
	
	result.append(postfix)
	return result.toString()
}
```

### 3.3.4 확장 함수는 오버라이드할 수 없다.

```kotlin
open class View {
	open fun click() = println("View clicked")
}

class Button: View() {
	override fun click() = println("Button clicked")
}
```

확장 함수는 클래스의 일부가 아니다. 확장 함수는 클래스 밖에 선언된다.

→ 확장 함수를 호출할 때 수신 객체로 지정한 변수의 정적 타입에 의해 어떤 확장함수가 호출될지 결정되지, 그 변수에 저장된 객체의 동적인 타입에 의해 확장 함수가 결정되지 않는다. 

→ 확장 함수는 오버라이드 할 수 없다.

![IMG_72EA9C8292F4-1.jpeg](https://github.com/user-attachments/assets/594bf011-69f2-45a7-9486-31c947a03b37)

```kotlin
fun View.showOff() = println("I'm a view!")
fun Button.showOff() = println("I'm a button!")
>>> >>> val view: View = Button()
>>> view.showOff()
I'm a view!
```

→ view가 가리키는 객체의 실제 타입이 Button이지만, 이 경우 view의 타입이 View이기 때문에 무조건 View의 확장 함수가 호출된다.

코틀린은 호출될 확장 함수를 정적으로 결정하기 때문에 확장 함수를 오버라이드 할 수 없다.

<aside>
💡

어떤 클래스를 확장한 함수와 그 클래스의 멤버 함수의 이름과 시그니처가 같다면 확장함수가 아니라 멤버 함수가 호출된다.(멤버 함수의 우선순위가 더 높다)

</aside>

### 3.3.5 확장 프로퍼티

- 확장 프로퍼티를 사용하면 기존 클래스 객체에 대한 프로퍼티 형식의 구문으로 사용할 수 있는 API를 추가할 수 있다.
- 프로퍼티라는 이름으로 불리기는 하지만 상태를 저장할 적절한 방법이 없기 때문에 아무 상태도 가질 수 없다.
- 더 짧게 코드를 작성할 수 있어서 편하다.

```kotlin
val String.lastChar: Char
	get() = get(length - 1)
```

- 일반 프로퍼티와 같은데, 단지 수신 객체 클래스가 추가됐을 뿐이다.
- 뒷받침하는 필드가 없어서 기본 게터 구현을 제공할 수 없으므로 최소한 게터는 꼭 정의해야 한다.
- 초기화 코드에서 계산한 값을 담을 장소가 전혀 없으므로 초기화 코드도 쓸 수 없다.

변경 가능한 확장 프로퍼티 선언

```kotlin
var StringBuilder.lastChar: Char
	get() = get(length - 1)
	set(value: Char) {
		this.setCharAt(length - 1, value)
	}
	
>>> println("Kotlin".lastChar)
n
>>> val sb = StringBuilder("Kotlin?")
>>> sb.lastChar = "!"
>>> println(sb)
Kotlin!
```

## 3.4 컬렉션 처리: 가변 길이 인자, 중위 함수 호출, 라이브러리 지원

- vararg 키워드를 사용하면 호출 시 인자 개수가 달라질 수 있는 함수를 정의할 수 있다.
- 중위(infix) 함수 호출 구문을 사용하면 인자가 하나뿐인 메소드를 간편하게 호출할 수 있다.
- 구조 분해 선언(destructing declaration)을 사용하면 복합적인 값을 분해해서 여러 변수에 나눠 담을 수 있다.

### 3.4.1 자바 컬렉션 API 확장

자바 라이브러리 클래스의 인스턴스인 컬렉션에 대해 코틀린이 새로운 기능을 추가할 수 있는 이유

→ 확장함수이기 때문

### 3.4.2  가변 인자 함수: 인자의 개수가 달라질 수 있는 함수 정의

```kotlin
val list = listOf(2, 3, 5, 7, 11)

fun listOf<T> (vararg value: T): List<T> { ... }
```

**가변 길이 인자**

- 메소드를 호출할 때 원하는 개수만큼 값을 인자로 넘기면 자바 컴파일러가 배열에 그 값들을 넣어주는 기능
- 코틀린의 가변 길이 인자도 자바와 비슷하지만 타입 뒤에 …를 붙이는 대시 코틀린에서는 파라미터 앞에 vararg 변경자를 붙인다.
- 이미 배열에 들어있는 원소를 가변 길이 인자로 넘기는 경우
    - 자바 → 배열을 그냥 넘기면 된다.
    - 코틀린 → 배열을 명시적으로 풀어서 배열의 각 원소가 인자로 전달되게 해야한다,
        - 스프레드 연산자가 그런 작업을 해준다. → 배열 앞에 *를 붙이면 된다.
        
        ```kotlin
        fun main(args: Array<String>) {
        	val list = listOf("args: ", *args)
        	println(list)
        }
        ```
        

### 3.4.3 값의 쌍 다루기: 중위 호출과 구조 분해 선언

```kotlin
val map = mapOf(1 to "one", 7 to "seven", 53 to "fifty-three")
```

→ 여기서 to는 코틀린 키워드가 아니라 중위 호출(infix call) 방식으로 to라는 일반 메소드를 호출한 것

중위 호출 시에는 수신 객체와 유일한 메소드 인자 사이에 메소드 이름을 넣는다.

[1.to](http://1.to)(”one”) ← to 메소드를 일반적인 방식으로 호출

1 to “one” ← to 메소드를 중위 호출 방식으로 호출

⇒ 인자가 하나뿐인 일반 메소드나 인자가 하나뿐인 확장 함수에 중위 호출을 사용할 수 있다.

함수를 중위 호출에 사용하게 허용하고 싶으면 infix 변경자를 함수 선언 앞에 추가해야 한다.

```kotlin
infix fun Any.to(other: Any) = Pair(this, other)
```

→ Pair 인스턴스를 반환 

Pair 

- 코틀린 표준 라이브러리 클래스
- 두 원소로 이뤄진 순서쌍을 표현한다.
- 두 변수를 즉시 초기화할 수 있다.

```kotlin
val (number, name) = 1 to "one"
```

→ 구조 분해 선언

![IMG_BD4F6D237322-1.jpeg](https://github.com/user-attachments/assets/dfaf0795-cfc2-4e95-9516-ad0b4d8b796e)

Pair 인스턴스 외 다른 객체에도 구조 분해 적용할 수 있다.

```kotlin
for( (index, element) in collection.withIndex()) {
	println("$index: $element")
}
```

to 함수는 확장 함수로 to를 사용하면 타입과 관계없이 임의의 순서쌍을 만들 수 있다.

→ to의 수신 객체가 제네릭하다는 뜻

```kotlin
fun <K, V> mapOf(vararg values: Pair<K, V>): Map<K, V>
```

→ mapOf도 원하는 개수만큼 인자를 전달할 수 있다.

→ 각 인자가 키와 값으로 이루어진 순서쌍이어야 한다.

## 3.5 문자열과 정규식 다루기

### 3.5.1 문자열 나누기

```kotlin
"12.345-6.A".split(".")
```

→ 자바에서 위 결과는 빈배열을 반환한다.

→ split의 구분 문자열은 실제로는 정규식이기 때문, 따라서 .는 모든 문자를 나타내는 정규식으로 해석된다.

코틀린에서는 자바의 split 대신에 여러가지 다른 조합의 파라미터를 받는 split 확장함수를 제공함으로써 혼동을 야기하는 메소드를 감춘다.

```kotlin
"12.345-6.A".split("\\.|-".toRegex())) <- 정규식을 명시적으로 만든다.
"12.345-6.A".split(".", "-") <- 여러 구분 문자열을 지정한다.
```

### 3.5.2 정규식과 3중 따옴표로 묶은 문자열

파일의 전체 경로명을 디렉터리, 파일 이름 확장자로 구분

“/Users/yole/kotlin-book/chapter.adoc”

1. String을 확장한 함수

```kotlin
fun parsePath(path: String) {
	val directory = path.substringBeforeLast("/")
	val fullName = path.substringAfterLast("/")
	
	val fileName = fullName.substringBeforeLast(".")
	val extension fullName.substringAfterLast(".")
	
	println("Dir: $directory, name: $fileNae, ext: $extenstion")
}
```

1. 정규식을 사용

```kotlin
fun parsePath(path: String) {
	val regex = """(.+)/(.+)\.(.+)""".toRegex()
	val matchResult = regex.matchEntire(path)
	if(matchResult != null) {
		val (directory, filename, extension) = matchResult.destructured
		println("Dir: $directory, name: $fileNae, ext: $extenstion")
	}
}
```

- 3중 따옴표 문자열을 사용해 정규식을 사용함.
    - 3중 따옴표 문자열에서는 \를 포함한 어떤 문자도 이스케이프(특수 문자 처리)할 필요가 없다.
    - 일반 문자열을 사용해 정규식을 작성하는 경우 \\. , 3중 따옴표 문자열에서는 \.
    - (.+) /→ 마지막 슬래시까지 모든 문자와 매치된다. 마지막 슬래시를 제외한 모든 슬래시도 들어간다.
    - (.+)\. → 마지막 마침표 전까지 모든 문자가 들어간다.
    - 

### 3.5.3 여러 줄 3종 따옴표 문자열

 

- 3중 따옴표 문자열에는 줄 바꿈을 표현하는 아무 문자열이나 그대로 들어간다.

- 여러 줄 문자열에는 들여쓰기나 줄 바꿈을 포함한 모든 문자가 들어간다.
- 보기 좋게 표현하려면 들여쓰기를 하고 나중에 trimMargin을 사용해 공백을 제거한다.

- 여러 줄 문자열에는 줄 바꿈이 들어가지만 줄바꿈을 \n과 같은 특수 문자를 사용해 넣을 수 없다.
- 반면에 \를 문자열에 넣고 싶으면 이스케이프 할 필요가 없다.

- 3중 따옴표 문자열안에 문자열 템플릿 사용할 수도 있다.
    - 3중 따옴표 문자열 안에서는 이스케이프를 할 수 없기 때문에 문자열 템플릿의 시작을 표현하는 $를 3중 따옴표 문자열 안에 넣을 수 없다는 문제가 생긴다.
    - val price = “””${’$’}99.9”””

- 테스트에 요긴하게 쓰인다.
    - 테스트의 예상 출력을 작성할 때 가장 완벽한 해법이다.

## 3.6 코드 다듬기: 로컬 함수와 확장

메소드 추출 리팩토링을 적용해서 긴 메소드를 부분부분 나눠서 각 부분을 재활용할 수 있다.

→ 코드를 리팩토링하면 클래스 안에 작은 메소드가 많아지고 각 메소드 사이의 관계를 파악하기 힘들어서 코드를 이해하기 더 어려워질 수도 있다.

코틀린에서는 함수에서 추출한 함수를 원 함수 내부에 중첩시킬 수 있다.

→ 문법적인 부가 비용을 들이지 않고도 깔끔하게 코드를 조직할 수 있다.

ex)

```kotlin
class User(val id: Int, val name: String, val address: String)

fun saveUser(user: user) {
	if(user.name.isEmpty()) {
		throw IllegalArgumentException(
			"Can't save user ${user.id}: empty Name")
	}
	
	if(user.address.isEmpty()) {
		throw IllegalArgumentException(
			"Can't save user ${user.id}: empty Name")
	}
```

→ 검증 코드를 로컬 함수로 분리하면 중복을 없애는 동시에 코드 구조를 깔끔하게 유지할 수 있다.

```kotlin
class User(val id: Int, val name: String, val address: String)

fun saveUser(user: user) {
	
	fun validate(user: User, value: String, fieldName: String) {
		if(value.isEmpty()) {
			throw IllegalArgumentException(
			"Can't save user ${user.id}: empty $fieldName")
		}
	}
	
	validate(user, user.name, "Name")
	validate(user, user.address, "Address")
}
				
```

→ User 객체를 로컬 함수에서 하나하나 전달해야 한다는 점이 아쉬움

```kotlin
class User(val id: Int, val name: String, val address: String)

fun saveUser(user: user) {
	
	fun validate(value: String, fieldName: String) {
		if(value.isEmpty()) {
			throw IllegalArgumentException(
			"Can't save user ${user.id}: empty $fieldName")
		}
	}
	
	validate(user.name, "Name")
	validate(user.address, "Address")
}
				
```

```kotlin
class User(val id: Int, val name: String, val address: String)

fun User.validateBeforeSave() {
	
	fun validate(value: String, fieldName: String) {
		if(value.isEmpty()) {
			throw IllegalArgumentException(
			"Can't save user $id: empty $fieldName")
		}
	}
	
	validate(name, "Name")
	validate(address, "Address")
}

fun saveUser(user: User) {
	user.validateBeforeSave()
}
			
```

→ 확장 함수로 만들면 수신 객체를 지정하지 않고도 공개된 멤버 프로퍼티나 메소드에 접근할 수 있다.

## 3.7 요약

- 코틀린은 자체 컬렉션 클래스는 없지만 자바 클래스를 확장해서 사용한다.
- 함수 파라미터의 디폴트 값을 정의하면 오버로딩한 함수를 정의할 필요성이 줄어든다. 이름 붙인 인자를 사용하면 가독성을 향상시킬 수 있다.
- 코틀린 파일에서 클래스 멤버가 아닌 최상위 함수와 프로퍼티를 직접 선언할 수 있다. 이를 활용하면 코드 구조를 더 유연하게 만들 수 있다.
- 확장함수와 프로퍼티를 사용하면 외부 라이브러리에 정의된 클래스를 포함해 모든 클래스의 API를 그 클래스의 소스코드를 바꿀 필요 없이 확장할 수 있다. 확장함수를 사용해도 실행 시점에 부가 비용이 들지 않는다.
- 중위 호출을 통해 인자가 하나 밖에 없는 메소드나 확장 함수를 더 깔끔한 구문으로 호출할 수 있다.
- 코틀린은 정규식과 일반 문자열을 처리 할 때 유용한 다양한 문자열 처리 함수를 제공한다.
- 자바 문자열로 표현하려면 수많은 이스케이프가 필요한 문자열의 경우 3중 따옴표 문자열을 사용하면 더 깔끔하게 표현할 수 있다.
- 로컬 함수를 써서 코드를 더 깔끔하게 유지하면서 중복을 제거할 수 있다.
