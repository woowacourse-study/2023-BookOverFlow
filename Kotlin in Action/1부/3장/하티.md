# 3장. 함수 정의와 호출

## 다루는 내용

- 컬렉션, 문자열, 정규식을 다루기 위한 함수
- 이름 붙인 인자, 디폴트 파라미터 값, 중위 호출 문법 사용
- 확장 함수, 확장 프로퍼티 사용해 자바 라이브러리 적용
- 최상위 및 로컬 함수와 프로퍼티를 사용해 코드 구조화

## 코틀린에서 컬렉션 만들기

```kotlin
// HashSet
val set = hashSetOf(1, 7, 53)

// ArrayList
val list = arrayListOf(1, 7, 53)

// HashMap
val map = hashMapOf(1 to "one", 7 to "seven", 53 to "fifty-three")
```

- `to`는 언어가 제공하는 키워드가 아닌 일반 함수
- 코틀린은 자신만의 컬렉션 기능을 제공하지 않고 기존 자바 컬렉션 활용
- why? 표준 자바 컬렉션을 활용하면 자바 코드와 상호작용하기 훨씬 쉬움

```kotlin
val numbers = setOf(1, 14, 2)
println(numbers.max())
```

- 코틀린 컬렉션과 자바 컬렉션과 똑같은 클래스지만, 코틀린에서는 자바보다 더 많은 기능을 쓸 수 있음 (e.g. `max()`)

## 함수를 호출하기 쉽게 만들기

```kotlin
val list = listOf(1, 2, 3)
println(list) // toString() 호출

// 출력
[1, 2, 3]
```

- 디폴트 구현과 다른 결과를 원한다면?
    - 자바: Guava, Apache Commons 같은 서드파티 프로젝트를 추가하거나 직접 관련 로직 구현해야 함
    - 코틀린: 표준 라이브러리에 이미 함수가 있음

```kotlin
fun <T> joinToString(
        collection: Collection<T>,
        separator: String,
        prefix: String,
        postfix: String,
): String {
        val result = StringBuilder(prefix)
        
        for ((index, element) in collection.withIndex()) {
                if (index > 0) result.append(separator)
                result.append(element)
        }

        result.append(postfix)
        return result.toString()
}
```

- generic 함수
- 위의 코드를 덜 복잡하고 간단하게 만들고 싶다면?!?

### 이름 붙인 인자

```kotlin
joinToString(
        collection = collection, 
        separator = " ", 
        prefix = " ",
        postfix = ".",
)
```

- 코틀린으로 작성함 함수를 호출할 때, 함수에 전달하는 인자 중 일부/전부의 이름을 명시할 수 있음

### 디폴트 파라미터 값

- 자바에서는 일부 클래스에서 `overloading`한 메소드가 많아진다는 문제가 존재
- 코틀린에서는 함수 선언에서 파라미터의 디폴트 값을 지정 가능, 오버로드 중 상당수를 피할 수 있음

```kotlin
fun <T> joinToString(
        collection: Collection<T>,
        separator: String = ", ",
        prefix: String = "",
        postfix: String = "",
): String { ... }

joinToString(list, ", ", "", "")
joinToString(list)

// 함수 선언 시와 같은 순서로 인자 지정
joinToString(list, "; ") // prefix, postfix 생략

// 이름 붙은 인자를 사용하는 경우 파라미터 순서 관계없이 지정 가능
joinToString(list, postfix = ";", prefix = "# ") 
```

### 정적인 유틸리티 클래스 없애기: 최상위 함수와 프로퍼티

**최상위 함수**

- 자바에서는 다양한 정적 메소드를 모으기만 하고, 특별한 상태나 인스턴스 메소드가 없는 클래스가 존재
- 코틀린에서는 이런 무의미한 클래스가 필요 없음 → 소스 파일의 최상위 수준, 클래스의 밖에 위치시킬 수 있음: **최상위 함수**
- 이 함수가 어떻게 실행될 수 있는가?
    - JVM이 클래스 안에 들어있는 코드만을 실행할 수 있기 때문에, 컴파일러는 이 파일을 컴파일할 때 새로운 클래스를 정의해줌
        
        ```java
        /* Java */
        public class JoinKt {
                public static String joinToString(...) { ... }
        }
        
        import strings.JoinKt;
        ...
        JoinKt.joinToString(list)
        ```
        
    - 코틀린 최상위 함수가 포함되는 클래스의 이름을 바꾸고 싶다면 파일에 `@JvmName` annotation을 추가해야 함
        
        ```java
        @file:JvmName("StringFunctions")
        package strings
        fun joinToString(..): String { ... }
        ```
        

**최상위 프로퍼티**

- 프로퍼티 역시 파일의 최상위 수준에 놓을 수 있음
- 프로퍼티의 값은 정적 필드에 저장됨
- 최상위 프로퍼티를 활용해 코드에 상수를 추가할 수 있음
    
    ```kotlin
    const val UNIX_LINE_SEPARATOR = "\n"
    ```
    
    - `const` 변경자를 추가하면 프로퍼티를 `public static final` 필드로 컴파일 할 수 있음
    - 원시 타입과 String 타입만 const로 지정 가능

## 메소드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티

- 기존 자바 API를 재작성하지 않고도 코틀린이 제공하는 기능인 `확장 함수 (extension function`)을 통해 기존 코드와 코틀린 코드를 자연스럽게 통합할 수 있음
- **확장 함수**: 멤버 메소드인 것처럼 호출할 수 있으나, 그 클래스 밖에 선언된 함수
    
    ```kotlin
    fun String.lastChar(): Char = this.get(this.length - 1)
    
    println("Kotlin".lastChar())  // n
    ```
    
    - String: 수신 객체 타입 (receiver type)
    - this: 수신 객체 (receiver object)  // 생략 가능
    - 수신 객체 타입이 어떤 언어로 작성됐는가도 중요하지 않음 (자바 클래스로 컴파일한 클래스 파일이 있는 한 가능)
    - this 생략 가능
- 확장 함수가 캡슐화를 깨지는 않는다
    - 클래스 안에서 정의한 메소드와 달리, 확장 함수 안에서는 클래스 내부에서만 사용 가능한 private/protected 멤버를 사용할 수 없음

### 임포트와 확장 함수

- 확장 함수를 사용하기 위해서는 다른 클래스나 함수와 마찬가지로 import 해야만 함
- 코틀린에서는 개별 함수를 임포트할 수 있음
    
    ```kotlin
    import strings.lastChar
    // or import strings.*
    
    val c = "Kotlin".lastChar()
    ```
    

### 자바에서 확장 함수 호출

- 내부적으로 확장 함수는 수신 객체를 첫 번째 인자로 받는 정적 메소드
    
    ```kotlin
    char c = StringUtilKt.lastChar("Java");
    ```
    
- 확장 함수를 호출해도 다른 adapter 객체나 실행 시점 부가 비용이 들지 않음

### 확장 함수로 유틸리티 함수 정의

```kotlin
fun <T> Collection<T>.joinToString(
        separator: String = ", ",
        prefix: String = "",
        postfix: String = "",
): String { 
        val result = StringBuilder(prefix)
        for ((index, element) in this.withIndex()) {
                if (index > 0) result.append(separator)
                result.append(element)
        }
        result.append(postfix)
        return result.toString()
}

val list = arrayListOf(1, 2, 3)
println(list.joinToString(" "))   // 1 2 3
```

- 확장 함수는 정적 메소드 호출에 대한 문법적인 편의일 뿐
- 클래스가 아닌 더 구체적인 타입을 수신 객체 타입으로 지정할 수 있음
    
    ```kotlin
    fun Collection<String>.join(...) { ... }
    ```
    

### 확장 함수는 오버라이드 할 수 없다

- 코틀린의 메소드 오버라이드도 일반적인 객체지향의 메소드 오버라이드와 동일
- 다만 확장 함수는 오버라이드할 수 없음

- 멤버 함수 오버라이드
    
    ```kotlin
    open class View {
            open fun click() = println("View clicked")
    }
    
    class Button: View() {
            override fun click() = println("Button clicked")
    }
    
    val view: View = Button()
    view.click()  // Button clicked
    ```
    
    - Button이 오버라이드한 click이 호출됨

- 확장 함수 오버라이드
    - 확장 함수는 클래스의 일부가 아닌, 클래스 밖에 선언
    - 확장 함수를 호출할 때 **수신 객체로 지정한 변수의 정적 타입**에 의해 어떤 확장 함수가 호출될지 결정, 변수에 저장된 객체의 동적인 타입에 의해 결정되지 않음
    
    ```kotlin
    fun View.showOff() = println("I'm a view")
    fun Button.showOff() = println("I'm a button")
    
    val view: View = Button()
    view.showOff()   // I'm a view
    ```
    
    - view가 가리키는 객체의 실제 타입은 Button이지만, 타입은 View이므로 View의 확장 함수가 호출됨

- 어떤 클래스의 확장 함수와, 그 클래스의 멤버 함수의 이름과 시그니처가 같다면 확장 함수가 아니라 **멤버 함수가 호출됨**

### 확장 프로퍼티

- 확장 프로퍼티를 사용하여 기존 클래스 객체에 대한 프로퍼티 형식의 구문으로 사용할 수 있는 API 추가할 수 있음
- 프로퍼티라고 불리지만 상태를 저장할 적절한 방법이 없어 아무 상태도 가질 수 없음
- 다만 더 짧게 코드를 작성할 수 있어 편리한 경우가 있음

```kotlin
val String.lastChar: Char
        get() = get(length - 1)

// 변경 가능한 확장 프로퍼티
var StringBuilder.lastChar: Char
        get() = get(length - 1)
        set(value: Char) {
                this.setCharAt(length - 1, value)
        }
```

- 일반적인 프로퍼티와 같은데, 수신 객체 클래스가 추가됨
- 백킹 필드가 없어 기본 게터 구현을 제공할 수 없으므로 **최소한 게터를 꼭 정의해야 함**

- 사용 방법은 멤버 프로퍼티를 사용할 때와 같음
    
    ```kotlin
    println("Kotlin".lastChar)  // n
    
    val sb = StringBuilder("Kotlin")
    sb.lastChar = '!'
    println(sb)   // Kotlin!
    ```
    

- 자바에서 확장 프로퍼티를 사용하고 싶다면 항상 게터/세터를 명시적으로 호출해야 함
    
    ```kotlin
    StringUtilKt.getLastChar("Java")
    ```
    

## 컬렉션 처리: 가변 길이 인자, 중위 함수 호출, 라이브러리 지원

### 자바 컬렉션 API 확장

```kotlin
val strings: List<String> = listOf("first", "second", "fourteenth")
strings.last() // fourteenth

val numbers: Collection<Int> = setOf(1, 14, 2)
numbers.max() // 14
```

- 위의 코드에서 `last()`, `max()`는 확장 함수 !
    
    ```kotlin
    fun <T> List<T>.last(): T { ... }
    fun Collection<Int>.max(): Int { ... }
    ```
    
- 코틀린 표준 라이브러리는 수많은 확장 함수를 포함하고 있음

### 가변 인자 함수: 인자의 개수가 달라질 수 있는 함수 정의

```kotlin
val list = listOf(2, 3, 5, 7, 11)
```

- 리스트를 생성하는 함수 → 원하는 만큼 원소를 전달할 수 있음

```kotlin
// 함수의 정의
fun listOf<T>(vararg values: T): List<T> { ... }
```

- 자바의 가변 길이 인자 (`varargs`)와 비슷함
- 다만, 코틀린에서는 **파라미터 앞에 `vararg` 변경자를 붙임**

```kotlin
fun main(args: Array<String>) {
        val list = listOf("args: ", *args)
        println(list)
}
```

- 이미 배열에 있는 원소를 가변 길이 인자로 넘길 때,
- 자바에서는 배열을 그냥 넘기면 되지만
- 코틀린에서는 배열을 명시적으로 풀어서 배열의 각 원소가 인자로 전달되도록 해야 함
    - spread 연산자가 이런 작업을 해줌
    - **실제로는 전달하려는 배열 앞에 `*`을 붙이기만 하면 됨**

### 값의 쌍 다루기: 중위 호출과 구조 분해 선언

- `중위 호출(infix call)`이라는 특별한 방식으로 `to`라는 일반 메소드를 호출
    
    ```kotlin
    val map = mapOf(1 to "one", 7 to "seven")
    ```
    

- 중위 호출 시에는 수신 객체와 유일한 메소드 인자 사이에 메소드 이름을 넣음
    
    ```kotlin
    1.to("one")   // 일반적인 방식으로 to 메소드 호출
    1 to "one"    // 중위 호출 방식으로 to 메소드 호출
    ```
    

- 인자가 하나뿐인 일반 메소드 / 인자가 하나뿐인 확장 함수에 중위 호출 사용 가능
- 함수를 중위 호출에 사용하게 허용하고 싶으면 `infix` 변경자를 함수 선언 앞에 추가
    
    ```kotlin
    infix fun Any.to(other: Any) = Pair(this, other)
    ```
    

- 구조 분해 선언 (destructuring declaration)
    
    ```kotlin
    // Pair의 내용으로 두 변수를 즉시 초기화 가능
    val (number, name) = 1 to "one"
    
    // loop에서 구조 분해 선언 활용 가능
    for ((index, element) in collection.withIndex()) { ... }
    ```
    

- `to`는 확장 함수며, 타입과 관계없이 임의의 순서쌍을 만들 수 있음
    - 즉, to의 수신 객체가 제네릭함
- `mapOf` 함수 역시 원하는 개수만큼 인자 전달 가능
    
    ```kotlin
    fun <K, V> mapOf(vararg values: Pair<K, V>: Map<K, V>
    ```
    

## 문자열과 정규식 다루기

- 코틀린의 문자열은 자바 문자열과 같음
    - 자바—코틀린 간 특별한 변환 혹은 별도의 wrapper 필요 없음
- 코틀린은 다양한 확장 함수를 제공함

### 문자열 나누기

- 자바의 `split` 메소드
    - 자바 정규식의 `.`은 모든 문자를 나타내는 정규식으로 해석
    - `[12.345-6.A"split(".")` 의 결과는 *[12, 345-6, A]*가 아닌 빈 문자열이 나옴
- 코틀린에서는 여러 가지 다른 조합의 파라미터를 받는 `split` 확장 함수를 제공
    - 정규식을 파라미터로 받는 경우: String이 아닌 Regex 타입을 받음
        
        ```kotlin
        println("12.345-6.A".split("\\.|-".toRegex()))
        // [12, 345, 6, A]
        ```
        
        - 정규식 문법은 자바와 똑같음
        - `toRegex` 확장 함수를 사용해 문자열 → 정규식 변환 가능
        
    - 간단한 경우, 구분 문자열을 하나 이상 인자로 받음
        
        ```kotlin
        println("12.345-6.A".split(".", "-"))
        // [12, 345, 6, A]
        ```
        

### 정규식과 3중 따옴표로 묶은 문자열

- “파일의 전체 경로명을 디렉터리, 파일 이름, 확장자로 구분하기” 구현하기
    
    ```kotlin
    "/Users/sujin9/kotlin-book/chapter.adoc"
    ----------디렉터리----------/파일이름.확장자
    ```
    

- String 확장 함수 사용
    
    ```kotlin
    fun parsePath(path: String) {
            val directory = path.substringBeforeLast("/")
            val fullName = path.subStringAfterLast("/")
    
            val fileName = fullName.substringBeforeLast(".")
            val extension = fullName.substringAfterLast(".")
    
            println("Dir: $directory, name: $fileName, ext: $extension")
    }
    
    // Dir: /Users/sujin9/kotlin-book, name: chapter, ext: adoc
    ```
    

- 3중 따옴표 문자열 & 정규식 사용
    
    ```kotlin
    fun parsePath(path: String) {
            val regex = """(.+)/(.+)\.(.+)""".toRegex()
            val matchResult = regex.matchEntire(path)
            if (matchResult != null) {
                    val (directory, filename, extension) = matchResult.destructured
                    println("Dir: $directory, name: $fileName, ext: $extension")
            }
    }
    
    // Dir: /Users/sujin9/kotlin-book, name: chapter, ext: adoc
    ```
    
    - 3중 따옴표 문자열에서는 `\`를 포함한 어떤 문자도 이스케이프할 필요 없음
        - 평소에 `\\.` 라고 쓰는 걸 `\.`로 쓸 수 있음
    - """(.+)/(.+)\.(.+)"""
        - `(.+)`: directory
        - `/` : 마지막 슬래시
        - `(.+)`: file name
        - `\.` : 마지막 점
        - `(.+)`: extension

### 여러 줄 3중 따옴표 문자열

- 문자열 이스케이프를 피할 수 있음
- 줄 바꿈을 표현하는 아무 문자열 없이 그대로 들어갈 수 있음

```kotlin
val kotlinLogo= """|  //
                                    .| //
                                    .|/ \"""

println(kotlinLogo.trimMargin("."))
|  //
| //
|/ \

```

- 여러 줄 문자열을 코드에서 더 보기 좋게 표현하고 싶다면,
    - 들여쓰기를 하되 들여쓰기의 끝부분을 특별한 문자열로 표시하고
    - `trimMargin`을 사용해 그 문자열과 그 직전의 공백을 제거
    - 위의 예제에서는 `.`를 들여쓰기 구분 문자열로 사용
    
- `\n`과 같은 특수 문자로 줄바꿈 안됨
- `\`를 문자열에 넣고 싶을 때 이스케이프할 필요 없음
- 3중 따옴표 문자열 안에 문자열 템플릿 사용 가능
- 3중 따옴표 안에서는 이스케이프를 할 수 없으므로 `$`를 넣을 수 없음
    - 문자열 템플릿 안에 `$`를 넣어야 함
        
        ```kotlin
        val price = """${'$'}99.9"""
        ```
        

## 코드 다듬기: 로컬 함수와 확장

- DRY: Don’t Repeat Yourself - 중복 코드 반복하지 마라!
- 이를 위해서, 많은 경우 메소드 추출 리팩토링을 적용하여 부분부분을 나눠서 각 부분을 재활용
    - 다만, 클래스 안에 작은 메소드가 많아지고, 각 메소드 간의 관계 파악이 어려워 코드 이해가 어려워질 수 있음
    - 추출한 메소드를 별도의 inner class 안에 넣으면 코드를 깔끔하게 조직할 수 있지만, 불필요한 준비 코드가 늘어남

- 코틀린에서는 함수에서 추출한 함수를 원 함수에 중첩시킬 수 있음
- 코드 중복을 local 함수를 통해 어떻게 제거할 수 있는가?
    
    ```kotlin
    class User(val id: Int, val name: String, val address: String)
    
    fun saveUser(user: User) {
            if (user.name.isEmpty()) {
                    throw IllegalArgumentException (
                            "Can't save user ${user.id}: empty Name"
                    )
            }
            if (user.address.isEmpty()) { 
                    throw IllegalArgumentException (
                            "Can't save user ${user.id}: empty Address"
                    )
            }
    
            // save user on db
    }
    ```
    
    - 위의 코드에서 중복되는 검증 코드를 로컬 함수로 분리
    - 로컬 함수는 자신이 속한 바깥 함수의 모든 파라미터와 변수 사용 가능
    
    ```kotlin
    class User(val id: Int, val name: String, val address: String)
    
    fun saveUser(user: User) {
            fun validate(value: String, fieldName: String) {
                    if (value.isEmpty()) {
                            throw IllegalArgumentException (
                                    "Can't save user ${user.id}: empty $fieldName"
                            )
                    }
            }
    
            validate(user.name, "Name")
            validate(user.address, "Address")
    
            // save user on db
    }
    ```
    
    - 검증 로직을 User 클래스 확장 함수로 만들기
    
    ```kotlin
    class User(val id: Int, val name: String, val address: String)
    
    fun User.validateBeforeSave() {
            fun validate(value: String, fieldName: String) {
                    if (value.isEmpty()) {
                            throw IllegalArgumentException (
                                    "Can't save user $id: empty $fieldName"
                            )
                    }
            }
    
            validate(name, "Name")
            validate(address, "Address")
    }
    
    fun saveUser(user: User) {
            user.validateBeforeSave()
    
            // save user on db
    }
    ```
    

## 요약

- 자체 컬렉션 클래스를 정의하진 않지만 자바 클래스를 확장하여 풍부한 API 제공
- 함수 `파라미터의 디폴트 값`을 정의하여 오버로딩 함수 정의 줄어듦
- `이름 붙인 인자`를 사용하면 인자가 많을 때 함수 호출 가독성 향상됨
- 코틀린 파일에서 클래스 멤버가 아닌 `최상위 함수/프로퍼티` 직접 선언 가능
- `확장 함수/프로퍼티` 사용하면 외부 라이브러리에 정의된 클래스를 포함해 모든 클래스의 API를 그 클래스의 소스코드 수정 없이 확장 가능, 실행 시점에 부가 비용도 들지 않음
- `중위 호출`을 통해 인자가 하나 뿐인 메소드/확장 함수 더 깔끔한 구문으로 표현
- 정규식 및 일반 문자열 처리할 때 유용한 다양한 `문자열 처리 함수` 제공
- 수많은 이스케이프가 필요한 문자열을 `"""`을 사용하여 더 깔끔하게 표현
- `로컬 함수`를 통해 코드를 깔끔하게 유지하며 중복 제거 가능
