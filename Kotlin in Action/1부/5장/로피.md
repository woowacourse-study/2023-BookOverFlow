# 5장 람다로 프로그래밍

## 5.1 람다 식과 멤버 참조

### 5.1.1 람다 소개: 코드 블록을 함수 인자로 넘기기

‘이벤트가 발생하면 이 핸들러를 실행하자' or ‘데이터 구조의 모든 원소에 이 연산을 적용하자’

자바

→ 무명 내부 클래스를 통해 구현

→ 무명 내부 클래스를 사용하면 코드를 함수에 넘기거나 변수에 저장할 수 있기는 하지만 상당히 번거로움

```java
buttn.setOnClickListener(new OnClickListener() {
	@Override
	public void onClick(View view) {
		/* 클릭 시 수행할 동작*/
	}
});
```

함수형 프로그래밍

→ 함수를 값처럼 다루는 접근 방법을 통해 해결

→ 클래스를 선언하고 그 클래스의 인스턴스를 함수에 넘기는 대신 함수형 언어에서는 함수를 직접 다른 함수에 전달 할 수 있다.

람다식

→ 코드가 더욱 간결해짐

→ 함수를 선언할 필요가 없고 코드 블록을 직접 함수의 인자로 전달할 수 있음.

```java
button.setOnClickListener { /* 클릭 시 수행할 동작  */ }
```

### 5.1.2 람다와 컬렉션

자바에서는 쓰기 편한 컬렉션 라이브러리가 적었으며, 그에 따라 자바 개발자들은 필요한 컬렉션 기능을 직접 작성하곤 했음.

예) 컬렉션 직접 검색

```kotlin
data class Person(val name: String, val age: Int)

fun findTheOldest(people: List<Person>) {
	var maxAge = 0
	var theOldest: Person? = null
	for(person in people) {
		if(person.age > maxAge) {
			maxAge = person.age
			theOldest = person 
		}
	}
	
	println(theOldest)
}
```

코틀린에서는 라이브러리 함수를 통해 쉽게 구현 가능하다

예) 람다를 사용해 컬렉션 검색하기

```kotlin
println(maxBy{ it.age })
```

maxBy

- 가장 큰 원소를 찾기 위해 비교에 사용할 값을 돌려주는 함수를 인자로 받는다.
- 중괄호로 둘러싸인 코드는 바로 비교에 사용할 값을 돌려주는 함수이다.
- 위의 코드는 컬렉션의 원소를 인자로 받아서 비교에 사용할 값을 반환한다.

함수나 프로퍼티를 반한화는 역할을 수행하는 람다는 멤버 참조로 대치할 수 있음

```kotlin
people.maxBy(Person::age)
```

### 5.1.3 람다 식의 문법

![IMG_AA0699604F1B-1.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/5723aa6a-901d-4e34-959c-8e5bf6dee90e/IMG_AA0699604F1B-1.jpeg)

- 코틀린 람다식은 항상 중괄호로 둘러싸여 있다.
- 인자 목록 주변에 괄호가 없다.
- 화살표가 인자 목록과 람다 본문을 구분해준다.
- 람다식을 변수에 저장할 수 있다.
- 람다가 저장된 변수를 다른 일반 함수와 마찬가지로 다룰 수 있다.
    
    ```kotlin
    val sum = { x: Int, y: Int -> x + y }
    sum(1, 2)
    ```
    
- 람다식을 직접 호출해도 되지만 읽기 어렵고 그다지 쓸모도 없다.
- 코드의 일부분을 블록으로 둘러싸 실행할 필요가 있다면 `run`을 사용한다.
    - run은 인자로 받은 람다를 실행해주는 라이브러리 함수
    
    ```kotlin
    run { println(42) }
    ```
    
- 실행 시점에 코틀린 람다 호출에는 아무 부가 비용이 들지 않으며, 프로그램의 기본 구성 요소와 비슷한 성능을 낸다
- 람다 읽기 쉽게 만들기
    - 컴파일러가 문맥으로부터 유추할 수 있는 인자 타입을 굳이 적을 필요가 없다.
        - 컴파일러가 타입을 모르겠다고 불평하는 경우에만 타입 명시
    - 인자가 단 하나뿐인 경우 굳이 인자에 이름을 붙이지 않아도 된다.
    - 맨 뒤에 있는 인자가 람다 식이라면 그 람다를 괄호 밖으로 빼낼 수 있다.
    - 람다가 어떤 함수의 유일한 인자이고 괄호 뒤에 람다를 썼다면 호출 시빈 괄호를 없애도 된다.
    - 람다의 파라미터 이름을 디폴트 이름인 it로 바꾸면 람다 식을 더 간단하게 만들 수 있다.
        - 람다 안에 람다가 중첩되는 경우 각 람다의 파라미터를 명시하는 편이 더 낫다.
- 람다를 변수에 저장할 때 파라미터의 타입을 추론한 문맥이 존재하지 않기 때문에 파라미터 타입을 명시해야 한다.
    
    ```kotlin
    val getAge = { p: Person -> p.age }
    people.maxBy(getAge) 
    ```
    
- 본문이 여러 줄로 이뤄진 경우 본문의 맨 마지막에 있는 식이 람다의 결과 값이 된다.

### 5.1.4 현재 영역에 있는 변수에 접근

람다를 함수 안에서 정의하면 함수의 파라미터뿐 아니라 람다 정의의 앞에 선언된 로컬 변수까지 람다에서 모두 사용할 수 있다.

예) forEach - 컬렉션의 모든 원소에 대해 람다를 호출

```kotlin
fun printMessageWithPrefix(messages: Collection<String>, prefix: String) {
	message.forEach {
		println("$prefix $it")
	}
}
```

코틀린 람다 안에서는 파이널 변수가 아닌 변수에 접근할 수 있다.

람다 안에서 바깥의 변수를 변경해도 된다.

```kotlin
fun printProblemCounts(reponses: Collection<String>) {
	var clientErrors = 0
	var serverErrors = 0
	responses.forEach {
		if (it.startsWith("4")) {
			clientErrors++
		} else if (it.startsWith("5")) {
			serverErrors++
		}
	}
}
```

→ 람다 안에서 사용하는 외부 변수를 **람다가 포획한 변수**

어떤 함수가 자신의 로컬 변수를 포획한 람다를 반환하거나 다른 변수에 저장한다면 로컬 변수의 생명주기와 함수의 생명주기와 달라질 수 있다. 포획한 변수가 있는 람다를 저장해서 함수가 끝난 뒤에 실행해도 람다의 본문 코드는 여전히 포획한 변수를 읽거나 쓸 수 있다.

→ 파이널 변수를 포획한 경우에는 람다 코드를 변수 값과 함께 저장한다.

→ 파이널이 아닌 변수를 포획한 경우에는 변수를 특별한 래퍼로 감싸서 나중에 변경하거나 읽을 수 있게 한 다음, 래퍼에 대한 참조를 람다 코드와 함께 저장한다.

람다를 이벤트 핸들러나 다른 비동기적으로 실행되는 코드로 활용하는 경우 함수 호출이 끝난 다음에 로컬 변수가 변경될 수도 있다.

```kotlin
fun tryToCountButtonClicks(button: Button): Int {
	var clicks = 0
	button.onClick { clicks++ }
	return clicks
}
```

→ 항상 0을 반환

→ 핸들러는 tryToCountButtonsClicks가 clicks를 반환한 다음에 호출되기 때문

→ 카운터 변수를 함수의 내부가 아니라 클래스의 프로퍼티나 전역 프로퍼티의 위치로 빼내서 변화시켜야 함.

### 5.1.5 멤버 참조

함수를 값으로 바꾸기 위해 이중 콜론(::)을 사용

```kotlin
val getAge = Person::age
```

→ ::를 사용하는 식을 **멤버 참조**라고 부른다.

멤버 참조

- 프로퍼티나 메소드를 단 하나만 호출하는 함수 값을 만들어준다.
    
    ![IMG_0878E37D5E8F-1.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/358ca3dc-843f-4ca4-922f-247c12589e64/IMG_0878E37D5E8F-1.jpeg)
    
- 참조 대상이 함수인지 프로퍼티인지와는 관계없이 멤버 참조 뒤에는 괄호를 넣으면 안된다.
- 멤버 참조는 그 멤버를 호출하는 람다와 같은 타입이다.
    
    ```kotlin
    people.maxBy(Person::age)
    people.maxBy { p -> p.age }
    people.maxBy { it.age }
    ```
    
- 최상위에 선언된 함수나 프로퍼티를 참조할 수도 있다.
    
    ```kotlin
    fun salute() = println("Salute!")
    run(::salute)
    ```
    
- 람다가 인자가 여럿인 다른 함수한테 작업을 위임하는 경우 람다를 정의하지 않고 직접 위임 함수에 대한 참조를 제공하면 편리하다.
    
    ```kotlin
    val action = { person: Person, message: String ->
    	sendEmail(person, message)
    }
    
    val nextAction = ::sendEmail
    ```
    
- 생성자 참조를 사용하면 클래스 생성 작업을 연기하거나 저장해둘 수 있다.
    
    ```kotlin
    data class Person(val name: String, val age: Int)
    
    val createPerson = ::Person
    val p = createPerson("Alice", 29)
    ```
    
- 확장 함수도 멤버함수와 똑같은 방식으로 참조할 수 있다.
    
    ```kotlin
    fun Person.isAdult() = age >= 21
    val predicate = Person::isAdult
    ```
    

> 바운드 멤버 참조

코틀린 1.0
- 클래스의 메소드나 프로퍼티에 대한 참조를 얻은 다음에 그 참조를 호출할 때 항상 인스턴스 객체를 제공해야 했다.

코틀린 1.1
- 바운드 멤버 참조를 사용하면 멤버 참조를 생성할 때 클래스 인스턴스를 함께 저장한 다음 나중에 그 인스턴스에 대해 멤버를 호출해준다. 따라서 호출 시 수신 대상 객체를 별도로 지정해 줄 필요가 없다.
> 

## 5.2 컬렉션 함수형 API

### 5.2.1 필수적인 함수: filter와 map

filter

- 컬렉션을 이터레이션하면서 주어진 람다에 각 원소를 넘겨서 람다가 true를 반환하는 원소만 모은다.
- 결과는 입력 컬렉션의 원소 중에서 주어진 술어(참/거짓을 반환하는 함수)를 만족하는 원소만으로 이뤄진 새로운 컬렉션이다.
- 컬렉션에서 원치 않는 원소를 제거한다.
- 원소를 변환할 수는 없다.

map

- 주어진 람다를 컬렉션의 각 원소에 적용한 결과를 모아서 새 컬렉션을 만든다.
- 결과는 원본 리스트와 원소의 개수는 같지만, 각 원소는 주어진 함수에 따라 변환된 새로운 컬렉션이다.

ex) list에서 가장 나이 많은 사람의 이름을 알고 싶으면,

```kotlin
people.filter { it.age == people.maxBy(Person::age)!!.age)
```

→ list에서 최대값을 구하는 작업을 계속 반복하다는 단점이 있다.

```kotlin
val maxAge = people.maxBy(Person::age)!!.age
people.filter { it.age == maxAge }
```

맵의 경우 키와 값을 처리하는 함수가 따로 존재한다.

filterKey와 mapsKey는 키를 걸러 내거나 filterValues와 mapValues는 값을 걸러내거나 반환한다.

### 5.2.2 all, any, count, find: 컬렉션에 술어 적용

all

- 컬렉션의 모든 연소가 조건을 만족하는지 판단하는 연산

any

- 컬렉션에서 조건을 만족하는 원소가 하나라도 있는지 판단하는 연산

count

- 조건을 만족하는 원소의 개수를 반환

find

- 조건을 만족하는 첫 번째 원소를 반환
- 만족하는 원소가 하나라도 있는 경우 가장 먼저 조건을 만족한다고 확인되는 원소를 반환
- 만족하는 원소가 전혀 없는 경우 null을 반환한다.
- firstOrNull과 같다.

> 함수를 적재적소에 사용하라: count와 size

count 대신 컬렉션을 필터링한 결과의 크기를 가져오는 경우가 있다.
`people.filter(canBeInClub27).size`
→ 이렇게 처리하면 조건을 만족하는 모든 원소가 들어가는 중간 컬렉션이 생긴다.

count는 조건을 만족하는 원소의 개수만을 추적하지 않는 조건을 만족하는 원소를 따로 저장하지 않는다.
따라서 count가 훨씬 더 효율적
> 

### 5.2.3 groupBy: 리스트를 여러 그룹으로 이뤄진 맵으로 변경

groupBy

- 특성을 파라미터로 전달하면 컬렉션을 자동으로 구분해주는 함수
- 결과는 컬렉션의 원소를 구분하는 특성이 키이고 키 값에 따른 각 그룹이 값인 맵이다.

```kotlin
val people = listOf(Person("Alice", 31),
				Person("Bob", 29), Person("Carol", 31))
println(people.groupBy { it.age })
```

### 5.2.4 flatMap과 flatten: 중첩된 컬렉션 안의 원소 처리

flatMap

- 먼저 인자로 주어진 람다를 컬렉션의 모든 객체에 적용하고 람다를 적용한 결과 얻어지는 여러 리스트를 한 리스트로 한데 모은다.

```kotlin
val strings = listOf("abc", "def")
println(strings.flatMap { it.toList() })
```

→ 리스트의 리스트가 있는데? 모든 중첩된 리스트의 원소를 한 리스트로 모아야한다면  사용

하지만 특별히 변환 해야할 내용이 없다면 flatten 함수 사용

## 5.3 지연 계산(lazy) 컬렉션 연산

컬렉션 함수는 결과 컬렉션을 즉시 생성한다.

컬렉션 함수를 연쇄하면 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담는다.

→ 시퀀스를 사용하면 중간 임시 컬렉션을 사용하지 않고도 컬렉션 연산을 연쇄할 수 있따.

```kotlin
people.asSequence()
	.map(Person::name)
	.filter { it.startsWith("A") }
	.toList()
```

→ 중간 결과를 저장하는 컬렉션이 생기지 않기 때문에 원소가 많은 경우 성능이 눈에 띄게 좋아진다.

Sequence 인터페이스

- 코틀린 지연 계산 시퀀스가 시작된다.
- 한 번에 하나씩 열거될 수 있는 원소의 시퀀스를 표현할 뿐이다.
- 안에는 iterator라는 단 하나의 메소드가 있다.
- 메소드를 통해 시퀀스로부터 원소 값을 얻을 수 있다.
- 필요할 때 비로소 계산된다. 따라서 중간 처리 결과를 저장하지 않고도 연산을 연쇄적으로 적용해서 효율적으로 계산을 수행할 수 있다.
- asSequence 확장 함수를 호출하면 어떤 컬렉션이든 시퀀스로 바꿀 수 있다.
- 시퀀스를 리스트로 만들 때는 toList를 사용한다.

시퀀스를 다시 컬렉션으로 되돌려야 하는 이유

→ 시퀀스의 원소를 차례로 이터레이션해야 한다면 시퀀스를 직접 써도 된다. 하지만 시퀀스 원소를 인덱스를 사용해 접근하는 등의 다른 API 메소드가 필요하다면 시퀀스를 리스트로 변환해야 한다.

> 큰 컬렉션에 대해서 연산을 연쇄시킬 때는 시퀀스를 사용하는 것을 규칙으로 삼아라

컬렉션에 들어있는 원소가 많으면 중간 원소를 재배열하는 비용이 커지기 때문에 지연 계산이 더 낫다.
> 

### 5.3.1 시퀀스 연산 실행: 중간 연산과 최종 연산

![IMG_EB9EDB9EF2B8-1.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/aa6577fc-e245-4e9b-b081-7251ab1d7e97/IMG_EB9EDB9EF2B8-1.jpeg)

중간 연산

- 다른 시퀀스를 반환한다.
- 최초 시퀀스의 원소를 변환하는 방법을 안다.
- 항상 지연 계산된다.
- 결과를 얻을 필요가 있을 때(최종 연산이 호출될 때) 적용된다.

최종 연산

- 결과를 반환한다.
- 결과는 최초 컬렉션에 대해 변환을 적용한 시퀀스로부터 일련의 계산을 수행해 얻을 수 있는 컬렉션이나 원소, 숫자 또는 객체다.
- 최종 연산을 호출하면 연기됐던 모든 계산이 수행된다.

시퀀스의 모든 연산은 각 원소에 대해 순차적으로 적용된다.

→ 첫 번째 원소가 처리되고, 다시 두 번째 원소가 처리되며, 이런 처리가 모든 원소에 대해 적용된다.

→ 원소에 연산을 차례대로 적용하다가 결과가 얻어지면 그 이후의 원소에 대해서는 변환이 이뤄지지 않을 수도 있다.

![IMG_B198F4631DB1-1.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/9702fb26-d939-4a95-8c72-32736988119a/IMG_B198F4631DB1-1.jpeg)

컬렉션에 대해 수행하는 연산의 순서도 성능에 영향을 끼친다.

ex) 사람의 컬렉션이 있는데 이름이 어떤 길이보다 짧은 사람의 명단을 얻고 싶다고 하자.

→ map, filter 어떤 순서로 수행해도 되지만 수행해야하는 변환의 전체횟수는 다르다.

```kotlin
val people = listOf(Person("Alice", 29), Person("Bob", 31),
										Person("Charles", 31), Person("Dan", 21)
										
println(people.asSequence().map(Person::name).filter { it.length < 4 }.toList()

println(people.asSequence().filter { it.name.length < 4 }.map(Person::name).toList()
```

![IMG_E2D8858390F3-1.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/950443fd-249a-4795-a571-e5332c94f3e9/IMG_E2D8858390F3-1.jpeg)

> 자바 스트림과 코틀린 시퀀스 비교

자바 8을 채택하면 CPU에서 병렬적으로 실행할 수 있다. 자바 버전에 따라 시퀀스와 스트림 중에 적절한 쪽을 선택하라.
> 

### 5.3.2 시퀀스 만들기

시퀀스를 만드는 방법

- asSequence()
- generateSequence
    - 이전의 원소를 인자로 받아 다음 원소를 계산한다.
    
    ```kotlin
    val naturalNumbers = generateSequence(0) { it + 1 }
    val numbersTo100 = naturalNumbers.takeWhile { it <= 100 }
    println(numbersTo100.sum())
    ```
    
    → 최종 연산을 수행하기 전까지는 시퀀스의 각 숫자는 계산되지 않는다.
    

시퀀스를 사용하는 용례

- 객체의 조상으로 이뤄진 시퀀스를 만들어내는 것이다.
    - 어떤 객체의 조상이 자신과 같은 타입이고 모든 조상의 시퀀스에서 어떤 특성을 알고 싶을 때가 있다?
    - Kotlin에서 `generateSequence` 함수 등을 사용하여 객체의 상속 계층을 역추적하며 특정 조건을 만족하는 조상을 찾거나, 모든 조상에 대해 어떤 특성을 계산할 때 유용하게 사용됩니다. 예를 들어, 계층 구조에서 어떤 객체의 상위 부모 객체들을 반복적으로 찾아가면서 필요한 연산을 수행하는 경우를 말합니다.

```kotlin
fun File.isInsideHiddenDirectory() =
	generateSequence(this) { it.parentFile }.any { it.isHidden }

val file = File("...")
println(file.isInsideHiddenDirectoty())
```

→ 첫 번째 원소를 지정하고, 시퀀스의 한 원소로부터 다음 원소를 계산하는 방법을 제공함으로써 시퀀스를 만든다.
