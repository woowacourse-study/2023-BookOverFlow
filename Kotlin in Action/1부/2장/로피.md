# 2장 코틀린 기초

## 2.1 기본 요소: 함수와 변수

### 2.1.1 Hello, World!

```kotlin
fun main(args: Array<String>) {
	println("Hello, world!")
}
```

- 함수를 선언할 때 fun 키워드를 사용한다.
- 파라미터 이름 뒤에 그 파라미터의 타입을 쓴다.
- 함수를 최상위 수준에 정의할 수 있다.
- 배열도 일반적인 클래스와 마찬가지다.
- println을 사용
    - 코틀린 표준 라이브러리는 여러 가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 래퍼를 제공
- 줄 끝에 세미콜론을 붙이지 않아도 된다.

### 2.1.2 함수

- 함수 선언은 fun 키워드로 시작한다.
- fun 다음에는 함수 이름이 온다.
- 함수 이름 뒤에는 괄호 안에 파라미터 목록이 온다.
- 함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 오는데, 괄호와 반환 타입 사이를 콜론(:)으로 구분해야 한다.

```kotlin
fun max(a: Int, b: Int): Int {
	return if (a > b) a else b
}
```

- if는 문장이 아니고 결과를 만드는 식
- if식은 3항 연산자로 작성한 (a > b) ? a : b 식과 비슷

> **문(statement)과 식(expression) 구분**

식 - 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있다.
문 - 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다.

코틀린에서는 루프를 제외한 대부분의 제어 구조가 식이다.
대입문은 자바에서 식이엇으나 코틀린에서는 문이 됐다.
> 

**식이 본문인 함수**

본문이 중괄호로 둘러싸인 함수 - 블록이 본문인 함수

등호와 식으로 이루어진 함수 - 식이 본문인 함수

코틀린에서는 식이 본문인 함수가 자주 쓰인다. 함수의 본문 식에는 단순한 산술식이나 함수 호출 식뿐 아니라 if, when, try 등의 더 복잡한 식도 자주 쓰인다.

```kotlin
fun max(a: Int, b: Int) = if ( a > b ) a else b
```

→ 식이 본문인 함수의 경우 굳이 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해서 식의 결과 타입을 함수 반환 타입으로 정해준다.

**타입 추론(type inference)**

- 컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소의 타입을 정해주는 기능

식이 본문인 함수의 반환 타입만 생략 가능, 블록이 본문인 함수가 값을 반환한다면 반드시 반환 타입을 지정하고 return문을 사용해 반환 값을 명시해야 한다.

### 2.1.3 변수

- 코틀린에서는 키워드로 변수 선언을 시작하는 대신 변수 이름 뒤에 명시하거나 생략하게 허용한다.
- 타입을 지정하지 않으면 컴파일러가 초기화 식을 분석해서 초기화 식의 타입을 변수 타입으로 지정한다.
- 부동소수점(floating point) 상수를 사용한다면 변수 타입은 Double이 된다.
- 초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야 한다.
- 초기화 식이 없다면 변수에 저장될 값에 대해 아무 정보가 없기 때문에 컴파일러가 타입을 추론할 수 없다. 그런 경우 타입을 반드시 지정해야 한다.

**변경 가능한 함수와 변경 불가능한 함수**

- val - 변경 불가능한(immutable) 참조를 저장하는 변수, 일단 초기화하고 나면 재대입이 불가능하다.
- var - 변경가능한(mutable) 참조다. 이런 변수의 값은 바뀔 수 있다.

기본적으로는 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때에만 var로 변경해라. 변경 불가능한 참조외 변경 불가능한 객체를 부수 효과가 없는 함수와 조합에 사용하면 코드가 함수형 코드에 가까워진다.

val 변수는 블록을 실행할 때 정확히 한 번만 초기화돼야 한다.

어떤 블록이 실행될 때 오직 한 초기화 문장만 실행됨을 컴파일러가 확인할 수 있다면 조건에 따라 val 값을 다른 여러 값으로 초기화할 수도 있다.

```kotlin
val message: String
if (canPerformOperation()) {
	message = "Success"
} else {
	message = "Failed"
}
```

val 참조 차제는 불변일지라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다.

```kotlin
val languages = arrayListOf("Java")
languages.add("Kotlin")
```

var 키워드를 사용하면 변수의 값을 변경할 수 있지만 변수의 타입은 고정돼 바뀌지 않는다.

```kotlin
var answer = 42
answer = "no answer"
```

컴파일러는 변수 선언 시점의 초기화 식으로부터 변수의 타입을 추론하며, 변수 선언 이후 변수 재대입이 이뤄질 때는 이미 추론한 변수의 타입을 염두에 두고 대입문의 타입을 검사한다.

어떤 타입의 변수에 다른 타입의 값을 저장하고 싶다면 변환 함수를 써서 값을 변수의 타입으로 변환하거나, 값을 변수에 대입할 수 있는 타입으로 강제 형 변환해야 한다.

### 2.1.4 더 쉽게 문자열 형식 지정: 문자열 템플릿

- 컴파일러는 각 식을 정적으로( 컴파일 시점에) 검사하기 때문에 존재하지 않는 변수를 문자열 템플릿 안에서 사용하면 컴파일 오류가 발생한다.
- $ 문자를 문자열에 넣고 싶으면 println(”\$x”)와 같이 \를 사용해 $를 이스케이프 시켜야 한다.
- 복잡한 식도 중괄호로 둘러싸서 문자열 템플릿 안에 넣을 수 있다.
- 문자열 템플릿 안에서 변수 이름만 사용하는 경우라도 중괄호로 변수명을 감싸는 습관을 들이면 좋다.

## 2.2 클래스와 프로퍼티

### 2.2.1 프로퍼티

**프로퍼티**

- 자바에서는 필드오 접근자를 한데 묶어 프로퍼티라고 부름.
- 코틀린에서는 프로퍼티를 언어 기본 기능으로 제공.
- 코틀린에서는 자바의 필드와 접근자 메소드를 완전히 대신한다.
- 클래스에서 프로퍼티를 선언할 때 val이나 var tkdyd
- 코틀린에서 프로퍼티를 선언하는 방식은 프로퍼티와 관련 있는 접근자를 선언하는 것이다.

코틀린은 값을 저장하기 위한 비공개 필드와 그 필드에 값을 저장하기 위한 세터, 필드의 값을 읽기 위한 게터로 이뤄진 간단한 디폴트 접근자 구현을 제공한다.

대부분의 프로퍼티에는 그 프로퍼티의 값을 저장하기 위한 필드가 있다.

→ 프로퍼티를 뒷받침하는 필드(backing field)

### 2.2.2 커스텀 접근자

```kotlin
class Rectangle(val height: Int, val width: Int) {
	val isSquare: Boolean
		get() {
			return height == widt
		}
	}
```

→ 이 프로퍼티에는 자체 구현을 제공하는 게터만 존재

→ 클라이언트가 프로퍼티에 접근할 때마다 게터가 프로퍼티 값을 매번 다시 계산

→ 가독성의 차이

### 2.2.3 코틀린 소스코드 구조: 디렉터리와 패키지

같은 패키지에 속해 있다면 다른 파일에서 정의한 선언일지라도 직접 사용할 수 있다. 

다른 패키지에 정의한 선언을 사용하려면 임포트를 통해 선언을 불러와야 한다.

코틀린에서는 클래스 임포트와 함수 임포트에 차이가 없으며, 모든 선언을 import 키워드로 가져올 수 있다. 

최상위 함수는 그 이름을 서서 임포트 할 수 있다.

스타(*) 임포트를 사용하면 패키지 안에 잇는 모든 클래스 뿐만 아니라 최상위에 정의도니 함수나 프로퍼티까지 모두 불러온다.

코틀린에서는 여러 클래스를 한 파일에 넣을 수 있고, 파일의 이름도 마음대로 정할 수 있다.

디스크상의 어느 디렉터리에 소스코드 파일을 위치 시키든 관계 없다.

→ 자바와 같이 패키지별로 디렉터리를 구성하는 것이 낫다.

## 2.3 선택 표현과 처리: enum과 when

### 2.3.1 enum 클래스 정의

코틀린에서는 enum은 소프트 키워드(soft keyword)라 부르는 존재다.

→ enum은 class 앞에 있을 때는 특별한 의미를 지니지만 다른 곳에서는 이름에 사용할 수 있다.

class는 키워드다.

→class라는 이름을 사용할 수 없으므로 클래스를 표현하는 변수 등을 정의할 때는 clazz나 aClass와 같은 이름을 사용해야 한다.

enum 

- 단순히 값만 열거하는 존재 아니다.
- 프로퍼티나 메서드를 정의할 수 있다.
- 일반적인 클래스와 마찬가지로 생성자와 프로퍼티를 선언한다.
- enum 상수를 정의할 때는 그 상수에 해당하는 프로퍼티 값을 지정해야만 한다.
- enum 클래스 안에 메소드를 정의하는 경우 반드시 enum 상수 목록과 메소드 정의 사이에 세미콜론을 넣어야 한다.

### 2.3.2 when으로 enum 클래스 다루기

when도 값을 만들어내는 식이다.

→ 식이 본문인 함수에 바로 사용할 수 있다.

### 2.3.3 when과 임의의 객체를 함께 사용

코틀린 when의 분기 조건은 임의의 객체를 허용한다.

when 식은 인자 값과 매치하는 조건 값을 찾을 때까지 각 분기를 검사한다. 

when은 분기 조건 부분에 식을 넣을 수 있기 때문에 많은 경우 코드를 더 간결하고 아름답게 작성할 수 있다.

### 2.3.4 인자 없는 when 사용

인자가 없는 when식을 사용하면 불필요한 객체 생성을 막을 수 있다.

→ 코드는 약간 읽기 어려워지지만 성능을 더 향상시키기 위해 그 정도 비용을 감수해야 하는 경우도 자주 있다.

when에 아무 인자도 없으려면 각 분기의 조건이 불리언 결과를 계산하는 식이어야 한다.

### 2.3.5 스마트 캐스트: 타입 검사와 타입 캐스트를 조합

코틀린에서는 is를 사용해 변수 타입을 검사한다.

코틀린에서는 컴파일러가 캐스팅을 해준다.(**스마트 캐스트**)

→ 어떤 변수가 원하는 타입인지 일단 is로 검사하고 나면 굳이 변수를 원하는 타입으로 캐스팅하지 않아도 마치 처음부터 그 변수가 원하는 타입으로 선언된 것처럼 사용할 수 있다.

스마트 캐스트는 is로 변수에 든 값의 타입을 검사한 다음에 그 값이 바뀔 수 없는 경우에만 작동한다.

→ 클래스의 프로퍼티에 대해 스마트 캐스트를 사용한다면 그 프로퍼티는 반드시 val이어야 하며 커스텀 접근자를 사용한 것이어도 안된다.

원하는 타입으로 명시적으로 타입 캐스팅하려면 as 키워드를 사용한다.

### 2.3.7 if와 when의 분기에서 블록 사용

if나 when 모두 분기에 블록을 사용할 수 있다. 그런 경우 블록의 마지막 문장이 블록 전체의 결과가 된다. 

→ 이 규칙은 함수에 대해서는 성립하지 않는다.
