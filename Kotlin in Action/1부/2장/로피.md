# 2장 코틀린 기초

## 2.1 기본 요소: 함수와 변수

### 2.1.1 Hello, World!

```kotlin
fun main(args: Array<String>) {
	println("Hello, world!")
}
```

- 함수를 선언할 때 fun 키워드를 사용한다.
- 파라미터 이름 뒤에 그 파라미터의 타입을 쓴다.
- 함수를 최상위 수준에 정의할 수 있다.
- 배열도 일반적인 클래스와 마찬가지다.
- println을 사용
    - 코틀린 표준 라이브러리는 여러 가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 래퍼를 제공
- 줄 끝에 세미콜론을 붙이지 않아도 된다.

### 2.1.2 함수

- 함수 선언은 fun 키워드로 시작한다.
- fun 다음에는 함수 이름이 온다.
- 함수 이름 뒤에는 괄호 안에 파라미터 목록이 온다.
- 함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 오는데, 괄호와 반환 타입 사이를 콜론(:)으로 구분해야 한다.

```kotlin
fun max(a: Int, b: Int): Int {
	return if (a > b) a else b
}
```

- if는 문장이 아니고 결과를 만드는 식
- if식은 3항 연산자로 작성한 (a > b) ? a : b 식과 비슷

> **문(statement)과 식(expression) 구분**

식 - 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있다.
문 - 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다.

코틀린에서는 루프를 제외한 대부분의 제어 구조가 식이다.
대입문은 자바에서 식이엇으나 코틀린에서는 문이 됐다.
> 

**식이 본문인 함수**

본문이 중괄호로 둘러싸인 함수 - 블록이 본문인 함수

등호와 식으로 이루어진 함수 - 식이 본문인 함수

코틀린에서는 식이 본문인 함수가 자주 쓰인다. 함수의 본문 식에는 단순한 산술식이나 함수 호출 식뿐 아니라 if, when, try 등의 더 복잡한 식도 자주 쓰인다.

```kotlin
fun max(a: Int, b: Int) = if ( a > b ) a else b
```

→ 식이 본문인 함수의 경우 굳이 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해서 식의 결과 타입을 함수 반환 타입으로 정해준다.

**타입 추론(type inference)**

- 컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소의 타입을 정해주는 기능

식이 본문인 함수의 반환 타입만 생략 가능, 블록이 본문인 함수가 값을 반환한다면 반드시 반환 타입을 지정하고 return문을 사용해 반환 값을 명시해야 한다.

### 2.1.3 변수

- 코틀린에서는 키워드로 변수 선언을 시작하는 대신 변수 이름 뒤에 명시하거나 생략하게 허용한다.
- 타입을 지정하지 않으면 컴파일러가 초기화 식을 분석해서 초기화 식의 타입을 변수 타입으로 지정한다.
- 부동소수점(floating point) 상수를 사용한다면 변수 타입은 Double이 된다.
- 초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야 한다.
- 초기화 식이 없다면 변수에 저장될 값에 대해 아무 정보가 없기 때문에 컴파일러가 타입을 추론할 수 없다. 그런 경우 타입을 반드시 지정해야 한다.

**변경 가능한 함수와 변경 불가능한 함수**

- val - 변경 불가능한(immutable) 참조를 저장하는 변수, 일단 초기화하고 나면 재대입이 불가능하다.
- var - 변경가능한(mutable) 참조다. 이런 변수의 값은 바뀔 수 있다.

기본적으로는 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때에만 var로 변경해라. 변경 불가능한 참조외 변경 불가능한 객체를 부수 효과가 없는 함수와 조합에 사용하면 코드가 함수형 코드에 가까워진다.

val 변수는 블록을 실행할 때 정확히 한 번만 초기화돼야 한다.

어떤 블록이 실행될 때 오직 한 초기화 문장만 실행됨을 컴파일러가 확인할 수 있다면 조건에 따라 val 값을 다른 여러 값으로 초기화할 수도 있다.

```kotlin
val message: String
if (canPerformOperation()) {
	message = "Success"
} else {
	message = "Failed"
}
```

val 참조 차제는 불변일지라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다.

```kotlin
val languages = arrayListOf("Java")
languages.add("Kotlin")
```

var 키워드를 사용하면 변수의 값을 변경할 수 있지만 변수의 타입은 고정돼 바뀌지 않는다.

```kotlin
var answer = 42
answer = "no answer"
```

컴파일러는 변수 선언 시점의 초기화 식으로부터 변수의 타입을 추론하며, 변수 선언 이후 변수 재대입이 이뤄질 때는 이미 추론한 변수의 타입을 염두에 두고 대입문의 타입을 검사한다.

어떤 타입의 변수에 다른 타입의 값을 저장하고 싶다면 변환 함수를 써서 값을 변수의 타입으로 변환하거나, 값을 변수에 대입할 수 있는 타입으로 강제 형 변환해야 한다.

### 2.1.4 더 쉽게 문자열 형식 지정: 문자열 템플릿

- 컴파일러는 각 식을 정적으로( 컴파일 시점에) 검사하기 때문에 존재하지 않는 변수를 문자열 템플릿 안에서 사용하면 컴파일 오류가 발생한다.
- $ 문자를 문자열에 넣고 싶으면 println(”\$x”)와 같이 \를 사용해 $를 이스케이프 시켜야 한다.
- 복잡한 식도 중괄호로 둘러싸서 문자열 템플릿 안에 넣을 수 있다.
- 문자열 템플릿 안에서 변수 이름만 사용하는 경우라도 중괄호로 변수명을 감싸는 습관을 들이면 좋다.

## 2.2 클래스와 프로퍼티

### 2.2.1 프로퍼티

**프로퍼티**

- 자바에서는 필드오 접근자를 한데 묶어 프로퍼티라고 부름.
- 코틀린에서는 프로퍼티를 언어 기본 기능으로 제공.
- 코틀린에서는 자바의 필드와 접근자 메소드를 완전히 대신한다.
- 클래스에서 프로퍼티를 선언할 때 val이나 var tkdyd
- 코틀린에서 프로퍼티를 선언하는 방식은 프로퍼티와 관련 있는 접근자를 선언하는 것이다.

코틀린은 값을 저장하기 위한 비공개 필드와 그 필드에 값을 저장하기 위한 세터, 필드의 값을 읽기 위한 게터로 이뤄진 간단한 디폴트 접근자 구현을 제공한다.

대부분의 프로퍼티에는 그 프로퍼티의 값을 저장하기 위한 필드가 있다.

→ 프로퍼티를 뒷받침하는 필드(backing field)

### 2.2.2 커스텀 접근자

```kotlin
class Rectangle(val height: Int, val width: Int) {
	val isSquare: Boolean
		get() {
			return height == widt
		}
	}
```

→ 이 프로퍼티에는 자체 구현을 제공하는 게터만 존재

→ 클라이언트가 프로퍼티에 접근할 때마다 게터가 프로퍼티 값을 매번 다시 계산

→ 가독성의 차이

### 2.2.3 코틀린 소스코드 구조: 디렉터리와 패키지

같은 패키지에 속해 있다면 다른 파일에서 정의한 선언일지라도 직접 사용할 수 있다. 

다른 패키지에 정의한 선언을 사용하려면 임포트를 통해 선언을 불러와야 한다.

코틀린에서는 클래스 임포트와 함수 임포트에 차이가 없으며, 모든 선언을 import 키워드로 가져올 수 있다. 

최상위 함수는 그 이름을 서서 임포트 할 수 있다.

스타(*) 임포트를 사용하면 패키지 안에 잇는 모든 클래스 뿐만 아니라 최상위에 정의도니 함수나 프로퍼티까지 모두 불러온다.

코틀린에서는 여러 클래스를 한 파일에 넣을 수 있고, 파일의 이름도 마음대로 정할 수 있다.

디스크상의 어느 디렉터리에 소스코드 파일을 위치 시키든 관계 없다.

→ 자바와 같이 패키지별로 디렉터리를 구성하는 것이 낫다.

## 2.3 선택 표현과 처리: enum과 when

### 2.3.1 enum 클래스 정의

코틀린에서는 enum은 소프트 키워드(soft keyword)라 부르는 존재다.

→ enum은 class 앞에 있을 때는 특별한 의미를 지니지만 다른 곳에서는 이름에 사용할 수 있다.

class는 키워드다.

→class라는 이름을 사용할 수 없으므로 클래스를 표현하는 변수 등을 정의할 때는 clazz나 aClass와 같은 이름을 사용해야 한다.

enum 

- 단순히 값만 열거하는 존재 아니다.
- 프로퍼티나 메서드를 정의할 수 있다.
- 일반적인 클래스와 마찬가지로 생성자와 프로퍼티를 선언한다.
- enum 상수를 정의할 때는 그 상수에 해당하는 프로퍼티 값을 지정해야만 한다.
- enum 클래스 안에 메소드를 정의하는 경우 반드시 enum 상수 목록과 메소드 정의 사이에 세미콜론을 넣어야 한다.

### 2.3.2 when으로 enum 클래스 다루기

when도 값을 만들어내는 식이다.

→ 식이 본문인 함수에 바로 사용할 수 있다.

### 2.3.3 when과 임의의 객체를 함께 사용

코틀린 when의 분기 조건은 임의의 객체를 허용한다.

when 식은 인자 값과 매치하는 조건 값을 찾을 때까지 각 분기를 검사한다. 

when은 분기 조건 부분에 식을 넣을 수 있기 때문에 많은 경우 코드를 더 간결하고 아름답게 작성할 수 있다.

### 2.3.4 인자 없는 when 사용

인자가 없는 when식을 사용하면 불필요한 객체 생성을 막을 수 있다.

→ 코드는 약간 읽기 어려워지지만 성능을 더 향상시키기 위해 그 정도 비용을 감수해야 하는 경우도 자주 있다.

when에 아무 인자도 없으려면 각 분기의 조건이 불리언 결과를 계산하는 식이어야 한다.

### 2.3.5 스마트 캐스트: 타입 검사와 타입 캐스트를 조합

코틀린에서는 is를 사용해 변수 타입을 검사한다.

코틀린에서는 컴파일러가 캐스팅을 해준다.(**스마트 캐스트**)

→ 어떤 변수가 원하는 타입인지 일단 is로 검사하고 나면 굳이 변수를 원하는 타입으로 캐스팅하지 않아도 마치 처음부터 그 변수가 원하는 타입으로 선언된 것처럼 사용할 수 있다.

스마트 캐스트는 is로 변수에 든 값의 타입을 검사한 다음에 그 값이 바뀔 수 없는 경우에만 작동한다.

→ 클래스의 프로퍼티에 대해 스마트 캐스트를 사용한다면 그 프로퍼티는 반드시 val이어야 하며 커스텀 접근자를 사용한 것이어도 안된다.

원하는 타입으로 명시적으로 타입 캐스팅하려면 as 키워드를 사용한다.

### 2.3.7 if와 when의 분기에서 블록 사용

if나 when 모두 분기에 블록을 사용할 수 있다. 그런 경우 블록의 마지막 문장이 블록 전체의 결과가 된다. 

→ 이 규칙은 함수에 대해서는 성립하지 않는다.

## 2.4 대상을 이터레이션: while과 for 루프

### 2.4.1 while 루프

**while 루프**

- 조건이 참인 동안 본문을 반복 실행

```kotlin
while (조건) {
	/*...*/
}
```

**do-while 루프**

- 맨 처음에 무조건 본문을 한 번 실행한 다음, 조건이 참인 동안 본문을 반복 실행한다.

```kotlin
do {
	/*...*/
} while (조건)
```

### 2.4.2 수에 대한 이터레이션: 범위와 수열

코틀린에서는 범위를 사용한다.

- 범위는 기본적으로 두 값으로 이뤄진 구간
- .. 연산자로 시작 값과 끝 값을 연결해서 범위를 만든다.
- 코틀린의 범위는 폐구간 또는 양끝을 포함하는 구간이다.

**수열**

- 어떤 범위에 속한 값을 일정한 순서로 이터레이션하는 경우

ex) fizz-buzz

```kotlin
fun fizzBuzz(i: Int) = when {
	i % 15 == 0 -> "FizzBuzz"
	i % 3 == 0 -> "Fizz"
	i % 5 == 0 -> "Buzz"
	else -> "$i"
}

>>> for(i in 1..100) {
	...print(fizzBuzz(i))
	...}
}

1 2 Fizz 4 Buzz Fizz 7 ...
```

```kotlin
>>> for (i in 100 downTo 1 step 2) {
...   print(fizzBuzz(i))
... }

Buzz 98 Fizz 94 92 FizzBuzz 88 ...
```

→ 증가 값 step을 갖는 수열에 대해 이터레이션한다.

- 증가 값을 사용하면 수를 건너 뛸 수 있다.
- 증가 값을 음수로 만들면 정방향 수열이 아닌 역방향 수열을 만들 수 있다. (step은 무조건 positive)
- downTo를 사용하면 역방향 수열을 만든다, step 뒤에 숫자를 붙이면 절대값으로 바뀌지만 실제로는 음수.

**until 함수**

- 끝 값을 포함하지 않는 반만 닫힌 범위에 대해 이터레이션할 때 사용
- for(x in 0 until size) == for(x in 0..size-1)

### 2.4.3 맵에 대한 이터레이션

**맵을 초기화하고 이터레이션하기**

```kotlin
val binaryRes = TreeMap<Char, String>()
// 키에 대해 정렬하기 위해 TreeMap 사용

for(c in 'A'..'F') {
	val binary = Integer.toBinaryString(c.toInt())
	binaryReps[c] = binary
}

for ((letter, binary) in binaryReps) {
	println("$letter = $binary")
}
```

- .. 연산자를 숫자 타입의 값뿐 아니라 문자 타입의 값에도 적용할 수 있다.
- get, put을 사용하는 대신 map[key]나 map[key] = value를 사용해 값을 가져오고 설정할 수 있다.
- 맵에 사용했던 구조 분해 구문을 맵이 아닌 컬렉션에도 활용할 수 있다.
    - 이런 구조 분해 구문을 사용하면 원소의 현재 인덱스를 유지하면서 컬렉션을 이터레이션할 수 있다.
    
    ```kotlin
    val list = arrayListOf("10", "11", "1001")
    for ((index, element) in list.withIndex()) {
    	println("$index: $element")
    }
    ```
    

### 2.4.4 in으로 컬렉션이나 범위의 원소 검사

in 연산자

- 어떤 값이 범위에 속하는지 검사

!in 연산자

- 어떤 값이 범위에 속하지 않는지 검사

→ in, !in 연산자를 when 식에서도 사용해도 된다.

범위는 문자에만 국한되지 않는다.

- 비교가 가능한 클래스라면 그 클래스의 인스턴스 객체를 사용해 범위를 만들 수 있다.
- Comparable을 사용하는 범위의 경우 그 범위 내의 모든 객체를 항상 이터레이션하지는 못한다.
    - 하지만 in 연산자를 사용하면 값이 범위 안에 속하는지 결정할 수 있다.
    - String 에 있는 Comparable 구현이 두 문자열을 알파벳 순서로 비교

## 2.5 코틀린의 예외 처리

코틀린의 기본 예외 처리 구문은 자바와 비슷하다.

```kotlin
if (percentage !in 0..100) {
	throw IllegalArgumentException(
		"..."
	)
}
// throw는 식이므로 다른 식에 포함될 수 있다.
```

### 2.5.1 try, catch, finally

```kotlin
fun readNumber(reader: BufferedReader): Int? {
	try {
		val line = reader.readLine()
		return Integer.parseInt(line)
	}
	catch (e: NumberFormatException) {
		return null
	}
	finally {
		reader.close()
	}
}
```

- 코틀린에서는 throws절이 코드에 없다.
    - 자바에서는 함수를 작성할 때 함수 선언 뒤에 throws IOException을 붙여야 한다. (체크 예외이기 때문)
    - 자바에서는 체크예외를 명시적으로 처리해야 한다. 어떤 함수가 던질 가능성이 있는 예외나 그 함수가 호출한 다른 함수에서 발생할 수 있는 예외를 모두 catch로 처리해야 하며, 처리하지 않은 예외는 throws절에 명시해야 한다.
    - 체크 예외 - 복구 가능성이 있는 예외이므로 반드시 예외를 처리하는 코드를 함께 작성해야 한다.

- 코틀린은 체크 예외와 언체크 예외를 구별하지 않는다.
- 코틀린에서는 함수가 던지는 예외를 지정하지 않고 발생한 예외를 잡아내도 되고 잡아내지 않아도 된다.
- NumerFormatException은 체크 예외가 아니라서 자바 컴파일러는 잡아내게 강제하지 않는다.

### 2.5.2 try를 식으로 사용

```kotlin
fun readNumber(reader: BufferedReader) {
	val number = try {
		Integer.parseInt(reader.readLine())
	} catch (e: NumberFormatException) {
		return
	}
	println(number)
}
```

- try 키워드는 식이다.
    - try 본문을 반드시 중괄호 {}로 둘러싸야 한다.
    - try 본문도 내부에 여러 문장이 있으면 마지막 식의 값이 전체 결과 값이다.
    - try 코드 블록의 실행이 정상적으로 끝나면 그 블록의 마지막 식의 값이 결과다. 예외가 발생하고 잡히면 그 예외에 해당하는 catch 블록의 값이 결과다.

## 2.6 요약

- 함수를 정의할 때 fun 키워드 사용. val, var는 각각 읽기 전용 변수와 변경 가능한 변수를 선언할 때 쓰인다.
- 문자열 템플릿을 사용하면 문자열을 연결하지 않아도 되므로 코드가 간결해진다. 변수 이름 앞에 $를 붙이거나, 식을 ${식}처럼 ${}로 둘러싸면 변수나 식의 값을 문자열 안에 넣을 수 있다.
- 코틀린에서는 값 객체 클래스를 아주 간결하게 표현할 수 있다.
- 코틀린에서 if는 식이며, 값을 만들어낸다.
- when은 자바의 switch보다 강력하다.
- 컴파일러가 스마트 캐스트를 활용해 자동으로 타입을 바꿔준다.
- 코틀린의 for는 자바의 for보다 더 편리하다. 맵을 이터레이션하거나 이터레이션하면서 컬렉션의 원소나 인덱스를 함께 사용해야 하는 경우 코틀린의 for가 더 편리하다.
- 범위와 수열은 코틀린에서 같은 문법을 사용하며, for 루프에 대해 같은 추상화를 제공한다. 어떤 값이 범위 안에 들어있거나 들어잇지 않은지 검사하기 위해서 in이나 !in을 사용한다.
- 코틀린에서는 함수가 던질 수 있는 예외를 선언하지 않아도 된다.
