# 1장. 코틀린이란 무엇이며, 왜 필요한가?

## 코틀린 맛보기

- **코틀린**: 자바 플랫폼에서 돌아가는 새로운 프로그래밍 언어
    - 간결하고 실용적
    - 자바 코드와의 상호운용성을 중시
- e.g.
    
    ```kotlin
    data class Person(val name: String, val age: Int? = null)
    
    fun main(args: Array<String>) {
            val persons = listOf(Person("su"), Person("jin", age = 25))
            
            val oldest = persons.maxBy { it.age ?: 0 }
            println("The oldest: $oldest")
    }
    ```
    
    - data class
    - nullable type
        - 컴파일 시점에서 자바의 **wrapper** 타입으로 자동 변환
    - parameter default value

## 코틀린의 주요 특성

### 대상 플랫폼

- 서버, 안드로이드 등 **자바가 실행되는 모든 곳**
- 다른 환경에서도 잘 작동함
    - 인텔의 멀티OS 엔진 사용 → iOS 디바이스에서 실행 가능
    - 코틀린 + 토네이도FX / 자바FX 사용 → 데스크탑 애플리케이션 작성 가능

### 정적 타입 (statically typed) 지정 언어

- 모든 프로그램 구성 요소의 타입을 컴파일 시점에 알 수 있고,
- 프로그램 안에서 객체의 필드나 메소드를 사용할 때마다 컴파일러가 타입을 검증해줌

- ↔ 동적 타입 (dynamically typed) 지정 언어
    - JVM groovy, JRuby
    - 타입과 관계없이 모든 값을 변수에 넣을 수 있고, 메소드나 필드 접근에 대한 검증이 실행 시점에 발생함
    - 코드가 짧아지고 데이터 구조를 더 유연하게 생성하고 사용 가능
    - 실수를 컴파일 시 걸러내지 못하고 실행 시점에 오류가 발생

- 타입 추론 (type inference)
    - 자바와 달리, 코틀린에서는 **타입 선언 생략 가능**
    - 코틀린 컴파일러가 문맥으로부터 변수 타입을 자동으로 유추함

- 정적 타입 지정의 장점
    - `성능`: 실행 시점에 어떤 메소드를 호출할지 알아내는 과정이 필요 없어 호출이 더 빠름
    - `신뢰성`: 컴파일러가 프로그램의 정확성을 검증하므로 프로그램이 오류로 중단될 가능성 낮아짐
    - `유지 보수성`: 코드에서 다루는 객체가 어떤 타입에 속하는지 알 수 있어 코드를 다룰 때 더 쉬움
    - `도구 지원`: 더 안전하게 리팩토링 가능, 도구는 더 정확한 코드 완성 기능을 제공할 수 있음

- nullable type 지원
    - 컴파일 시점에 npe 발생 가능 여부를 검사할 수 있어 신뢰성을 높임

### 함수형 프로그래밍, 객체지향 프로그래밍

- 함수형 프로그래밍 (functional programming)
    - `first-class 함수`
        - 함수를 일반 값처럼 다룰 수 있다.
        - 함수를 변수에 저장하고, 인자로 전달하고, 함수에서 새로운 함수를 만들어 반환할 수 있다.
    - `불변성`
        - 불변 객체를 사용해 프로그램을 작성
    - `side effect 없음`
        - 입력이 같으면 항상 같은 출력 / 다른 객체의 상태 변경 안함 / 함수 외부와 상호작용하지 않음 ⇒ 순수 함수 (pure function) 사용

- 함수형 프로그래밍 장점
    - `간결성`
        - 명령형 코드에 비해 간결하고 우아함
        - 순수 함수를 값처럼 활용함으로써 더 강력한 추상화가 가능, 이를 통해 코드 중복을 방지할 수 있음
        - 람다 식이라 불리는 무명 함수 구문을 사용하여 간결하게 표현 가능
    - `safe multithreading`
        - 다중 스레드를 사용해도 안전
        - 다중 스레드에서 적절한 동기화 없이 같은 데이터를 여러 스레드가 변경하는 경우 주로 문제 발생
        - 불변 데이터 구조 + 순수 함수를 적용하면 같은 데이터를 여러 스레드가 변경할 수 없음
    - `테스트 용이`
        - 순수 함수는 독립적으로 테스트할 수 있음

### 무료 오픈소스

- 코틀린 언어, 컴파일러, 라이브러리 및 관련된 모든 도구는 모두 **오픈소스**이며, 어떤 목적에든 무료로 사용 가능
- 코틀린은 Apache2 라이선스하에 제공됨
- 개발은 GitHub를 통해 이뤄지고 있음 (https://github.com/jetbrains/kotlin)

## 코틀린 응용

### 코틀린 서버 프로그래밍

- 기존에 많이 만들어진 자바 기반 코드들 존재
- 기존 프레임워크나 기술을 확장하고 개선하거나 대치해야할 때, 코틀린은 자바와 상호운영이 가능
    - 새로운 컴포넌트 작성, 기존 서비스 코드 migration 용이
- 코틀린의 새로운 기술을 활용해 서버 시스템 개발 가능
    - 빌더 패턴 활용하여 간결한 구문 사용
    

### 코틀린 안드로이드 프로그래밍

- 기존 코드 기반과 새 코드를 통합할 필요가 적음
- 다양한 디바이스에 대해 서비스의 신뢰성을 보장하면서 더 빠르게 개발해 배포할 필요가 잇있음
- ⇒ 코틀린 언어의 특성 + 안드로이드 프레임워크의 컴파일러 플러그인 지원 ⇒ 생산성!
- 개발 작업을 훨씬 더 적은 코드로 달성 가능
- 어플리케이션의 신뢰성 증가
    - null값을 정확히 추적하며 NPE로 인한 문제를 줄여줌

## 코틀린의 철학

### 실용성

- 실제 문제를 해결하기 위해 만들어진 실용적인 언어
- 연구를 위한 언어가 아님
    - 다른 프로그래밍 언어가 채택한 검증된 해법과 기능에 의존
    - 언어의 복잡도가 줄어들고, 이미 알고 있는 기존 개념을 통해 더 쉽게 배울 수 있음
- 특정 프로그래밍 스타일이나 패러다임 사용이 강제되지 않음
- 도구 강조
    - 편리한 개발 환경도 생산성 향상에 필수
    - 언어를 먼저 설계하고 IDE 지원을 고민한 것이 아니라, intelliJ 아이디어의 개발과 컴파일러의 개발이 맞물려 있음
    - IDE에서 코드 패턴을 자동으로 감지하고 수정 제안을 함

### 간결성

- 코드를 새로 작성하는 시간 <<<<< 기존 코드를 읽는 시간
- 간단하고 간결한 코드가 내용을 파악하기 쉬움
- 의미 없는 부분과 부수적인 요소를 줄이고, 번거로운 준비 코드(e.g. getter/setter)를 묵시적으로 제공함

### 안전성

- 언어가 안전하다: 발생 가능한 오류 중 일부 유형의 오류를 프로그램 설계가 원천적으로 방지해준다는 뜻
- 오류를 방지하는 데에는 trade off가 존재함 (안전성 — 생산성)
    - 컴파일러에게 더 많은 정보를 제공해야만 더 큰 안정성을 얻을 수 있음
- JVM에서 실행함으로써 상당한 안정성을 보장함
- 코틀린 컴파일러의 타입 자동 추론 (적은 정보 제공)
- 실행 시점이 아닌 컴파일 시점 검사를 통해 오류를 더 많이 방지
    - NPE이 발생할 수 있는 연산을 사용하는 코드 금지, nullable 타입 제공
    - ClassCastException: 타입 검사와 캐스트가 한 연산자에 의해 이뤄짐으로써 타입 검사를 생략하지 않게 됨

### 상호운용성

- 기존 라이브러리를 그대로 사용할 수 있는가? ⇒ YES
    - 자바 클래스 상속/확장, 자바 인터페이스 구현, 자바 애노테이션 적용 등 모두 가능
- 자바와 코틀린 코드 혼용 가능
    - 자바 코드에서 코틀린 코드 호출할 때도 아무런 노력이 필요 없음
    - 프로그램 컴파일에도 문제가 없음
- 기존 자바 라이브러리를 최대한 활용
    - 자바 표준 라이브러리 클래스에 의존
    - 코틀린 컬렉션을 더 쉽게 활용할 수 있는 몇 가지 기능을 추가

## 코틀린 도구 사용

### 코드 컴파일

- 코틀린도 컴파일 언어, 코드 실행 전 코드 컴파일 필요
- 컴파일 과정
    - `.kt` 확장자가 붙은 코틀린 소스코드 파일
    - 컴파일러가 소스코드를 분석해 `.class` 파일 생성
    - 만들어진 `.class` 파일은 개발 중인 어플리케이션의 유형에 맞는 표준 패키징 과정을 거쳐 실행됨
        - 가장 간단한 방식: 커맨드라인에서 `kotlinc` 명령을 통해 코틀린 코드 컴파일한 다음 `java` 명령으로 그 코드를 실행
            
            ```kotlin
            kotlinc <source file> -include-runtime -d <jar name>
            java-jar <jar name>
            ```
            
        
        ![kotlin build 과정](https://prod-files-secure.s3.us-west-2.amazonaws.com/d4809f18-a915-4e30-8b11-8f015eacff00/47d74bec-c678-4948-9bc7-4166e2c5bc8f/image.png)
        
        kotlin build 과정
        
    - 컴파일한 코드는 kotlin runtime library에 의존함
        - 코틀린 자체 표준 라이브러리 클래스, 코틀린에서 자바 API의 기능을 확장한 내용 포함됨
        - 코틀린으로 컴파일한 어플리케이션 배포 시, 런타임 라이브러리도 함께 배포해야 함
- 실제 개발 시 프로젝트 진행을 위해 maven, gradle, ant 등의 빌드 시스템 사용할 것

### 코틀린 플러그인

- intelliJ, android studio에서 제공하는 다양한 기능

### 대화형 셸

- 대화형 셸 == REPL (read-eval-print loop, 입력받아 값 게산해서 결과 값을 출력하는 루프)
- REPL에서 코틀린 코드 한 줄 입력하면 그 즉시 코드를 실행한 결과를 볼 수 있음
    - Tool > Kotlin > Kotlin REPL pulgin

### kotlin playground

### java-kotlin 변환기

- 자동으로 자바를 코틀린으로 변환하는 도구
- (intelliJ) Code > Convert Java File to Kotlin File

## 요약

- 코틀린은 타입 추론을 지원하는 정적 타입 지정 언어
    - 정확성과 성능 보장, 간결성 유지
- 객체지향 + 함수형 프로그래밍 스타일 모두 지원
    - 일급 시민 함수를 사용한 수준 높은 추상화
    - 불변 값 지원을 통한 다중 스레드 개발과 테스트 용이
- 서버 어플리케이션 개발에 활용
- 안드로이드 개발에 활용
- 무료, 오픈소스, 주요 IDE와 빌드 시스템 제공
- 실용적, 안전, 간결, 상호운영성
