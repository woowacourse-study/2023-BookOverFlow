# 1장 코틀린이란 무엇이며, 왜 필요한가?

## 코틀린

- 간결하고 실용적이며, 자바 코드와 상호운용성을 중시한다.

<br><br>

## 1.2 코틀린의 주요 특성

### 1.2.1 대상 플랫폼: 서버, 안드로이드 등 자바가 실행되는 모든 곳

- 코틀린의 주목적은 자바가 사용되고 있는 모든 용도에 적합하면서도 더 간결하고 생산적이며 안전한 대체 언어를 제공하는 것이다.
- 코틀린을 활용할 수 있는 일반적인 영역
    - 서버 코드
    - 안드로이드
- 코틀린은 어느 한 문제 영역만을 해결하거나 소프트웨어 개발이 처한 어려움 중 일부만을 다루기 위한 언어가 아니다.

<br>

### 1.2.2 정적 타입 지정 언어

**정적 타입(statically typed) 지정**

- 타입을 컴파일 시점에 알 수 있다.
- 객체의 필드나 메소드를 사용할 때마다 컴파일러가 타입을 검증해주는 것
- 장점
    - **성능**: 실행 시점에 어떤 메서드를 호출할지 알아내는 과정이 필요 없기에 메서드 호출이 빠르다.
    - **신뢰성**: 컴파일러가 정확성을 검증하기 때문에 실행 시 오류로 중단될 가능성이 적어진다.
    - **유지 보수성**: 객체가 어떤 타입인지 알 수 있기에 처음 보는 코드를 다룰 때 더 쉽다.
    - **도구 지원**: ****안전하게 리팩터링이 가능하다.

**동적 타입(dynamically typed) 지정 언어**

- 타입과 관계없이 모든 값을 변수에 넣을 수 있다.
- 메소드나 필드 접근에 대한 검증이 실행 시점에 일어난다.
- 코드가 짧아지고 데이터 구조를 유연하게 사용할 수 있다.
- 실행 시점에 오류가 발생한다.
- JVM에서는 그루비나 JRuby가 대표적인 동적 타입 지정 언어다.

코틀린 컴파일러가 문맥으로부터 변수 타입을 자동으로 유추할 수 있는데, 이를 **타입 추론(type inference)**이라고 부른다.

코틀린은 널이 될 수 있는 타입(nullable type)을 지원한다.

컴파일 시점에 널 포인터 예외(null pointer exception)가 발생할 수 있는지 여부를 검사할 수 있어 신뢰성을 높일 수 있다.

<br>

### 1.2.3 함수형 프로그래밍과 객체지향 프로그래밍

- 일급 시민(first-class) 함수
    - 함수를 일반 값처럼 다룰 수 있다.
    - 함수를 변수에 저장할 수 있고, 함수를 다른 함수의 인자로 전달할 수 있으며, 함수에서 새로운 함수를 만들어 반환할 수 있다.
- 불변성(immutability)
    - 함수형 프로그래밍에서는 일단 만들어지고 나면 내부 상태가 절대로 바뀌지 않는 불변 객체를 사용한다.
- 부수 효과(side effect) 없음
    - 함수형 프로그래밍에서는 입력이 같으면 항상 같은 출력을 내놓고 다른 객체의 상태를 변경하지 않으며, 함수 외부나 다른 환경과 상호작용하지 않는 순수 함수(pure function)을 사용한다.

**함수형 프로그래밍의 장점1. 간결성**

- 함수형 코드는 명령형(imperative) 코드에 비해 간결하다.
- 함수를 값처럼 활용할 수 있으면 더 강력한 추상화(abstraction)을 할 수 있고 코드 중복을 막을 수 있다.

**함수형 프로그래밍의 장점2. 안전**

- 불변 데이터 구조를 사용하고 순수 함수를 적용하면 다중 스레드 환경에서 같은 데이터를 여러 스레드가 변경할 수 없다.
- 복잡한 동기화가 필요하지 않다.

**함수형 프로그래밍의 장점3. 테스트**

- 부수 효과가 있는 함수는 함수를 실행할 때 필요한 전체 환경을 구성하는 준비 코드가 필요하지만, 순수 함수는 독립적으로 테스트가 가능하다.

코틀린의 함수형 프로그래밍 지원

- 함수 타입을 지원하여 어떤 함수가 다른 함수를 파라미터로 받거나 함수가 새로운 함수를 반환할 수 있다.
- 람다 식을 지원하여 코드 블록을 쉽게 정의하고 여기저기에 전달할 수 있다.
- 데이터 클래스는 불변적인 값 객체를 간편하게 만들 수 있는 구문을 제공한다.
- 코틀린 표준 라이브러리는 객체와 컬렉션을 함수형 스타일로 다룰 수 있는 API를 제공한다.

<br><br>

## 1.3 코틀린 응용

### 1.3.1 코틀린 서버 프로그래밍

**서버**

- 브라우저에 HTML 페이지를 돌려주는 웹 어플리케이션
- 모바일 어플리케이션에게 HTTP를 통해 JSON API를 제공하는 백엔드
- RPC 프로토콜을 통해 서로 통신하는 작은 서비스들로 이뤄진 마이크로서비스

코틀린은 자바 코드와 상호운용이 가능하다. 자바 클래스를 코틀린으로 확장해도 문제가 없으며, 코틀린 클래스 안의 메서드나 필드에 특정 애노테이션을 붙여야 하는 경우도 문제가 없다.

코틀린의 빌더 패턴을 활용하면 간결한 구문을 통해 코틀린이 제공하는 완전한 추상화와 코드 재활용을 지속적으로 누릴 수 있다.

DSL을 활용할 수 있는 다른 예로는 **영속성** 프레임워크가 있다. 익스포즈드 프레임워크는 SQL 데이터베이스의 구조를 기술할 수 있는 읽기 쉬운 DSL을 제공하며, 코틀린 코드만을 사용해 완전한 타입 검사를 지원하면서 데이터베이스 질의를 실행할 수 있다.

<br>

### 1.3.2 코틀린 안드로이드 프로그래밍

리스너를 추가하거나 레이아웃 요소를 필드와 바인딩하는 등의 안드로이드 개발 작업을 훨씬 더 적은 코드로 달성할 수 있다.

코틀린을 사용하면 애플리케이션의 신뢰성이 더 높아진다. 코틀린은 null을 정확히 추적하며 널 포인터로 인해 생기는 문제를 줄여준다.

코틀린 컴파일러가 생성한 바이트코드는 일반적인 자바 코드와 똑같이 효율적으로 실행된다. 

대부분의 코틀린 표준 라이브러리 함수는 인자로 받은 람다 함수를 인라이닝한다. 따라서 람다를 사용해도 새로운 객체가 만들어지지 않기 때문에 가비지 컬레션이 늘어나서 프로그램이 자주 멈추는 일도 없다.

<br><br>

## 1.4 코틀린의 철학

### 1.4.1 실용성

코틀린은 실제 문제를 해결하기 위해 만들어진 실용적인 언어다.

코틀린은 다른 언어가 채택한 검증된 해법과 기능에 의존하기 때문에 복잡도가 줄어들고 이미 알고 있는 개념을 통해 쉽게 배울 수 있다.

특정 프로그래밍 스타일이나 패러다임을 강제하지 않는다.

<br>

### 1.4.2 간결성

언어가 간결하다는 말은 그 언어로 작성된 코드를 읽을 때 의도를 쉽게 파악할 수 있는 구문 구조를 제공하고, 그 의도를 달성하는 방법을 이해할 때 방해가 될 수 있는 부가적인 준비 코드가 적다는 뜻이다.

코틀린은 게터, 세터, 생성자 파라미터를 필드에 대입하기 위한 로직 등 자바에 존재하는 여러 번거로운 준비 코드를 묵시적으로 제공하기 때문에 간결하다.

코틀린은 람다를 지원하기 때문에 작은 코드 블록을 라이브러리 함수에 쉽게 전달할 수 있다. 따라서 일반적인 기능을 캡슐화하고 작업에 따라 달라져야 하는 개별 내용을 사용자가 작성한 코드 안에 남겨둘 수 있다.

코틀린은 연산자 오버로딩(operator overloading)은 지원하지만, 언어가 제공하지 않는 연산자를 프로그래머가 정의할 수 있게 허용하지는 않는다.

<br>

### 1.4.3 안전성

언어가 안전하다는 말은 발생할 수 있는 오류 중 일부 오류를 설계가 원천적으로 방지해준다는 뜻이다. 

컴파일러에게 작동 방식에 대한 정보를 자세히 제공해야 코드와 의도가 일치하는지를 검증할 수 있다. 안전성과 생산성은 트레이드오프 관계가 성립한다.

JVM을 사용하면 메모리 안전성을 보장하고, 버퍼 오버플로를 방지하며, 동적으로 할당한 메모리를 잘못 사용해서 발생하는 문제를 예방할 수 있다.

JVM에서 실행되는 정적 타입 지정 언어로서 코틀린은 타입 안전성을 보장한다. 하지만 자바보다 더 적은 비용으로 타입 안전성을 사용할 수 있다. 대부분의 경우 코틀린 컴파일러가 타입을 자동으로 추론해주기 때문에 직접 타입을 작성할 필요가 없다. (자바는 가장 먼저 타입을 적어줘야 함.)

**컴파일 시점 검사**를 통해 오류를 더 많이 방지해준다. 코틀린은 NullPointerException을 없애기 위해 노력한다. 코틀린의 타입 시스템은 null이 될 수 없는 값을 추적하며, 실행 시점에 NullPointerException이 발생할 수 있는 연산을 사용하는 코드를 금지한다. 이로 인해 추가로 들어가는 비용은 미미하다.

코틀린은 ClassCastException 예외를 방지한다. 어떤 객체를 다른 타입으로 캐스트하기 전에 타입을 미리 검사하지 않으면 ClassCastException이 발생할 수도 있다. **코틀린은 타입 검사와 캐스트가 한 연산자에 의해 이뤄진다.** 어떤 객체의 타입을 검사했고 속한다면, 메서드, 필드를 별도의 캐스트 없이 사용이 가능하다.

<br>

### 1.4.4 상호운용성

라이브러리가 어떤 API를 제공하던 코틀린은 그 API를 활용할 수 있다. 자바 메서드를 호출하거나 상속, 확장, 인터페이스 구현, 애노테이션 사용 모두 가능하다.

자바 코드에서 코틀린 코드를 호출할 때도 자바 클래스나 메서드와 똑같이 사용할 수 있다.

**코틀린은 자체 컬렉션 라이브러리를 제공하지 않고** 자바 표준 라이브러리 클래스에 의졶한다. 다만 코틀린에서 컬렉션을 더 쉽게 활용할 수 있게 몇 가지 기능을 더할 뿐이다.

<br>

## 1.5 코틀린 도구 사용

### 1.5.1 코틀린 코드 컴파일



코틀린 컴파일러로 컴파일한 코드는 코틀린 런타임 라이브러리에 의존한다. 런타임 라이브러리에는 코틀린 자체 표준 라이브러리 클래스와 코틀린에서 자바 API의 기능을 확장한 내용이 들어있다.

<br>

### 1.5.5 온라인 놀이터

[http://try.kotl.in](http://try.kotl.in) 에서 코틀린 코드를 작성하고 실행해볼 수 있다.

<br>
<img src="https://github.com/user-attachments/assets/3272b319-b827-4d52-8e04-bd1b196917a0" width = 300>

<br>
## 1.6 요약

- 코틀린은 정적 타입 지정 언어다. 따라서 코드의 정확성과 성능을 보장하면서 간결하게 유지할 수 있다.
- 코틀린은 객체지향과 함수형 프로그래밍 스타일을 모두 지원한다. 코틀린에서는 일급 시민 함수를 사용하여 수준 높은 추상화가 가능하고, 불변 값 지원을 통해 다중 스레드 애플리케이션 개발과 테스트를 더 쉽게 할 수 있다.
- 코틀린은 실용적이며 안전하고, 간결하며 상호운용성이 좋다. 이는 코틀린이 이미 알려진 해법을 채택하고, NullPointerException과 같이 흔히 발생하는 오류를 방지하며, 읽기 쉽고 간결한 코드를 지원하면서 자바와 통합될 수 있는 언어를 만드는데 초점을 맞췄다는 뜻이다.