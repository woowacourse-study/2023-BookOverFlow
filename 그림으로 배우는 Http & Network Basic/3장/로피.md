# 3장 HTTP 정보는 HTTP 메시지에 있다

## 3.1 HTTP 메시지

**HTTP 메시지**

- HTTP에서 교환하는 정보
- 리퀘스트 측 HTTP 메시지 → 리퀘스트 메시지
- 리스폰스 측 HTTP 메시지 → 리스폰스 메시지
- 복수 행의 데이터로 구성된 텍스트 문자열
    - 메시지 헤더와 메시지 바디로 구성 ← 개행 문자(CR+LF)로 구분
    - 메시지 바디 항상 존재하는 건 아님

      ![IMG_3927.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/cd9a0adf-5568-41ea-9212-6f5f98708d2d/IMG_3927.jpg)


## 3.2 리퀘스트 메시지와 리스폰스 메시지의 구조

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/65caae5c-1325-49e5-8189-cbcd76ba532f/Untitled.png)

- 리퀘스트 라인

리퀘스트에 사용하는 메소드와 리퀘스트 URI와 사용하는 HTTP 버전 포함

- 상태 라인

리스폰스 결과를 나타내는 상태 코드와 설명, 사용하는 HTTP 버전 포함

- 헤더 필드

리퀘스트와 리스폰스의 여러 조건과 속성등을 나타내는 각종 헤더 필드 포함

일반, 리퀘스트, 리스폰스, 엔티티 있음

- 그 외

HTTP의 RFC에 없는 헤더필드(쿠기 등)가 포함

## 3.3 인코딩으로 전송 효율을 높이다

HTTP 데이터 전송시 효율을 높이기 위해 인코딩(변환) 실시

- 다량의 액세스를 효율 좋게 처리
- 컴퓨터에서 인코딩 처리해야해서 리소스 많이 소비

### 3.3.1 메시지 바디와 엔티티 바디의 차이

**메시지**

HTTP 통신의 기본단위로 옥텟(8비트) 시퀀스로 구성되고 통신을 통해서 전송

**엔티티**

리퀘스트랑 리스폰스의 페이로드(전송되는 데이터)로 전송되는 정보로 엔티티 헤더 필드와 엔티티 바디로 구성

HTTP 메시지 바디의 역할

- 리퀘스트랑 리스폰스에 관한 엔티티 바디를 운반
- 기본적으로 메시지 바디와 엔티티 바디는 같지만 전송 코딩 적용 후에는 엔티티 바디 내용이 달라짐

### 3.3.2 압축해서 보내는 콘텐츠 코딩

**콘텐츠 코딩**

- 엔티티에 적용하는 인코딩
    - 엔티티 정보를 유지한 채 압축
    - 콘텐츠 코딩된 엔티티는 수신한 클라이언트 측에서 디코딩
- 주요 콘텐츠 압축
    - gzip(GNU zip), compress(UNIX의 표준 압축), deflate(zlib), identity(인코딩 없음)

### 3.3.3 분해해서 보내는 청크 전송 코딩

**청크 전송 코딩**

- 사이즈가 큰 데이터 전송하는 경우 데이터 분할
- 엔티티 바디를 청크(덩어리)로 분할하는 기능
    - 청크 사이즈를 16진수 사용해서 단락 표시
    - 엔티티 바디 끝에는 0(CR+LF) 기록
- 청코 전송 코딩된 엔티티 바디는 수신한 클라이언트 측에서 원래의 엔티티 바디로 디코딩

## 3.4 여러 데이터를 보내는 멀티파트

MIME(Multipurpose Internet Mail Extensions: 다목적 인터넷 메일 확장 사양)

- 이미지 등의 바이너리 데이터를 아스키 문자열에 인코딩하는 방법과 데이터 종류를 나타내는 방법 규정
- MIME 확장 사양에 있는 멀티파트라고 하는 여러 다른 종류의 데이터 수용하는 방법 사용
- HTTP도 멀티파트에 대응
    - 메시지 바디 내부에 엔티티를 여러 개 포함 시켜 보낼 수 있고
    - 이미지나 텍스트 파일 업로드

Multipart

- multipart/form-data
    - Web 폼으로부터 파일 업로드에 사용
- multipart/byteranges
    - 상태 코드 206(Particial Content) 리스폰스 메시지가 복수 범위의 내용을 포함하는 때에 사용
- HTTP 메시지로 멀티파트 사용시 → Content-type 헤더 필드 사용
- 멀티파트 가각의 엔티티 구분 위해 “boundary” 문자열 사용

## 3.5 일부분만 받는 레인지 리퀘스트

리줌 기능

- 예전에는 대용량의 이미지와 데이터 다운 힘들었음 → 커넥션 끊어지면 처음부터 다운로드 해야했기 때문
- 이전에 다운로드를 한 곳에서부터 다운로드 재개
- 엔티티의 범위 지정 필요
- 범위 지정하여 리퀘스트 하는 것 → 레인지 리퀘스트

레인지 리퀘스트

- 사용 시 전 10,000 바이트 정도 크기의 리소스에서 5,001 ~ 10,000 바이트의 범위 만을 리퀘스트 가능
- Range 헤더 필드를 사용해서 리소스의 바이트 레인지 지정

![IMG_3928.jpg](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/7d9a6f88-cfe4-4995-aa87-70a9c9988589/IMG_3928.jpg)

레인지 리퀘스트에 대한 리스폰스는 상태 코드 206 Partial Content라는 리스폰스 메시지 되돌아옴.

복수 범위의 레인지 리퀘스트에 대한 리스폰스는 multipart/byteranges로 리스폰스 되돌아옴

서버가 레인지 리퀘스트 지원하지 않는 경우 상태 코드 200 OK라는 리스폰스 메시지로 완전한 엔티티로 되돌아옴.

### 3.6 최적의 콘텐츠를 돌려주는 콘텐츠 네고시에이션

**콘텐츠 네고시에이션**

- 클라이언트와 서버가 제공하는 리소싀의 내용에 대해서 교섭하는 것
- 클라이언트에 더욱 적합한 리소스 제공하기 위한 구조
- 제공하는 리소스를 언어와 문자 세트, 인코딩 방식 등을 기준으로 판단
- 판단 기준 - 리퀘스트 메시지에 포함된 리퀘스트 헤더 필드
    - Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Language
- 종류
    - 서버 구동형 네고시에이션
        - 서버 측에서 콘텐츠 네고시에이션을 하는 방식
        - 서버 측에서 리퀘스트 헤더 필드의 정보를 참고해서 자동으로 처리
        - 브라우저가 보내는 정보를 근거로 하기 때문에 유저에게 정말로 적절한 것이 선택되었다고 할 수 없음
    - 에이전트 구동형 네고시에이션
        - 클라이언트 측에서 콘텐츠 네고시에이션을 하는 방식
        - 브라우저에 표시된 선택지 중에서 유저가 수동으로 선택
    - 트랜스페어런트 네고시에이션
        - 서버 구동형과 에이전트 구동형을 혼합한 것
        - 서버와 클라이언트가 각각 콘텐츠 네고시에이션을 하는 방식
