# 3장. Http 정보는 Http 메시지에 있다.

## Http 메시지

- Http에서 교환하는 정보
- 복수 행의 데이터로 구성된 테스트 문자열
- 메시지 헤더 + 메시지 바디(nullable) 로 구성
- 메시지 헤더 : 서버와 클라이언트가 꼭 처리해야하는 리퀘스트와 리스폰스 내용과 속성 등
- 메시지 바디 : 꼭 전송되는 데이터 그 자체

</br>

## 리퀘스트 메시지와 리스폰스 메시지의 구조

**리퀘스트 메시지** : 리퀘스트 라인 + 리퀘스트 헤더 필드 + 일반 헤더 필드 + 엔티티 헤더 필드

**리스폰스 메시지** : 상태 라인 + 리스폰스 헤더 필드 + 일반 헤더 필드 + 엔티티 헤더 필드 

- 리퀘스트 라인 : 리퀘스트에 사용하는 메소드 + 리퀘스트 URI + 사용하는 Http 버전 포함
- 상태 라인 : 리스폰스 결과를 나타내는 상태 코드 + 설명 + 사용하는 HTTP 버전
- 헤더 필드 : 리퀘스트와 리스폰스의 여러 조건과 속성 등을 나타내는 각종 헤더 필드
    - 종류 : 일반 헤더 필드, 리퀘스트 헤더 필드, 리스폰스 헤더필드, 엔티티 헤더 필드
    
</br>

## 인코딩으로 전송 효율을 높이다.

Http로 데이터를 전송할 경우 그대로 전송할 수도 있지만 전송할 때에 인코딩(변환)을 실시함으로써 전송 효율을 높일 수 있다. 

전송 시 인코딩을 하면 다량의 액세스를 효율 좋게 처리할 수 있다. 인코딩 처리를 컴퓨터에서 하기 때문에 CPU 등의 리소스는 보다 많이 소비하게 된다. 

</br>

### 메시지 바디와 엔티티 바디의 차이

**메시지** 

Http 통신의 기본 단위로 옥텟 시퀀스 (Octet sequence)로 구성되고 통신을 통해서 전송

**엔티티** 

리퀘스트랑 리스폰스의 페이로드(payload)로 전송되는 정보로 엔티티 헤더 필드와 엔티티 바디로 이루어져 있다. 

Http 메시지 바디의 역할은 리퀘스트랑 리스폰스에 관한 엔티티 바디를 운반하는 일이다.

기본적으로 메시지 바디와 엔티티 바디는 같지만 전송 코딩이 적용된 경우에는 엔티티 바디의 내용이 변화하기 떄문에 메시지 바디와 달라진다. 

</br>

### 압축해서 보내는 콘텐츠 코딩

Content coding : 엔티티에 적용하는 인코딩. 엔티티 정보를 유지한채로 압축. 

종류 : gzip(GNU zip), compress(Unix 표준 압축), deflate(zlib), identity(인코딩 없음)

</br>

### 분해해서 보내는 청크 전송 코딩

Http 통신에서는 리퀘스트했었던 리소스 전부에서 엔티티 바디의 전송이 완료되지 않으면 브라우저에 표시되지 않는다. 사이즈가 큰 데이터를 전송하는 경우에 데이터를 분할해서 조금씩 표현 가능하다. → 이렇게 엔티티 바디를 분할하는 기능이 Chuncked transfer Coding

**방법**

엔티티 바디를 chunk로 분해. 청크 사이즈를 16진수로 사용해서 단락을 표시하고 엔티티 바디 끝에는 “0(CR+LF)”를 기록. 

→ 수신한 클라이언트 측에서는 원래의 엔티티 바디로 디코딩

</br>

## 여러 데이터를 보내는 멀티 파트

### MIME (Multipurpose Internet Main Extensions)

다목적 인터넷 메일 확장 사양

MIME으로 불리는 메일로 텍스트나 영상, 이미지와 같은 여러 다른 데이터를 다루기 위한 기능을 사용하고 있다. MIME는 이미지 등의 바이너리 데이터를 아스키 문자열에 인코딩하는 방법과 데이터 종류를 나타내는 방법 등을 규정하고 있다. 이 MIME의 확장 사양에 있는 멀티파트는 여러 다른 종류의 데이터를 수용하는 방법을 사용한다. 

- multipart/form-data : Web 폼으로부터 파일 업로드에 사용됩니다.
- multipart/byteranges : 상태코드 206(Partitial Content) 리스폰스 메시지가 복수 범위의 내용을 포함하는 때에 사용합니다.

Http 메시지로 멀티파트를 사용할 때에는 Content-type 헤더 필드를 사용한다. 

멀티파트 각각의 엔티티를 구분하기 위해 “boundary” 문자열을 사용합니다. 

</br>

## 일부분만 받은 레인지 리퀘스트

resume: 커넥션이 끊어지면 마지막 지점에서부터 재개 가능

이 기능을 실현하기 위해서는 엔티티의 범위를 지정해서 다운로드를 할 필요가 있다. 이와 같이 범위를 지정하여 리퀘스트 하는 것을 Range Request라고 한다. 

Range Request에 대한 리스폰스는 상태 코드 206 Partitail Content라는 리스폰스 메시지가 되돌아온다. 또한, 복수 범위의 Range Request에 대한 리스폰스는 multipart/byteranges로 리스폰스가 되어 돌아온다. 서버가 range request에 지원하지 않는 경우에는 상태 코드 200 OK라는 리스폰스 메시지로 완전한 엔티티가 되돌아온다. 

</br>

## 최적의 콘텐츠를 돌려주는 콘텐츠 네고시에이션

같은 콘텐츠(내용)이지만 여러 개의 페이지를 지닌 웹 페이지가 있다. 이런 구조를 Content Negotitation이라고 부른다. 예) 구글 → 한글 페이지, 영어 페이지

콘텐츠 네고시에이션이란 클라이언트와 서버가 제공하는 리소스의 내용에 대해서 교섭하는 것이다. 

콘텐츠 네고시에이션은 제공하는 리소스를 언어와 문제 세트, 인코딩 방식 등을 기준으로 판단한다. 

→ 판단 기준 : 리퀘스트 메시지에 포함된 다음과 같은 리퀘스트 헤어 필드

: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Language

</br>

### 서버 구동형 네고시에이션(Server-driven Negotiation)

서버 측에서 콘텐츠 네코시에이션을 하는 방식. 서버 측에서 리퀘스트 헤더 필드의 정보를 참고해서 자동적으로 처리를 한다. 단지, 브라우저가 보내는 정보를 근거로 하기 때문에 유저에게 정말 적절한 것이 선택되었다고 할 수 없다. 

</br>

### 에이전트 구동형 네고시에이션 (Agent-driven Negoation)

클라이언트 측에서 콘텐츠 네고에이션을 하는 방식. 브라우저에 표시된 선택지 중 유저가 수동으로 선택. 

예) OS의 종류나 브라우저의 종류 등에 의해 PC용과 스마트폰 용의 웹페이지를 자동으로 전환

</br>

### 트랜스페어런트 네고시에이션 (Transparent Negotiation)

서버 구동형과 에이전트 구동형을 혼합한 것을 ㅗ서버와 클라이언트가 각각 콘텐츠 네고시에이션을 하는 방식
