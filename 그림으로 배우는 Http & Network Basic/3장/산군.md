# 3장(HTTP 정보는 HTTP 메시지에 있다)

## 3.1 HTTP 메시지

- HTTP에서 교환하는 정보를 HTTP 메시지라고 부른다.
    - 리퀘스트 메시지/ 리스폰스 메시지
- HTTP 메시지는 복수 행(개행 문자는 CR+LF)의 데이터로 구성된 텍스트 문자열이다.
    - 메시지 헤더와 메시지 바디로 구성되어 있고, 개행 문자로 구분한다.

## 3.2 리퀘스트 메시지와 리스폰스 메시지의 구조

![image](https://github.com/woowacourse-study/2023-cs-study/assets/81347125/9cf7a4e7-de3d-46c0-a236-86bcce65d626)


리퀘스트 라인(요청 라인)

- 리퀘스트에 사용하는 메서드와 리퀘스트 URI와 사용하는 HTTP 버전이 포함된다.

리스폰스 라인(상태 라인)

- 리스폰스 결과를 나타내는 상태 코드와 설명, 사용하는 HTTP 버전이 포함된다.

헤더 필드

- 리퀘스트와 리스폰스의 여러 조건과 속성 등을 나타내는 각종 헤더 필드가 포함된다.
- 일반 헤더필드, 리퀘스트 헤더필드, 리스폰스 헤더필드, 엔티티 헤더 필드 등 4종류가 있다.

그 외

- HTTP의 RFC에는 없는 헤더 필드(쿠키 등)가 포함된다.

## 3.3 인코딩으로 전송 효율을 높이다

- HTTP로 데이터를 전송할 경우, 그대로 전송해도 되지만 인코딩을 통해 전송 효율을 높일 수 있다.
    - 단 컴퓨터에서 인코딩 처리를 해야하기 때문에 CPU 등의 리소스는 보다 많이 소비한다.

### 3.3.1 메시지 바디와 엔티티 바디의 차이

메시지

- HTTP 통신의 기본 단위로 옥텟 시퀀스(Octet sequence, 8비트)로 구성되고 통신을 통해서 전송한다.

엔티티

- 리퀘스트랑 리스폰스의 페이로드(payload, 부가물)로 전송되는 정보로 엔티티 헤더 필드와 엔티티 바디로 구성된다.

HTTP 메시지 바디의 역할은 리퀘스트랑 리스폰스에 관한 엔티티 바디를 운반하는 일이다.

- 기본적으로 메시지 바디와 엔티티 바디는 같지만 전송 코딩이 적용된 경우엔 엔티티 바디의 내용이 변화하기에 서로 달라진다.
    - 메시지바디(= 엔티티바디)를 그대로 전송해도 되지만, 인코딩을 통해 메시지 바디는 변환된 엔티티바디를 운반한다.

### 3.3.2 압축해서 보내는 컨텐츠 코딩

메일에 파일을 첨부해서 보내는 경우 용량을 줄이기 위해 파일을 압축한다.

- HTTP에는 이와 같은 일이 가능한 **컨텐츠 코딩**이라고 불리는 기능이 있다.
- 컨텐츠 코딩은 엔티티에 적용하는 인코딩을 뜻하며, 정보는 유지한 채로 압축한다.
    - 수신한 클라이언트 측에서 디코딩한다.
    - 주요 컨텐츠 압축에는 gzip, compressm deflate, identity

### 3.3.3 분해해서 보내는 청크 전송 코딩

HTTP 통신에서는 리퀘스트했었던 리소스 전부에서 엔티티 바디의 전송이 완료되지 않으면 브라우저에 표시되지 않는다.

- 사이즈가 큰 데이터를 전송하는 경우에는 데이터를 조금씩 분할해서 표시한다.
- 이렇게 엔티티 바디를 쪼개는 기능을 **청크 전송 코딩(Chunked transfer Coding)**이라고 한다.
    - 엔티티 바디를 청크로 분해한다.
    - 청크를 16진수로 사용해서 단락을 표시하고 엔티티 바디 끝에는 “0(CR+LF)”를 기록해둔다.
    - 클라이언트는 이를 디코딩한다.

## 3.4 여러 데이터를 보내는 멀티파트

MIME(Mulipurpose Internet Mail Extensions, 다목적 인터넷 메일 확장 사양)

- 메일로 텍스트나 영상, 이미지와 같은 여러 다른 데이터를 다루기 위한 기능으로 사용한다.
- 이미지 등의 바이너리 데이터를 아스키 문자열에 인코딩하는 방법과 데이터 종류를 나타내는 방법 등을 규정한다.
    - 이 MIME의 확장 사양에 있는 **멀티파트**라고 하는 여러 다른 종류의 데이터를 수용하는 방법을 사용하고 있는 것이다.
- HTTP 또한 멀티파트에 대응하고 있어 하나의 메시지 바디 내부에 엔티티를 여러 개 포함시켜 보낼 수 있다.

multipart/form-data

- web 폼으로부터 파일 업로드에 사용한다.

multipart/byteranges

- 상태 코드 206(Paritial Content) 리스폰스 메시지가 복수 범위의 내용을 포함하는 때에 사용한다.

HTTP 메시지로 멀티파트를 사용할 때에는 Content-type 헤더 필드를 사용한다.

- 멀티파트 각각의 엔티티를 구분하기 위해 ‘boundary’ 문자열을 사용한다.
- 각 엔티티의 선두에는 ‘boundary’ 문자열 앞에 ‘--’를 삽입한다.
- 멀티파트의 마지막에는 그 문자열의 마지막 부분에 ‘--’를 삽입해서 마무리한다.
- 멀티파트는 파트마다 헤더 필드가 포함된다.
    - 파트의 중간에 멀티파트를 만드는 것과 같이 파트를 내부에 포함할 수도 있다.

## 3.5 일부분만 받는 레인지 리퀘스트

예전에는 대용량 데이터를 다운로드하기 어려웠다.

- 커넥션이 종료되면, 다시 다운로드를 받아야했기 때문이다.
- 이를 위해 일반적인 **리줌**이라는 기능이 필요하게 되었다.
    - 이전에 다운로드를 한 곳에서부터 다운로드를 재개할 수 있다.
    - 엔티티의 범위를 지정해 다운로드를 해야 가능하다.
    - 이를 **레인지 리퀘스트(range request)**라고 한다.

레인지 리퀘스트

- 전체 10,000 바이트 정도 크기의 리소스에서 5,001 - 10,000 바이트의 범위(바이트 레인지)만을 리퀘스트 할 수 있다.
    - ex) Range: bytes = 5001-10000, 5001- , 3000, 5000-7000 …
- 레인지 리퀘스트에 대한 리스폰스는 상태 코드 206이 돌아오며 복수 범위의 리스폰스는 multipart/byteranges로 리스폰스가 돌아온다.
    - 서버가 레인지 리퀘스트를 지원하지 않는 경우, 200 리스폰스로 완전한 엔티티가 되돌아온다.

## 3.6 최적의 컨텐츠를 돌려주는 컨텐츠 네고시에이션

- 같은 내용이지만 여러 개의 페이지를 지닌 웹 페이지가 있다.
    - ex) 언어가 다른경우
- 서로 다른 언어를 주로 사용하는 브라우저가 같은 URI에 엑세스할 때 서로 다른 웹 페이지를 표시한다.
    - 이와 같은 구조를 **컨텐츠 네고시에이션(Content Negotiation)**이라고 한다.

컨텐츠 네고시에이션

- 클라이언트와 서버가 제공하는 리소스의 내용에 대해 교섭하는 것이다.
    - 클라이언트에 더욱 적합한 리소스를 제공하기 위한 구조이다.
- 리퀘스트 메시지에 포함된 다음과 같은 리퀘스트 헤더필드로 판단한다.
    - Accept
    - Accept-Charest
    - Accept-Encoding
    - Accept-Launguage
    - Content-Language

서버 구동형 네고시에이션(Server-driven Negitiation)

- 서버 측에서 컨텐츠 네고시에이션을 하는 방식이다.
- 서버 측에서 리퀘스트 헤더 필드의 정보를 참고해 자동으로 처리한다.
    - 브라우저가 보내는 정보를 근거로 하기에 유저에게 적절한 것이 선택되었다고는 할 수 없다.

에이전트 구동형 네고시에이션(Agent-driven Negotiation)

- 클라이언트 측에서 컨텐츠 네고시에이션을 하는 방식이다.
- 브라우저에서 유저가 직접 선택한다.
- 웹 페이지에서 자동으로 이것을 정하는 것도 있다.
    - ex) OS 종류나 PC, 스마트폰 용의 웹페이지 자동 전환 등…

트랜스페어런트 네고시에이션(Transparent Negotiation) 

- 서버 구동형과 에이전트 구동형을 혼합한 것으로 각각 컨텐츠 네고시에이션을 하는 방식이다.
