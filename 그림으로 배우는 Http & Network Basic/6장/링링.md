# 6장. HTTP 헤더

## HTTP 메시지 헤더

HTTP 프로토콜의 리퀘스트와 리스폰스에는 반드시 헤더가 포함되어 있다.

메시지 헤더에는 클라이언트나 서버가 리퀘스트나 리퀘스트나 리스폰스를 처리하기 위한 정보가 들어있다.

</br>

**리퀘스트의 HTTP 메시지**

메소드, URI, HTTP 버전, HTTP 헤더 필드 등으로 구성

**리스폰스의 HTTP 메시지**

HTTP 메시지, HTTP 버전, 상태 코드(코드와 설명), HTTP 헤더 필드 등으로 구성

이러한 요소 중에서 가장 다양한 정보를 가지고 있는 것이 HTTP 헤더 필드이다. 

헤더 필드는 리퀘스트와 리스폰스 양쪽 모두 존재하는데 HTTP 메시지에 관한 정보를 가지고 있다.

</br>

## HTTP 헤더 필드

### HTTP 헤더 필드는 중요한 정보를 전달한다.

헤더필드는 중요한 정보를 전달하는 역할을 하며, 메시지 바디의 크기나 사용하고 있는 언어, 인증 정보 등을 브라우저나 서버에 제공하기 위해 사용한다.

</br>

### HTTP 헤더 필드의 구조

```kotlin
헤더 필드 명 : 필드 값
```

</br>

### 4종류의 HTTP 헤더 필드

**일반적인 헤더 필드 (General Header Fields)**

리퀘스트 메시지와 리스폰스 메시지 둘 다 사용되는 헤더

</br>

**리퀘스트 헤더 필드 (Request Header Fields)**

클라이언트 측에서 서버 측으로 송신된 리퀘스트 메시지에 사용되는 헤더

리퀘스트의 부가적 정보와 클라이언트의 정보, 리스폰스의 콘텐츠에 관한 우선 순위들을 부가한다.

</br>

**리스폰스 헤더 필드 (Response Header Fields)**

서버 측에서 클라이언트 측으로 송신한 리스폰스 메시지에 사용되는 헤더

리스폰스의 정보와 서버의 정보, 클라이언트의 추가 정보 요구 등을 부가한다.

</br>

**엔티티 헤더 필드 (Entity Header Fields)**

리퀘스트 메시지와 리스폰스 메시지에 포함된 엔티티에 사용되는 헤더

콘텐츠 갱신 시간 등의 엔티티에 관한 정보를 부가한다.

</br>

### HTTP/1.1 헤더 필드 일람

**일반 헤더 필드**

| 헤더 필드 명 | 설명 |
| --- | --- |
| Cache-Control | 캐싱 동작 지정 |
| Connection | Hop-by-hop 헤더, 커넥션 관리 |
| Date | 생성 날짜 |
| Pragma | 메시지 제어 |
| Trailer | 메시지 끝에 있는 헤더의 일람 |
| Transfer-Encoding | 메시지 바디의 전송 코딩 형식 지정 |
| Upgrade | 다른 프로토콜에 업그레이드 |
| Via | 프록시 서버에 관한 정보 |
| Warning | 에러 통지 |

</br>

**리퀘스트 헤더 필드**

| 헤더 필드 명 | 설명 |
| --- | --- |
| Accept | 유저 에이전트가 처리 가능한 미디어 타입 |
| Accept-Charset | 문자셋 우선순위 |
| Accept-Encoding | 콘텐츠 인코딩 우선순위 |
| Accept-Language | 언어(자연어) 우선순위 |
| Authorization | 웹 인증을 위한 정보 |
| Expect | 서버에 대한 특정 동작의 기대 |
| From | 유저의 메일 주소 |
| Host | 요구된 리소스의 호스트 |
| If-Match | 엔티티 태그의 비교 |
| If-Modified-Since | 리소스의 갱신 시간 비교 |
| If-None-Match | 엔티티 태그의 비교 (If-Match의 반대) |
| If-Range | 리소스가 갱신되지 않는 경우에 엔티티의 바이트 범위의 요구를 송신 |
| If-Unmodified-Since | 리소스의 갱신시간 비교 (If-Modified Since의 반대) |
| Max-Forwards | 최대 전송 홉 수 |
| Proxy-Authorization | 프록시 서버의 클라이언트 인증을 위한 정보 |
| Range | 엔티티 바이트 범위 요구 |
| Referer | 리퀘스트 중의 URI를 취득하는 곳 |
| TE | 전송 인코딩의 우선 순위 |
| User-Agent | HTTP 클라이언트의 정보 |

</br>

**리스폰스 헤더 필드**

| 헤더 필드 명 | 설명 |
| --- | --- |
| Accept-Ranges | 바이트 단위의 요구를 수신할 수 있는지 없는지 여부 |
| Age | 리소스의 지정 경과 시간 |
| Etag | 리소스를 특정하기 위한 정보 |
| Location | 클라이언트를 지정한 URI에 리다이렉트 |
| Rroxy-Authenticate | 프록시 서버의 클아이언트 인증을 위한 정보 |
| Retry-After | 리퀘스트 재시행의 타이밍 요구 |
| Server | HTTP 서버 정보 |
| Vary | 프록시 서버에 대한 캐시 관리 정보 |
| WWW-Authenticate | 서버의 클라이언트 인증을 위한 정보 |

</br>

**엔티티 헤더 필드**

| 헤더 필드 명 | 설명 |
| --- | --- |
| Allow | 리소스가 제공하는 HTTP 메소드 |
| Content-Encoding | 엔티티 바디에 적용되는 콘텐츠 인코딩 |
| Content-Language | 엔티티의 자연어 |
| Content-Length | 엔티티 바디의 사이즈 (단위: 바이트) |
| Content-Location | 리소스에 대응하는 대체 URI |
| Content-MD5 | 엔티티 바디의 메시지 다이제스트 |
| Content-Range | 엔티티 바디의 범위 위치 |
| Content-Type | 엔티티 바디의 미디어 타입 |
| Expires | 엔티티 바디의 유효기간 날짜 |
| Last-Modified | 리소스의 최종 갱신 날짜 |

</br>

### HTTP/1.1 이외의 헤더 필드

HTTP에서 교환되는 HTTP 헤더 필드가 RFC2616에서 정의된, 위의 47가지만 있는 것은 아니다.

비표준 헤더 필드는 RFC4299 HTTP Header Field Registrations에 정리되어 있다.

</br>

### End-to-end 헤더와 Hop-by-hop

HTTP 헤더 필드는 캐시와 비캐시 프록시의 동작을 정의하기 위해 두 가지 카테고리로 분류

**End-to-end 헤더**

리퀘스트나 리스폰스의 최종 수신자에게 전송된다.

캐시에서 구축된 리스폰스 중 보존되야 하고, 다시 전송되지 않으면 안되도록 되어 있다.

> 출발지부터 목적지까지 전체 통신 경로를 따라가는 헤더
> 
> 
> 이러한 헤더는 출발지에서 목적지로 이동하는 동안 중간 노드들에서 변경되지 않는다. 즉, 헤더 정보는 최종 목적지까지 변하지 않고 유지된다.
> 

</br>

**Hop-to-hop 헤더**

한번 전송에 대해서만 유효하고 캐시와 프로시에 의해서 전송되지 않는 것도 있다. 

HTTP/1.1과 그 이후에서 사용되는  Hop-to-hop 헤더는 Connection 헤더 필드에 열거해야 한다.

> 데이터가 네트워크 경로를 따라 갈 때마다 각 노드에서 처리되고 제거되는 헤더
> 
> 
> 이 헤더는 데이터 패킷이 네트워크를 통과할 때마다 각각의 라우터나 중간 노드에서만 유효하다. 즉, 데이터가 한 노드에서 다음 노드로 이동할 때마다 해당 hop-by-hop 헤더는 제거되거나 변경될 수 있다.
> 

아래의 8개 헤더필드 이외에는 모두 End-by-end로 분류된다.

Connection, Keep-Alive, Proxy-Authenticate, Proxy-Authorization, Trailer, TE, Transger-Encoding, Upgrade

</br>

## HTTP/1.1 일반 헤더 필드

일반 헤더 필드 : 리퀘스트 메시지와 리스폰스 메시지 양쪽에서 사용되는 헤더

</br>

### Cache-Control

Cache-Control 헤더는 디렉티브로 불리는 명령을 사용하여 캐싱 동작을 지정한다. 

지정한 디렉티브에는 파라미터가 있는 것과 없는 것도 있으며 
여러개의 디렉티브를 지정하는 경우에는 `,` 로 구분한다. 

```
Cache-Control: private, ma-age=0, no-cache
```

</br>

**Cache-Control 디렉티브 알람**

- 캐시 리퀘스트 디렉티브

| 디렉티브 | 파라미터 | 설명 |
| --- | --- | --- |
| no-cache | 없음 | 오리진 서버에 강제적인 재검증 |
| no-store | 없음 | 캐시는 리퀘스트, 리스폰스의 일부분을 보존해서는 안됨 |
| max-age = [초] | 필수 | 리스폰스의 최대 age 값 |
| max-state( = [초]) | 생략 가능 | 기한이 지난 리스폰스를 수신 |
| min-fresh = [초] | 필수 | 지정한 시간 이후에 변경된 리스폰스를 보냄 |
| no-transform | 없음 | 프록시는 미디어 타입을 변환해서는 안됨 |
| only-if-cached | 없음 | 캐시에서 리소스를 취득 |
| cache-extension | - | 새로운 디렉티브를 위해서 토큰 |

</br>

- 캐시 리스폰스 디렉티브

| 디렉티브 | 파라미터 | 설명 |
| --- | --- | --- |
| public | 없음 | 어딘가에 리스폰스 캐시가 가능 |
| private | 생략 가능 | 특정 유저에 대해서만 리스폰스 |
| no-cache | 생략 가능 | 유효성의 재확인 없이는 캐시는 사용해서는 안됨 |
| no-store | 없음 | 캐시는 리퀘스트, 리스폰스의 일부분을 보존해서는 안됨 |
| no-tranform | 없음 |  프록시는 미디어 타입을 변경해서는 안됨 |
|  must-revalidate | 없음 | 캐시 가능하지만 오리진 서버에 리소스의 재확인을 요구 |
| procy-revalidate | 없음 | 중간 캐시 서버에 대해서 캐시했던 리스폰스의 유효성의 재확인을 요구 |
| max-age = [초] | 필수 | 리스폰스의 최애 Age값 |
| s-maxage = [초] | 필수 | 공유 캐시 서버의 리스폰스 최대 Age 값 |
| cache-extension | - | 새로운 디렉티브를 위한 토큰 |

</br>

**캐시가 가능한지 여부를 나타내는 디렉티브**

1. public 디렉티브

```
Cache-control: public
```

Public 디렉티브가 사용되는 경우, 다른 유저에게도 돌려줄 수 있는 캐시를 해도 좋다는 것을 명시적으로 나타낸다. 

</br>

2. private 디렉티브

```
Cache-control: private
```

Private 디렉티브가 사용되는 경우, 리스폰스는 특정 유저만을 대상으로 함을 나타낸다. public 디렉티브와 기능이 반대. 

캐시 서버는 특정 유저를 위해서 리소스를 캐시할 수 있지만, 다른 유저로부터 같은 리퀘스트가 온다고 하더라도 그 캐시를 반환하지 않도록 한다.

</br>

3. no-cache 디렉티브

```
Cache-control: no-cache
```

캐시로부터 오래된 리소스가 반환되는 것을 막기 위해 사용한다.

클라이언트의 리퀘스트로 no-cache 디렉티브가 사용된 경우, 캐시된 리스폰스를 클라이언트가 받아들이지 않음을 나타낸다. 즉, 중간 캐시 서버가 오리진 서버까지 리퀘스트를 전송해야함.

서버의 리스폰스에 no-cache 디렉티브가 사용된 경우, 캐시 서버는 리소스를 저장할 수 없다. 오리진 서버는 캐시 서버가 이후의 리퀘스트에서 리소스의 유효성을 재확인하지 않고는 그 리스폰스를 사용하지 못하게 한다. 

```
Cache-Control: no-cache=Location
```

서버의 리스폰스로 no-cache의 필드 값에 헤더 필드 명이 지정된 경우에는 이 지정된 헤더 필드만 캐시할 수 없다. 즉, 지정된 헤더 필드 이외에는 캐시 하는 것이 가능하다. (리스폰스 디렉티브만 가능)

</br>

**캐시로 보존 가능한 것을 제어하는 디렉티브**

1. no-store 디렉티브

```
Cache-Control: no-store
```

리퀘스트(그와 대응되는 리스폰스) 혹은 리스폰스에 기밀 정보가 포함되어 있음을 나타낸다. 

→ 캐시는 리퀘스트, 리스폰스의 일부분을 로컬 스토리지에 보존해서는 안되도록 지정한다.

</br>

**캐시 기한이나 검증을 지정하는 디렉티브**

1. s-maxage 디렉티브

```
Cache-Control: s-maxage=604800 (단위 : 초)
```

이 디렉티브의 기능은 max-age 디렉티브와 동일한데 다른 점은 여러 유저가 이용할 수 있는 공유 캐시 서버에만 적용이 된다는 점이다. 즉, 같은 유저에 반복해서 리스폰스를 반환하는 캐시 서버는 무효한 디렉티브이다. 또한, 이 디렉티브를 사용하면 Expires 헤더 필드와 max-age 디렉티브는 무시된다.

</br>

2. max-age 디렉티브

```
Cache-Control: max-age=604800 (단위 : 초)
```

클라이언트의 리퀘스트로 max-age 디렉티브가 사용되었다면 지정되었던 값보다 새로운 경우에는 캐시되었던 리소스를 받아들일 수 있다. 또한, 지정한 값이 0이면 캐시 서버는 리퀘스트를 항상 오리진 서버에 넘길 필요가 있다.

서버의 리스폰스에서 이 디렉티브가 사용되는 경우, 캐시 서버가 유효성의 재확인을 하지 않고 리소스를 캐시에 보존해두는 최대 시간을 나타낸다. 

HTTP/1.1 캐시 서버는 동시에 Expires 헤더 필드가 달린 경우에는 max-age 디렉티브의 지정을 우선하고 Exprires 헤더 필드를 무시한다. HTTP/1.0 캐시 서버는 반대로 max-age 디렉티브가 무시된다.

</br>

3. min-fresh 디렉티브

```
Cache-Control: min-fresh=60 (단위 : 초)
```

min-fresh 디렉티브가 사용되는 경우, 캐시된 리소스가 적어도 지정된 시간은 최신 상태의 것을 반환하도록 캐시 서버에 요구한다. 

예) 60초로 지정되어 있는 경우에는 60초 이내에 유효 기한이 끝나는 리소스를 리스폰스로 반환하면 안된다.

</br>

**뭐징**

1. max-stale 디렉티브

```
Cache-Control: max-stale=36000 (단위 : 초)
```

max-stale 디렉티브가 사용되는 경우, 캐시된 리소스의 유효기간이 끝났더라도 받아들일 수 있음

디렉티브에 값이 지정되어 있지 않은 경우는 클라이언트는 아무리 시간이 경과했더라도 리스폰스를 받아들인다. 값이 지정된 경우에는 유효기간이 지난 후로부터 지정 시간 내라면 받아 들인다는 뜻을 서버에 전달한다. 

</br>

2. only-if-cached 디렉티브

```
Cache-Control: only-if-cached
```

클라이언트는 캐시 서버에 대해서 목적한 리소스가 로컬 캐시에 있는 경우만 리스폰스를 반환하도록 요구한다. 즉, 캐시 서버에서 리스폰스의 리로드와 유효성을 재확인하지 않도록 요구한다. 캐시 서버가 로컬 개시로부터 응답할 수 없는 경우에는 “504 Gateway Timeout” 상태를 반환한다.

</br>

3. must-revalidate 디렉티브

```
Cache-Control: must-revalidate
```

리스폰스의 캐시가 현재도 유효한지 아닌지의 여부를 오리진 서버에 조회를 요구한다.

프록시가 오리진 서버에 도달할 수 없고, 리소스를 다시 요구할 수 없는 경우에는 캐시는 클라이언트에 504를 반환한다. 이 디렉티브를 사용하면, 리퀘스트에서 max-stale 디렉티브를 사용해도 무시.

</br>

4. proxy-revalidate 디렉티브

```
Cache-Control: proxy-revalidate
```

모든 캐시 서버에 대해서 이후의 리퀘스트로 해당 리스폰스를 반환할 때는 반드시 유효성 재확인을 하도록 요구한다.

</br>

5. no-transform 디렉티브

```
Cache-Control: no-transform
```

리퀘스트와 리스폰스의 어느 쪽에 있어서도 캐시가 엔티티 바디의 미디어 타입을 변경하지 않도록 지정한다. 이렇게 해서 캐시 서버 등에 의해서 이미지가 압축되는 것을 방지한다.

</br>

**Cache-Control 확장**

1. cache-extension 토큰

```
Cache-Control: private, community="UCI"
```

Cache-Control 헤더 필드는 cache-extension 토큰을 사용하여 디렉티브를 확장할 수 있다.

extension tokens는 이해할 수 있는 캐시 서버에 대해서만 의미가 있다.

</br>

## Connection

Connection 헤더 필드는 두가지 역할을 한다.

- 프록시에 더 이상 전송하지 않는 헤더 필드 지정

```
Connection: 더 이상 전송하지 않는 헤더 필더 명
```

</br>

- 지속적 접속 관리

```
Connection: close
```

HTTP/1.1에서는 지속적 접속이 디폴트로 되어 있다. 그래서 리퀘스트를 송신했던 클라이언트는 접속이 계속 유지되면서 추가 리퀘스트를 송신하도록 한다. 서버 측에서 명시적으로 접속을 끊고 싶을 경우에는 Connection 헤더 필드에 Close라고 지정한다.

```
Connection: Keep-Alive
```

오래된 버전의 HTTP에서 지속적 접속을 하고 싶은 경우에는 Connection 헤더 필드에 Keep-Alive라고 지정해야 한다. 

</br>

### Date

Date 헤더 필드는 HTTP 메시지를 생성한 날짜를 나타낸다.

</br>

### Pragma

Pragma 헤더 필드는 HTTP/1.1 보다 오래된 버전의 흔적으로 HTTP/1.0 와의 후방 호환성만을 위해 정의되어 있는 헤더 필드.

```
Pragma: no-cache
```

일반 헤더 필드 이지만 클라이언트의 레퀘스트에서만 사용된다. 클라이언트는 캐시된 리소스의 리스폰스를 원하지 않음을 모든 중간 서버에 알리기 위해 사용한다. 

</br>

### Trailer

Trailer의 헤더 필드는 메시지 바디의 뒤에 기술되어 있는 헤더 필드를 미리 전달 가능하다 .이 헤더 필드는 HTTP/1.1에 구현되어 있는 청크 전송 인코딩을 사용하고 있는 경우에 사용 가능하다. 

</br>

### Transfer-Encoding

Transfer-Encoding 헤더 필드는 메시지의 바디의 전송 코딩 형식을 지정하는 경우에 사용.

HTTP/1.1에서는 전송 코딩 형식으로 청크 전송만이 정의되어 있다.

</br>

### Upgrade

Upgrade 헤더 필드는 HTTP 및 다른 프로토콜의 새로운 버전이 통신에 이용되는 경우에 사용한다.

지정하는 대상이 전혀 다른 통신 프로토콜이라고 하더라도 문제 없다.

클라이언트 → 서버

```
GET /index.html HTTP/1.1
Upgrade: TLS/1.0
Coonection: Upgrade
```

서버 → 클라이언트

```
HTTP/1.1 101 Switching Protocols
Upgrade: TLS/1.0, HTTP/1.1
Connectoin: Upgrade
```

</br>

### Via

Via 헤더 필드는 클라이언트와 서버 간의 리퀘스트 혹은 리스폰스 메시지의 경로를 알기 위해 사용된다. 프록시 혹은 게이트 웨이는 자신의 서버 종보를 Via 헤더 필드에 추가한 뒤에 메시지를 전송한다. 이것은 traceroute와 메일의 Received 헤더 기능과 유사하다.

Via 헤더 필드는 전송된 메시지의 추적과 리퀘스트 루프의 회피 등에 사용되기 때문에 프록시를 경유하는 경우에는 반드시 부가할 필요가 있다.

Via 헤더는 배송 경로를 알기 위해 TRACE 메소드와 연계해서 자주 사용된다.

</br>

### Warning

Warning 헤더는 HTTP/1.0 리스폰스 헤더(Retry-After)가 Http/1.1에서 변경된 것으로, 리스폰스에 관한 추가 정보를 전달한다. 기본적으로 캐시에 관한 문제의 경고를 유저에 전달한다. 

```
Warning: [경고 코드][경고한 호스트:포트 번호]"[경고문]" ([날짜])
```

HTTP/1.1에는 7개의 경고 코드가 정의되어 있다. 

이 경고문은 어디까지나 권장사항이며, 경고코드는 확장성을 가지고 있기 떄문에 이후에 코드를 추가할 수 있다.
