# 6장 HTTP 헤더

## 6.1 HTTP 메시지 헤더

HTTP 프로토콜의 리퀘스트와 리스폰스에는 반드시 메시지 헤더가 포함됨

- 메시지 헤더에는 클라이언트나 서버가 리퀘스트나 리스폰스를 처리하기 위한 정보 들어있음
- 클라이언트를 이용하는 사용자가 직접 볼 필요는 없음

### 리퀘스트의 HTTP 메시지

메소드, URI, HTTP 버전, HTTP 헤더 필드로 구성

### 리스폰스의 HTTP 메시지

HTTP 메시지와 HTTP 버전, 상태 코드(코드와 설명), HTTP 헤더 필드 등으로 구성

## 6.2 HTTP 헤더 필드

### 6.2.1 HTTP 헤더 필드는 중요한 정보를 전달한다

**HTTP 헤더 필드**

- HTTP 메시지를 구성하는 요소
- 리퀘스트와 리스폰스에 모두 존재
- 중요한 정보를 전달하는 역할 담당
- 메시지 바디의 크기나 사용하고 있는 언어, 인증 정보 등을 브라우저나 서버에 제공하기 위해 사용

### 6.2.2 HTTP 헤더 필드의 구조

HTTP 헤더필드 —> **헤더 필드 명 : 필드 값**으로 구성

ex) Content-Type:text/html

하나의 HTTP 헤더 필드가 여러 개의 필드값을 가질 수 있음

ex) Keep-Alive:timeout=15,max=100

### 6.2.3 4종류의 HTTP 헤더 필드

**일반적 헤더 필드(General Header Fields)**

- 리퀘스트 메시지와 리스폰스 메시지 둘 다 사용되는 헤더

**리퀘스트 헤더 필드(Reqeust Header Fields)**

- 클라이언트 측에서 서버 측으로 송신된 리퀘스트 메시지에 사용되는 헤더
- 리퀘스트의 부가적인 정보, 클라이언트 정보, 리스폰스의 콘텐츠에 관한 우선 순위 부가

**리스폰스 헤더 필드(Response Header Fields)**

- 서버 측에서 클라이언트 측으로 송신한 리스폰스 메시지에 사용되는 헤더
- 리스폰스의 정보, 서버의 정보, 클라이언트의 추가 정보 요구 등을 부가

**엔티티 헤더 필드IEntity Header Fields)**

- 리퀘스트 메시지와 리스폰스 메시지에 포함된 엔티티에 사용되는 헤더
- 콘텐츠 갱신 시간 등의 엔티티에 관한 정보 부가

### 6.2.4 HTTP/1.1 헤더 필드 일람

**일반 헤더 필드**

![IMG_3960.JPG](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/bcbd1d72-1184-4d67-8d57-c84b21e75db8/IMG_3960.jpg)

**리퀘스트 헤더 필드**

![IMG_3961.JPG](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/ad539812-d424-448b-90b9-ffb74eef57cd/IMG_3961.jpg)

**리스폰스 헤더 필드**

![IMG_3962.JPG](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/15539805-af37-416d-ade4-0df6e4501afb/IMG_3962.jpg)

![IMG_3963.JPG](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/c7f0b76d-0d66-4dd7-9861-9a210a057a21/IMG_3963.jpg)

**엔티티 헤더 필드**

![IMG_3964.JPG](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/6c903478-bd57-4b26-b1ab-cc106ed9a381/IMG_3964.jpg)

### 6.2.5 HTTP/1.1 이외의 헤더 필드

HTTP에서 교환되는 HTTP 헤더 필드가 RFC2616에서 정의된 47종류만 있는 것은 아님

### 6.2.6 End-to-end 헤더와 Hop-by-hop 헤더

캐시와 비캐시 프록시의 동작을 정의하기 위해 두 가지 카테고리로 분류

**End-to-end 헤더**

- message의 마지막 response에게 전송되어야 하는 헤더 => 요청 : 서버 / 응답 : 클라이언트
- 중간 프록시는 반드시 종단 간 헤더를 수정되지 않은 상태로 재전송해야 하고, 캐시는 이것을 반드시 저장해야함

**Hop-by-hop 헤더**

- 단일 전송-레벨 연결에서만 의미가 있음
- 프록시에의해 재전송되거나 [캐시](https://developer.mozilla.org/ko/docs/Web/HTTP/Caching)되어선 안됨
- 종류: Connection, Keep-Alive, Proxy-Authenticate, Proxy-Authorization, TE, Trailer, Transfer-Encoding, Upgrade

## 6.3 HTTP/1.1 일반 헤더 필드

**일반 헤더 필드**

- 리퀘스트 메시지와 리스폰스 메시지 양쪽에서 사용되는 헤더

### 6.3.1 Cache-Control

디렉티브로 불리는 명령을 사용하여 캐싱 동작을 지정

지정한 디렉티브에는 파라미터 있는 것과 없는 것도 있으며 여러 개의 디렉티브를 지정하는 경우 ‘,’로 구분

ex) Cache-Control: private, max-age=0, no-cache

**Cache-Control 디렉티브 알림**

**캐시 리퀘스트 디렉티브**

![IMG_3965.JPG](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/9f7986ec-7674-45b6-af8d-e6afd9f5989d/IMG_3965.jpg)

**캐시 리스폰스 디렉티브**

![IMG_3966.JPG](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/38283dbd-0e49-46f0-bbda-fa77ca4daf4e/IMG_3966.jpg)

### 캐시가 가능한지 여부를 나타내는 디렉티브

**1) public 디렉티브**

> Cache-Control: public
>

다른 유저에게도 돌려줄 수 있는 캐시를 해도 좋다는 것을 명시적으로 나타냄

**2) private 디렉티브**

> Cache-Control: private
>

리스폰스는 특정 유저만을 대상으로 하고 있다는 것을 나타냄

캐시 서버는 특정 유저를 위해서 리소스를 캐시할 수 있지만, 다른 유저로부터 같은 리퀘스트가 온다고 하더라도 그 캐시를 반환하지 않도록 함

**3) no-cache 디렉티브**

> Cache-Control: no-cache
>

캐시로부터 오래된 리소스가 반환되는 것을 막기 위해 사용

클라이언트의 리퀘스트로 no-cache 디렉티브가 사용된 경우, 캐시된 리스폰스를 클라이언트가 받 들이지 않음

→ 중간 캐시 서버가 오리진 서버까지 리퀘스트를 전송

서버의 리스폰스에 no-cache 디렉티브가 사용된 경우, 캐시 서버는 리소스를 저장할 수 없음

→ 오리진 서버는 캐시 서버가 이후의 리퀘스트에서 리소스의 유효성을 재확인하지 않고는 그 리스폰스 사용하지 못함

> Cache-Control: no-cache=Location
>

서버의 리스폰스로 no-cache의 필드 값에 헤더 필드 명이 지정된 경우에는 이 지정된 헤더 필드만 캐시 할 수 없음

→ 지정된 헤더 필드 외에는 캐시하는 것이 가능, 리스폰스 디렉티브만 가능

### 캐시로 보존 가능한 것을 제어하는 디렉티브

**1) no-store 디렉티브**

> Cache-Cnotrol: no-store
>

리퀘스트(그와 대응되는 리스폰스) 혹은 리스폰스에 기밀 정보가 포함되어 있음

→ 캐시는 리퀘스트, 리스폰스의 일부분을 로컬 스토리지에 보존해서는 안되도록 지정

### 캐시 기한이나 검증을 지정하는 디렉티브

**1) s-maxage 디렉티브**

> Cache-Control: s-maxage=604800 (단위 : 초)
>

여러 유저가 이용할 수 있는 공유 캐시 서버에만 적용된다는 것

→ 같은 유저에 반복해서 리스폰스를 반환하는 캐시 서버는 무효한 디렉티브

이를 사용하는 경우, Expires 헤더 필드와 max-age 디렉티브 무시

**2) max-age 디렉티브**

> Cache-Control: max-age=606800 (단위: 초)
>

클라이언트 리퀘스트로 지정되었던 값보다 새로운 경우에는 캐시되었던 리소스를 받아들일 수 있음

→ 지정한 값이 0이면 캐시 서버는 리퀘스트를 항상 오리진 서버에 넘겨야함

서버의 리스폰스에서는 캐시 서버가 유효성의 재확인을 하지 않고 리소스를 캐시에 보존해 두는 최대 시간을 나타냄

HTTP/1.1 -> max-age 디렉티브 지정 우선, Expires 헤더 필드 무시

HTTP/1.0 → max-age 디렉티브 무시

**3) min-fresh 디렉티브**

> Cache-Control: min-fresh=60 (단위: 초)
>

캐시된 리소스가 적어도 지정된 시간은 최신 상태의 것을 반환하도록 캐시 서버에 요구

→ 60초로 지정되어 있는 경우에는 60초 이내에 유효 기간이 끝나는 리소스를 리스폰스로 반환하면 안됨

**4) max-stale 디렉티브**

> Cache-Control: max-stale=3600 (단위: 초)
>

캐시된 리소스의 유효 기간이 끝났더라도 받아들일 수 있음을 나타냄

→ 디렉티브에 값이 지정되지 않는 경우는 클라이언트는 아무리 시간이 경과했더라도 리스폰스 받아들임

→ 값이 지정되어 있는 경우 유효 기한이 지난 후로부터 지정 시간 내라면 받아들이다는 뜻을 서버에 전달

**5) only-if-cached 디렉티브**

> Cache-Control: only-if-cached
>

클라이언트는 캐시 서버에 대해서 목적한 리소스가 로컬 캐시에 있는 경우만 리스폰스 반환하도록 요구

→ 캐시 서버에서 리스폰스의 리로드와 유효성을 재확인하지 않도록 요구

→ 캐시 서버가 로컬 캐시로부터 응답할 수 없는 경우에는 504

**6) must-revalidate 디렉티브**

> Cache-Control: must-revalidate
>

리스폰스의 캐시가 현재도 유효한지 아닌지의 여부를 오리진 서버에 조회 요구

→ 프록시가 오리진 서버에 도달 할 수 없고, 리소스를 다시 요구할 수 없으면 504

→ 리퀘스트에서 max-stale 디렉티브 사용하고 있더라도 무시

**7) proxy-revalidate 디렉티브**

> Cache-Control: proxy-revalidate
>

proxy-revalidate 디렉티브가 사용되는 경우, 모든 캐시 서버에 대해서 이후의 리퀘스트로 해당 리스폰스 반환할 때 반드시 유효성 재확인을 하도록 요구

**8) no-transform 디렉티브**

> Cache-Control: no-transform
>

리퀘스트와 리스폰스의 어느 쪽에 있어서도 캐시가 엔티티 바디의 미디어 타입을 변경하지 않도록 지정

→ 캐시 서버 등에 의해서 이미지가 압축되는 것을 방지

### Cache-Control 확장

**1) cache-extension 토큰**

> Cache-Control: private, community=”UCI”
>

cache-extension 토큰을 사용하여 디렉티브 확장

→ 캐시 서버가 새로운 디렉티브를 이해하지 못할 경우 무시, 이해할 수 있는 캐시 서버에 대해서만 의미 있음

### 6.3.2 Connection

**Connection 헤더 필드 역할**

- 프록시에 더 이상 전송하지 않는 헤더 필드를 지정

  > Connection: 더 이상 전송하지 않는 헤더 필드 명
  >

  클라이언트의 리퀘스트나 서버의 리스폰스에서 Connection 헤더 필드를 사용

  프록시 서버에 더 이상 전송하지 않는 헤더 필드 지정

- 지속적 접속 관리

  > Connection: Close
  >

  HTTP/1.1에서는 지속적 접속이 디폴트로 되어 있음

  리퀘스트를 송신했던 클라이언트는 접속이 계속 유지되면서 추가 리퀘스트를 송신하도록 함

  명시적으로 접속을 끊고 싶으면 Connection 헤더필드에 Close 지정

  > Connection: Keep-Alive
  >

  HTTP/1.1 이전 버전은 지속적  접속이 디폴트가 아니었음

  오래된 버전의 HTTP의 경우 지속적 접속을 하고 싶은 경우 위처럼 지정해야함


### 6.3.3 Date

Date 헤더 필드는 HTTP 메시지를 생성하는 날짜를 나타냄

### 6.3.4 Pragma

HTTP/1.1보다 오래된 버전의 흔적으로 HTTP/1.0 와의 후방 호환성만을 위해 정의되어 있는 헤더 필드

> Pragma: no-cache
>

클라이언트 리퀘스트에서만 사용

클라이언트는 캐시된 리소스의 리스폰스를 원하지 않음을 모든 중간 서버에 알리기 위해 사용

중간 서버에 보낼 때

> Cache-Control: no-cache
Pragma: no-cache
>

### 6.3.5 Trailer

메시지 바디의 뒤에 기술되어 있는 헤더 필드를 미리 전달할 수 있음

HTTP/1.1에 구현되어 있는 청크 전송 인코딩을 사용하고 있는 경우에 사용 가능

### 6.3.6 Transfer-Encoding

메시지 바디의 전송 코딩 형식을 지원하는 경우에 사용

### 6.3.7 Upgrade

HTTP 및 다른 프로토콜의 새로운 버전이 통신에 이용되는 경우 사용

→ 지정하는 대상이 전혀 다른 통신 프로그램이라도 상관 없음

### 6.3.8 Via

클라이언트와 서버 간의 리퀘스트 혹은 리스폰스 메시지의 경로를 알기 위해서 사용

프록시 혹은 게이트웨이는 자신의 서버 정보를 Via 헤더 필드에 추가한 뒤에 메세지 전송

전송된 메시지의 추적과 리퀘스트 루프의 회피 등에 사용되기 때문에 프록시를 경유하는 경우에는 반드시 부가 필요

### 6.3.9 Warning

HTTP/1.0 리스폰스 헤더가 HTTP/1.1에서 변경된 것

리스폰스에 관한 추가 정보 전달

캐시에 관한 문제의 경고를 유저에게 전달

HTTP/1.1에는 7개의 경고 코드 정의
