# 6장 HTTP 헤더

## 6.1 HTTP 메시지 헤더

HTTP 프로토콜의 리퀘스트와 리스폰스에는 반드시 메시지 헤더가 포함됨

- 메시지 헤더에는 클라이언트나 서버가 리퀘스트나 리스폰스를 처리하기 위한 정보 들어있음
- 클라이언트를 이용하는 사용자가 직접 볼 필요는 없음

### 리퀘스트의 HTTP 메시지

메소드, URI, HTTP 버전, HTTP 헤더 필드로 구성

### 리스폰스의 HTTP 메시지

HTTP 메시지와 HTTP 버전, 상태 코드(코드와 설명), HTTP 헤더 필드 등으로 구성

## 6.2 HTTP 헤더 필드

### 6.2.1 HTTP 헤더 필드는 중요한 정보를 전달한다

**HTTP 헤더 필드**

- HTTP 메시지를 구성하는 요소
- 리퀘스트와 리스폰스에 모두 존재
- 중요한 정보를 전달하는 역할 담당
- 메시지 바디의 크기나 사용하고 있는 언어, 인증 정보 등을 브라우저나 서버에 제공하기 위해 사용

### 6.2.2 HTTP 헤더 필드의 구조

HTTP 헤더필드 —> **헤더 필드 명 : 필드 값**으로 구성

ex) Content-Type:text/html

하나의 HTTP 헤더 필드가 여러 개의 필드값을 가질 수 있음

ex) Keep-Alive:timeout=15,max=100

### 6.2.3 4종류의 HTTP 헤더 필드

**일반적 헤더 필드(General Header Fields)**

- 리퀘스트 메시지와 리스폰스 메시지 둘 다 사용되는 헤더

**리퀘스트 헤더 필드(Reqeust Header Fields)**

- 클라이언트 측에서 서버 측으로 송신된 리퀘스트 메시지에 사용되는 헤더
- 리퀘스트의 부가적인 정보, 클라이언트 정보, 리스폰스의 콘텐츠에 관한 우선 순위 부가

**리스폰스 헤더 필드(Response Header Fields)**

- 서버 측에서 클라이언트 측으로 송신한 리스폰스 메시지에 사용되는 헤더
- 리스폰스의 정보, 서버의 정보, 클라이언트의 추가 정보 요구 등을 부가

**엔티티 헤더 필드IEntity Header Fields)**

- 리퀘스트 메시지와 리스폰스 메시지에 포함된 엔티티에 사용되는 헤더
- 콘텐츠 갱신 시간 등의 엔티티에 관한 정보 부가

### 6.2.4 HTTP/1.1 헤더 필드 일람

**일반 헤더 필드**

![IMG_3960.JPG](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/bcbd1d72-1184-4d67-8d57-c84b21e75db8/IMG_3960.jpg)

**리퀘스트 헤더 필드**

![IMG_3961.JPG](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/ad539812-d424-448b-90b9-ffb74eef57cd/IMG_3961.jpg)

**리스폰스 헤더 필드**

![IMG_3962.JPG](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/15539805-af37-416d-ade4-0df6e4501afb/IMG_3962.jpg)

![IMG_3963.JPG](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/c7f0b76d-0d66-4dd7-9861-9a210a057a21/IMG_3963.jpg)

**엔티티 헤더 필드**

![IMG_3964.JPG](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/6c903478-bd57-4b26-b1ab-cc106ed9a381/IMG_3964.jpg)

### 6.2.5 HTTP/1.1 이외의 헤더 필드

HTTP에서 교환되는 HTTP 헤더 필드가 RFC2616에서 정의된 47종류만 있는 것은 아님

### 6.2.6 End-to-end 헤더와 Hop-by-hop 헤더

캐시와 비캐시 프록시의 동작을 정의하기 위해 두 가지 카테고리로 분류

**End-to-end 헤더**

- message의 마지막 response에게 전송되어야 하는 헤더 => 요청 : 서버 / 응답 : 클라이언트
- 중간 프록시는 반드시 종단 간 헤더를 수정되지 않은 상태로 재전송해야 하고, 캐시는 이것을 반드시 저장해야함

**Hop-by-hop 헤더**

- 단일 전송-레벨 연결에서만 의미가 있음
- 프록시에의해 재전송되거나 [캐시](https://developer.mozilla.org/ko/docs/Web/HTTP/Caching)되어선 안됨
- 종류: Connection, Keep-Alive, Proxy-Authenticate, Proxy-Authorization, TE, Trailer, Transfer-Encoding, Upgrade

## 6.3 HTTP/1.1 일반 헤더 필드

**일반 헤더 필드**

- 리퀘스트 메시지와 리스폰스 메시지 양쪽에서 사용되는 헤더

### 6.3.1 Cache-Control

디렉티브로 불리는 명령을 사용하여 캐싱 동작을 지정

지정한 디렉티브에는 파라미터 있는 것과 없는 것도 있으며 여러 개의 디렉티브를 지정하는 경우 ‘,’로 구분

ex) Cache-Control: private, max-age=0, no-cache

**Cache-Control 디렉티브 알림**

**캐시 리퀘스트 디렉티브**

![IMG_3965.JPG](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/9f7986ec-7674-45b6-af8d-e6afd9f5989d/IMG_3965.jpg)

**캐시 리스폰스 디렉티브**

![IMG_3966.JPG](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/38283dbd-0e49-46f0-bbda-fa77ca4daf4e/IMG_3966.jpg)

### 캐시가 가능한지 여부를 나타내는 디렉티브

**1) public 디렉티브**

> Cache-Control: public
>

다른 유저에게도 돌려줄 수 있는 캐시를 해도 좋다는 것을 명시적으로 나타냄

**2) private 디렉티브**

> Cache-Control: private
>

리스폰스는 특정 유저만을 대상으로 하고 있다는 것을 나타냄

캐시 서버는 특정 유저를 위해서 리소스를 캐시할 수 있지만, 다른 유저로부터 같은 리퀘스트가 온다고 하더라도 그 캐시를 반환하지 않도록 함

**3) no-cache 디렉티브**

> Cache-Control: no-cache
>

캐시로부터 오래된 리소스가 반환되는 것을 막기 위해 사용

클라이언트의 리퀘스트로 no-cache 디렉티브가 사용된 경우, 캐시된 리스폰스를 클라이언트가 받 들이지 않음

→ 중간 캐시 서버가 오리진 서버까지 리퀘스트를 전송

서버의 리스폰스에 no-cache 디렉티브가 사용된 경우, 캐시 서버는 리소스를 저장할 수 없음

→ 오리진 서버는 캐시 서버가 이후의 리퀘스트에서 리소스의 유효성을 재확인하지 않고는 그 리스폰스 사용하지 못함

> Cache-Control: no-cache=Location
>

서버의 리스폰스로 no-cache의 필드 값에 헤더 필드 명이 지정된 경우에는 이 지정된 헤더 필드만 캐시 할 수 없음

→ 지정된 헤더 필드 외에는 캐시하는 것이 가능, 리스폰스 디렉티브만 가능

### 캐시로 보존 가능한 것을 제어하는 디렉티브

**1) no-store 디렉티브**

> Cache-Cnotrol: no-store
>

리퀘스트(그와 대응되는 리스폰스) 혹은 리스폰스에 기밀 정보가 포함되어 있음

→ 캐시는 리퀘스트, 리스폰스의 일부분을 로컬 스토리지에 보존해서는 안되도록 지정

### 캐시 기한이나 검증을 지정하는 디렉티브

**1) s-maxage 디렉티브**

> Cache-Control: s-maxage=604800 (단위 : 초)
>

여러 유저가 이용할 수 있는 공유 캐시 서버에만 적용된다는 것

→ 같은 유저에 반복해서 리스폰스를 반환하는 캐시 서버는 무효한 디렉티브

이를 사용하는 경우, Expires 헤더 필드와 max-age 디렉티브 무시

**2) max-age 디렉티브**

> Cache-Control: max-age=606800 (단위: 초)
>

클라이언트 리퀘스트로 지정되었던 값보다 새로운 경우에는 캐시되었던 리소스를 받아들일 수 있음

→ 지정한 값이 0이면 캐시 서버는 리퀘스트를 항상 오리진 서버에 넘겨야함

서버의 리스폰스에서는 캐시 서버가 유효성의 재확인을 하지 않고 리소스를 캐시에 보존해 두는 최대 시간을 나타냄

HTTP/1.1 -> max-age 디렉티브 지정 우선, Expires 헤더 필드 무시

HTTP/1.0 → max-age 디렉티브 무시

**3) min-fresh 디렉티브**

> Cache-Control: min-fresh=60 (단위: 초)
>

캐시된 리소스가 적어도 지정된 시간은 최신 상태의 것을 반환하도록 캐시 서버에 요구

→ 60초로 지정되어 있는 경우에는 60초 이내에 유효 기간이 끝나는 리소스를 리스폰스로 반환하면 안됨

**4) max-stale 디렉티브**

> Cache-Control: max-stale=3600 (단위: 초)
>

캐시된 리소스의 유효 기간이 끝났더라도 받아들일 수 있음을 나타냄

→ 디렉티브에 값이 지정되지 않는 경우는 클라이언트는 아무리 시간이 경과했더라도 리스폰스 받아들임

→ 값이 지정되어 있는 경우 유효 기한이 지난 후로부터 지정 시간 내라면 받아들이다는 뜻을 서버에 전달

**5) only-if-cached 디렉티브**

> Cache-Control: only-if-cached
>

클라이언트는 캐시 서버에 대해서 목적한 리소스가 로컬 캐시에 있는 경우만 리스폰스 반환하도록 요구

→ 캐시 서버에서 리스폰스의 리로드와 유효성을 재확인하지 않도록 요구

→ 캐시 서버가 로컬 캐시로부터 응답할 수 없는 경우에는 504

**6) must-revalidate 디렉티브**

> Cache-Control: must-revalidate
>

리스폰스의 캐시가 현재도 유효한지 아닌지의 여부를 오리진 서버에 조회 요구

→ 프록시가 오리진 서버에 도달 할 수 없고, 리소스를 다시 요구할 수 없으면 504

→ 리퀘스트에서 max-stale 디렉티브 사용하고 있더라도 무시

**7) proxy-revalidate 디렉티브**

> Cache-Control: proxy-revalidate
>

proxy-revalidate 디렉티브가 사용되는 경우, 모든 캐시 서버에 대해서 이후의 리퀘스트로 해당 리스폰스 반환할 때 반드시 유효성 재확인을 하도록 요구

**8) no-transform 디렉티브**

> Cache-Control: no-transform
>

리퀘스트와 리스폰스의 어느 쪽에 있어서도 캐시가 엔티티 바디의 미디어 타입을 변경하지 않도록 지정

→ 캐시 서버 등에 의해서 이미지가 압축되는 것을 방지

### Cache-Control 확장

**1) cache-extension 토큰**

> Cache-Control: private, community=”UCI”
>

cache-extension 토큰을 사용하여 디렉티브 확장

→ 캐시 서버가 새로운 디렉티브를 이해하지 못할 경우 무시, 이해할 수 있는 캐시 서버에 대해서만 의미 있음

### 6.3.2 Connection

**Connection 헤더 필드 역할**

- 프록시에 더 이상 전송하지 않는 헤더 필드를 지정

  > Connection: 더 이상 전송하지 않는 헤더 필드 명
  >

  클라이언트의 리퀘스트나 서버의 리스폰스에서 Connection 헤더 필드를 사용

  프록시 서버에 더 이상 전송하지 않는 헤더 필드 지정

- 지속적 접속 관리

  > Connection: Close
  >

  HTTP/1.1에서는 지속적 접속이 디폴트로 되어 있음

  리퀘스트를 송신했던 클라이언트는 접속이 계속 유지되면서 추가 리퀘스트를 송신하도록 함

  명시적으로 접속을 끊고 싶으면 Connection 헤더필드에 Close 지정

  > Connection: Keep-Alive
  >

  HTTP/1.1 이전 버전은 지속적  접속이 디폴트가 아니었음

  오래된 버전의 HTTP의 경우 지속적 접속을 하고 싶은 경우 위처럼 지정해야함


### 6.3.3 Date

Date 헤더 필드는 HTTP 메시지를 생성하는 날짜를 나타냄

### 6.3.4 Pragma

HTTP/1.1보다 오래된 버전의 흔적으로 HTTP/1.0 와의 후방 호환성만을 위해 정의되어 있는 헤더 필드

> Pragma: no-cache
>

클라이언트 리퀘스트에서만 사용

클라이언트는 캐시된 리소스의 리스폰스를 원하지 않음을 모든 중간 서버에 알리기 위해 사용

중간 서버에 보낼 때

> Cache-Control: no-cache
Pragma: no-cache
>

### 6.3.5 Trailer

메시지 바디의 뒤에 기술되어 있는 헤더 필드를 미리 전달할 수 있음

HTTP/1.1에 구현되어 있는 청크 전송 인코딩을 사용하고 있는 경우에 사용 가능

### 6.3.6 Transfer-Encoding

메시지 바디의 전송 코딩 형식을 지원하는 경우에 사용

### 6.3.7 Upgrade

HTTP 및 다른 프로토콜의 새로운 버전이 통신에 이용되는 경우 사용

→ 지정하는 대상이 전혀 다른 통신 프로그램이라도 상관 없음

### 6.3.8 Via

클라이언트와 서버 간의 리퀘스트 혹은 리스폰스 메시지의 경로를 알기 위해서 사용

프록시 혹은 게이트웨이는 자신의 서버 정보를 Via 헤더 필드에 추가한 뒤에 메세지 전송

전송된 메시지의 추적과 리퀘스트 루프의 회피 등에 사용되기 때문에 프록시를 경유하는 경우에는 반드시 부가 필요

### 6.3.9 Warning

HTTP/1.0 리스폰스 헤더가 HTTP/1.1에서 변경된 것

리스폰스에 관한 추가 정보 전달

캐시에 관한 문제의 경고를 유저에게 전달

HTTP/1.1에는 7개의 경고 코드 정의

## 6.4 리퀘스트 헤더 필드

클라이언트 측에서 서버 측으로 송신된 리퀘스트 메시지에 사용되는 헤더

리퀘스트의 부가 정보, 클라이언트 정보, 리스폰스의 콘텐츠에 관한 우선 순위 추가

### 6.4.1 Accept

유저 에이전트에 처리할 수 있는 미디어 타입과 미디어 타입의 상대적인 우선 순위를 전달하기 위해 사용

미디어 타입 지정은 **타입/서브타입**으로 한번에 여러 번 설정 가능

- 텍스트 파일

text/html, text/plain, text/css …

application/xhtml+xml, application/xml …

- 이미지 파일

image/jpeg, image/gif, image/png …

- 동영상 파일

video/mpeg, video/quicktime …

- 애플리케이션용 바이너리 파일

application/octet-stream, application/zip …

표시하는 미디어 타입에 우선 순위를 붙이고 싶은 경우에는 “:”으로 구분

“q=” → 표시할 품질 지수

- 품질 계수는 0~1 범위의 수치(소수점 3자리까지)
- 1이 높은 쪽
- 지정이 없는 경우 암묵적으로 “q=1.0”
- 서버가 복수의 콘텐츠를 반환할 수 있는 경우 → 가장 높은 품질 계수의 미디어 타입으로 반환

### 6.4.2 Accept-Charset

유저 에이전트에서 처리할 수 있는 문자셋, 문자셋의 상대적인 우선 순위 전달하기 위해 사용

문자셋은 여러 개 지정 가능

품질 지수에 의해 상대적 우선 순위 표시, 서버 구동형 네고시에이션에 이용

### 6.4.3 Accept-Encoding

> Accept-Encoding: gzip, deflate
>

유저 에이전트가 처리할 수 있는 콘텐츠 코딩과 콘텐츠 코딩의 상대적인 우선 순위를 전달하기 위해 사용

콘텐츠 코딩의 지정은 한번에 여러개 지정 가능

- gzip

파일 압축 프로그램 gzip에서 생성된 인코딩 포맷

- compress

Unix 파일 압축 프로그램 “compress”에 의해서 만들어진 인코딩 포맷

- deflate

Zlib 포맷과 deflate 압축 알고리즘에 의해서 만들어진 인코딩 포맷 조합한 것

- identity

압축과 변형을 하지 않는 디폴트 인코딩 포맷

품질지수에 의해서 상대적인 우선 순위 표시

“*”(애스터리스크) → 와일드 카드, 모든 인코딩 포맷 가리킴

### 6.4.4 Accept-Language

> Accept-Language: ko-kr, en-us:q=0.7,en:q=0.3
>

→ 한국어 리소스가 있는 경우에는 한국어로, 없으면 영어 리소스로 리스폰스를 받고 싶다는 것을 나타냄

유저 에이전트가 처리할 수 있는 자연어의 세트와 자연어 세트의 상대적인 우선 순위를 전달하기 위해 사용

자연어 세트 한번에 여러개 지정 가능

품질 지수에 의해 상대적인 우선 순위 나타냄

### 6.4.5 Authorization

유저 에이전트의 인증 정보(크리덴셜 값)을 전달하기 위해 사용

서버에 인증받으려는 유저 에이전트는 상태 코드 401 리스폰스 뒤에 리퀘스트에 Authorization 헤더 필드 포함

공유 캐시가 Authorization 헤더 필드를 포함하는 리퀘스트를 받은 경우 다른 동작 수행

### 6.4.6 Expect

클라이언트가 서버에 특정 동작 요구를 전달

기대하고 있는 요구에 서버가 응답하지 못해서 에러가 발생하는 경우에는 상태 코드 417(Expetataion Failed) 반환

클라이언트는 이 헤더 필드에 원하는 확장을 딸려 보낼 수 있지만 HTTP/1.1 사양에서는 “100-continue”(상태 코드 100 continue의 의미)

상태 코드 100 리스폰스를 가진 클라이언트는 리퀘스트 할 때 **Expect: 100-continue**로 지정 해야함

### 6.4.7 From

유저 에이전트를 사용하고 잇는 유저의 메일 주소를 전달

검색 엔진 등의 에이전트 책임자에게 연락처 메일 주소를 나타내는 목적으로 사용

에이전트를 사용하는 경우에는 From 헤더 필드 포함해야 함

### 6.4.8 Host

리퀘스트한 리소스의 인터넷 호스트와 포트 번호를 전달

HTTP/1.1에서 유일한 필수 헤더 필드

→ 1대의 서버에서 복수의 도메인을 할당할 수 있는 가상 호스트의 구조와 매우 깊은 관련이 있음

리퀘스트가 서버에 오면 호스트명을 IP주소로 해결해 리퀘스트 처리 → 같은 IP 주소로 복수의 도메인이 적용되어 있다고 한다면 어느 도메인에 대한 리퀘스트인지 알 수 없음 → Host 헤더 필드에 리퀘스트를 받을 호스트명을 명확하게 해야함

서버에 호스트 명이 설정되어 있지 않는 경우 → Host:

### 6.4.9 If-Match

> If-xxx : 조건부 리퀘스트라고 부름
→ 지정된 조건에 맞는 경우에만 리퀘스트를 받음
>

서버 상의 리소스를 특정하기 위해서 엔티티 태그(ETag) 값을 전달

- 서버는 약한 ETag 값을 사용할 수 없음(?)

서버는 If-Match의 필드 값과 리소스의 ETag 값이 일치한 경우에만 리퀘스트 받아들일 수 있음

일치하지 않으면 412(Precondition Failed) 리스폰스 반환

If-Match에 “*”도 가능 → ETag 값에 구애받지 않고 리소스가 존재하면 리퀘스트 처리

### 6.4.10 If-Modified-Since

> If-Modified-Since: Thu, 15 Apr 2004 00:00:00 GMT
>

리소스 갱신 날짜가 필드 값보다 새롭지 않다면 리퀘스트를 받아들이겠다는 뜻

필드 값에 지정된 날짜 이후 → 지정한 리소스가 갱신되어 있지 않은 경우는 304(Not Modified) 반환

### 6.4.11 If-None-Match

If-Match 헤더 필드와 반대로 동작

If-None-Match의 필드 값에 지정된 엔티티 태그(ETag) 값이 지정된 리소스의 ETag 값과 일치하지 않으면 리퀘스트를 받아들이겠다는 뜻

GET, HEAD + If-None-Match —> 최신의 리소스 요구하는 것 == If-Modified-Since와 비슷

### 6.4.12 If-Range

> **If-Range 헤더 필드 사용**
If-Range로 지정한 필드 값(ETag 값 or날짜)과 지정한 리소스의 ETag 값 혹은 날짜가 일치하면 Range 리퀘스트로서 처리하고 싶다는 것을 전달
일치하지 않는 경우 리소스 전체 반환
>

> **If-Range 헤더 필드 사용하지 않는 경우**
서버 측의 리소스가 갱신되어 있는 경우, 클라이언트 측에서 가지고 있는 리소스의 일부분 무효 → Range 리퀘스트 무효
서버는 412(Precondition Failed) 리스폰스 반환, 클라이언트에 다시 리퀘스트 보내도록 재촉
>

### 6.4.13 If-Unmodified-Since

If-Modified-Since 헤더 필드와 반대로 동작

지정된 리소스가 필드 값에 지정된 날짜 이후에 갱신되어 있지 않은 경우에만 리퀘스트 받아들이도록 전달

지정된 날짜 이후에 갱신된 경우 → 상태 코드 412(Precondition Failed) 리스폰스 반환

### 6.4.14 Max-Forwards

> Max-Forwards: 10
>

TRACE 혹은 OPTIONS 메소드에 의한 리퀘스트를 할 때에 전송해도 좋은 서버 수의 최대치를 10진수 정수로 지정

서버는 다음 서버에 리퀘스트를 전송할 때 Max-Forwards 값에서 1을 빼서 다시 세트

Max-Forwards 값이 0인 리퀘스트를 받은 경우 전송하지 않고 리스폰스 반환할 필요가 있음

HTTP를 사용한 통신에서 리퀘스트가 여러 대의 서버를 경유하게 됨 → 프록시 서버에 무언가의 원인으로 리퀘스트 전송이 실패하게 되면 클라이언트 리스폰스 되돌아 오지 않아서 알 수 없음

→ 이러한 문제의 원인 조사에 Max-Forwards 활용

- 필드 값이 0이 되었던 서버가 리스폰스를 하기 때문에 그 서버까지의 상황을 알 수 있음

### 6.4.15 Proxy-Authorization

프록시 서버에서의 인증 요구를 받아들인 때에 인증에 필요한 클라이언트의 정보 전달

클라이언트와 프록시 사이에 인증이 이루어짐

### 6.4.16 Range

> Range: bytes=5001-10000
>

리소스의 일부분만 취득하는 Range 리퀘스트를 할 때 지정 범위 전달

리퀘스트를 처리할 수 있으면 → 206 Partial Content

처리할 수 없으면 → 200 OK 리스폰스 리소스 전체 반환

### 6.4.17 Referer

리퀘스트가 발생한 본래 리소스의 URI 전달

기본적으로 Referer 헤더 필드는 보내져야 하지만, 브라우저 주소창에 직접 URI를 입력한 경우, 보안상 바람직하지 않다고 판단된 경우에는 보내지 않아도 됨

→ Referer를 통해서 리소스에 담긴 ID 및 패스워드와 비밀 정보들이 누설될 가능성이 있음

### 6.4.18 TE

리스폰스로 받을 수 잇는 전송 코딩의 형식과 상대적인 우선 순위 전달

전송 코딩에 적용, Trailer를 동반하는 청크 전송 인코딩 형식 지정 가능 → 이 경우 TE: trailers

### 6.4.19 User-Agent

리퀘스트를 생성한 브라우저와 유저 에이전트의 이름 등을 전달하기 위한 필드

## 6.5 리스폰스 헤더 필드

서버 측으로 부터 클라이언트 측으로 송신되는 리스폰스 메시지에 적용된 헤더

리스폰스의 부가 정보나 서버의 정보, 클라이언트에 부가 정보 요구 등을 나타냄

### 6.5.1 Accept-Ranges

> Accept-Ranges: bytes
>

서버가 리소스의 일부분만 지정해서 취득할 수 있는 Range 리퀘스트를 접수할 수 있는지 여부 전달

지정 가능한 필드 값 2개, 수신 가능한 경우 “bytes”, 수신 불가능한 경우 “none”

### 6.5.2 Age

> Age: 600
>

얼마나 오래 전에 오리진 서버에서 리스폰스가 생성되었는지 전달, 필드 값의 단위 → 초

프록시가 리스폰스 생성 → Age 헤더 필드 필수

### 6.5.3 ETag

엔티티 태그라고 불리며 일의적으로 리소스를 특정하기 위한 문자열 전달

서버는 리소스마다 ETag 값을 할당, 리소스 갱신되면 ETag 값도 갱신할 필요 있음

특별한 룰이 정해져있지 않고 서버에 따라 다양한 ETag 값 할당

리소스 URI는 같아도 ETag에 다라 달라짐

**강력한 ETag 값과 약한 ETag 값**

1) 강한 ETag 값

엔티티가 아주 조금 다르더라도 반드시 값이 변화함

2) 약한 ETag 값

리소스가 같다는 것만을 나타냄, 의미가 다른 리소스로 그 차이가 있는 경우에만 ETag 값 변화, 앞부분에 W/가 붙음

### 6.5.4 Location

리스폰스 수신자에 대해서 Request-URI 이외의 리소스 액세스를 유도하는 경우에 사용

“3xx: Redirection” 리스폰스에 대해 리다이렉트 처의 URI를 기술

Location 헤더 필드를 포함한 리스폰스를 받으면 강제로 리다이렉트 하는 곳의 리소스에 액세스를 시도

### 6.5.5 Proxy-Authenticate

프록시 서버에서의 인증 요구를 클라이언트에 전달

클라이언트와 프록시 사이에서 인증이 이루어짐

클라이언트와 서버의 경우 → WWW-Authorization 헤더 필드와 같은 역할

### 6.5.6 Retry-After

> Retry-After: 120
>

클라이언트가 일정 시간 후에 리퀘스트를 다시 시행해야 하는지 전달

상태 코드 503 Service Unavailable 리스폰스나 3xx Redirect 사용

값으로는 날짜, 리스폰스 이후의 몇 초를 지정 가능

### 6.5.7 Server

서버에 설치되어 있는 HTTP 서버의 소프트웨어를 전달

버전이나 옵션에 대해서도 기재하는 경우 있음

### 6.5.8 Vary

캐시를 컨트롤하기 위해 사용

오리진 서버가 프록시 서버에 로컬 캐시를 사용하는 방법에 대한 지시 전달

오리진 서버로부터 Vary에 지정되었던 리스폰스를 받아들인 프록시 서버는 이후 캐시도니 때의 리퀘스트와 같은 Vary에 지정되어 있는 헤더 필드를 가진 리퀘스트에 대해서만 캐시 반환 가능

### 6.5.9 WWW-Authenticate

HTTP 액세스 인증에 사용되는데 Request-URI에 지정했던 리소스에 적용할 수 있는 인증 스키마와 파라미터를 나타내는 challenge를 전달

상태 코드 401(Unauthorized) 리스폰스 반듸 포함

## 6.6 엔티티 헤더 필드

리퀘스트 메시지와 리스폰스 메시지에 포함된 엔티티에 사용되는 헤더로 콘텐츠의 갱신 시간 같은 엔티티에 관한 정보 포함

### 6.6.1 Allow

> Allow: GET, HEAD
>

Request-URI에 지정된 리소스가 제공하는 메소드의 일람 전달

서버가 받을 수 없는 메소드를 수신한 경우 상태코드 405 Method Not Allowed 리스폰스와 함께 수신 가능한 메소드의 일람을 기술한 Allow 헤더 필드 반환

### 6.6.2 Content-Encoding

서버가 엔티티 바디에 대해서 실시한 콘텐츠 코딩 형식 전달

- 콘텐츠 코딩 ⇒ 엔티티 정보가 누락되지 않도록 압축할 것을 지시
- Gzip, Compress, Deflate, identity

### 6.6.3 Content-Language

엔티티 바디에 사용된 자연어를 전달

### 6.6.4 Content-Length

엔티티 바디 크기(단위 bytes)를 전달

엔티티 바디에 전송 코딩이 실시된 경우 Content-Length 헤더 필드 사용해서는 안됨

### 6.6.5 Content-Location

메시지 바디에 대응하는 URI 전달

- 메시지 바디로 반환된 리소스의 URI를 나타냄

### 6.6.6 Content-MD5

메시지 바디가 변경되지 않고 도착했는지 확인하기 위해 MD5 알고리즘에 의해서 생성된 값을 전달

메시지 바디에 MD5 알고리즘을 적용해서 얻은 128비트의 바이너리 값에 Base64 인코딩을 한 결과를 필드 값에 기록

→ HTTP 헤더에는 바이너리 값 기록 불가해서 Base64로 인코딩

유효성 확인 위해 수신한 클라이언트 측에서 메시지 바디에 같은 MD5 알고리즘 실행

→ 도출한 값과 필드 값을 비교하여 메시지 바디가 올바른지 여부 알 수 있음

우발적으로 콘텐츠가 변경되어 버린 사실을 알 수 있지만 악의를 가진 변조는 검출할 수 없음

→ 콘텐츠를 변조하면 Content-MD5도 재계산해서 변조 가능하기 때문

### 6.6.7 Content-Range

범위를 지정해서 일부분만을 리퀘스트하는 Range 리퀘스트에 대해서 리스폰스 할 때에 사용

리스폰스로 보낸 엔티티가 어느 부분에 해당하는가를 전달

필드 값 → 현재 보내고 있는 곳을 바이트로 지정한 범위와 전체 사이즈 기록

### 6.6.8 Content-Type

엔티티 바디에 포함되는 오브젝트의 미디어 타입 전달

필드 값 → “타입/서브 타입”

Charset 파라미터 → “iso-8859-1”, “euc-kr” 등의 문자셋 지정

### 6.6.9 Expires

리소스의 유효 기한 날짜 전달

캐시 서버가 Expires 헤더 필드를 포함한 리소스를 수신한 경우 → 필드 값으로 지정된 날짜까지 리스폰스의 복사본을 유지하고 리퀘스트에는 캐시로 응답

지정날짜 지난 경우 → 리퀘스트가 온 단계에서 오리진 서버에 리소스 얻으러 감

오리진 서버가 캐시 서버에 캐시되는 것을 원하지 않는 경우 → Date 헤더 필드의 필드 값과 같은 날짜로

Cache-Control 헤더 필드에 max-age 디렉티브 지정되어 있는 경우 → Expires 헤더 필드보다 max-age 디렉티브의 지정 우선

### 6.6.10 Last-Modified

리소스가 마지막으로 갱신되었던 날짜 정보를 전달

Request-URI가 지정된 리소스가 갱신되었던 날짜 기본 전달, 동적인 데이터 다룰 경우 그 데이터의 최종 갱신 날짜가 전달

## 6.7 쿠키를 위한 헤더 필드

**쿠키**

- 유저 식별과 상태 관리에 사용되고 있는 기능
- 웹 사이트가 유저의 상태 관리 위해 웹 브라우저 경유로 유저의 상태를 관리하기 위해서 웹 브라우저 경유로 유저의 컴퓨터 상에 일시적으로 데이터를 기록해 두고, 다음에 그 유저가 웹 사이트에 액세스 해 왔을 때 지난번에 발행한 쿠키를 송신받을 수 있음
- 쿠키 호출 시 쿠키의 유효 기한, 송신지의 도메인, 경로, 프로토콜 등을 체크하는 것이 가능 → 데이터 도난 당할 일 없음

**쿠키의 사양서**

- 넷스케이프사에 의한 사양
  - 쿠키를 고안한 넷스케이프 커뮤니케이션스 사의 사양
  - 현재 널리 보급되어 잇는 쿠키 방식의 근원
- RFC2109
  - 쿠키 사양의 표준화를 시험해 보기 위해서 정리된 규격
  - 현재는 사용되지 않음
- RFC2965
  - 인터넷 익스플로러와 넷스케이프 내비게이터의 서로 다른 규격 때문에 일어난 브라우저 전쟁에 종지부를 찍기 위해 만들어짐
  - 실제로 거의 사용되지 않음
- RFC6264
  - 넷스케이프사에 의한 사양을 디 펙토 스탠다드(?)로서 쿠키의 사양을 재정의한 것
  - 현재 가장 잘 사용되고 있는 쿠키의 사양 → 넷스케이프 사의 사양을 근간으로 확장

### 쿠키를 위한 헤더 필드

### 6.7.1 Set-Cookie

> Set-Cookie: status-enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; ⇒path=/:domain=.hack.jp;
>

서버가 클라이언트에 대해서 상태 관리를 시작할 때 다양한 정보를 전달

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/203d6d84-3936-4265-836e-c5aa6af877e9/5e7e929a-efbe-41d6-aca9-cda0c26e7b0d/Untitled.jpeg)

<Set-Cookie 필드 속성>

**1) Expires 속성**

브라우저가 쿠리를 송출할 수 있는 유효 기간 지정 가능

속성 생략 시 ⇒ 브라우저 세션이 유지되고 있는 동안만 유효(브라우저 애플리케이션을 닫을 때까지)

한번 서버에 송출한 클라이언트 쿠키는 서버에서 명시적으로 삭제 안됨

유효 기간이 지났다면 쿠키를 덮어 씀 → 실질적으로 클라이언트 측의 쿠키 삭제하는 것임

**2) Path 속성**

쿠키를 송출하는 범위를 특정 디렉토리에 한정할 수 있음

이 지정을 피하는 방법이 있어서 보안 효과 기대 못함

**3) Domain 속성**

지정된 도메인 명은 후방 일치가 됨

여러 도메인에 대해서 쿠키를 송출하는 경우를 제외하고 domain 속성은 지정하지 않는 쪽이 안전

**4) Secure 속성**

웹 페이지가 HTTPS 에서 열렸을 때만 쿠키 송출을 제한하기 위해 지정

> Set-Cookie: name=value; secure
>

secure 속성을 생략한 경우 HTTP와 HTTPS에서도 쿠키 반송

**5) HttpOnly 속성**

자바스크립트를 경유해서 쿠키를 취득하지 못하도록 하는 쿠키의 확장 기능

크로스 사이트 스크립팅(XSS)으로부터 쿠키의 도청을 막는 것을 목적으로 하고 있음

> Set-Cookie: name=value; HttpOnly
>

이 경우 통상 웹 페이지 내에서 쿠키를 읽어들이는 것 가능 but, HttpOnly 속성 부여된 쿠키는 Javascript에서는 읽어들일 수 없음

독자적으로 확장한 기능이자만 현재 주요한 브라우저에서는 거의 모두 대응, XSS 자체를 막는 것은 아님

### 6.7.2 Cookie

> Cookie: status=enable
>

클라이언트가 HTTP의 상태 관리 지원을 원할 때 서버로부터 수신한 쿠키를 이후의 리퀘스트에 포함해서 전달

쿠키를 여러 개 수신하고 있을 때에는 쿠키를 여러 개 보내는 것도 가능

## 6.8 그 이외의 헤더 필드

HTTP 헤더 필드는 독자적으로 확장 가능

웹 서버와 브라우저의 기능에 다양한 독자적인 헤더 필드 존재

### 6.8.1 X-frame-Option

다른 웹 사이트의 프레임에서 표시를 제어하는 HTTP 리스폰스 헤더

클릭 재킹(click jacking)이라는 공격을 막는 것을 목적으로 함

필드 값

- DENY(거부)
- SAMEORIGIN
  - Top-level-browsing-context가 일치한 경우에만 허가

모든 웹 서버에서 설정해 두는 것이 바람직

### 6.8.2 X-XSS-Protection

크로스 사이트 스크립팅(XSS) 대책으로서 브라우저의 XSS 보호 기능을 제어하는 HTTP 리스폰스 헤더

필드 값

- 0
  - XSS 필터를 무효로 함
- 1
  - XSS 필터를 유효로 함

### 6.8.3 DNT

Do Not Track(DNT)

개인 정보 수집을 거부하는 의사를 나타내는 HTTP 리퀘스트 헤더

트래킹의 거부 의사를 나타내기 위한 방법 중 하나

필드 값

- 0: 트래킹 동의
- 1: 트래킹 거부

DNT 헤더 필드의 기능이 유효성을 유지하기 위해서는 웹 서버에서 DNT를 지원해야 할 필요가 있음

### 6.8.4 P3P

웹 사이트 상의 프라이버시 정책에 P3P(The Platform for Privacy Preferences) 사용

프로그램이 읽을 수 있는 형태로 나타내기 위한 HTTP 리스폰스 헤더

P3P 설정 순서

- 수순-1: P3P 정책 작성
- 수순-2: P3P 정책 참조 파일을 작성해서 “/w3c/p3p.xml”에 배치
- 수순-3: P3P 정책으로부터 콤팩트 정책을 작성하고 HTTP 리스폰스 헤더에 출력
