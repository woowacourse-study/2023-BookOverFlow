# Chapter 06 HTTP 헤더

## 6.1 HTTP 메시지 헤더
> HTTP 프로토콜의 리퀘스트와 리스폰스에는 반드시 메시지 헤더가 포함되어 있는데 메시지 헤더에는 클라이언트나 서버가 리퀘스트나 리스폰스를 처리하기 위한 정보가 들어 있다.

여러 요소가 있지만 가장 다양한 정보를 가지고 있는 것이 HTTP 헤더 필드이다.헤더 필드는 리퀘스트와 리스폰스 양쪽 모두 존재하고 HTTP 메시지에 관한 정보를 가지고 있다.
## 6.2 HTTP 헤더 필드
### 6.2.1 HTTP 헤더 필드는 중요한 정보를 전달한다
> HTTP 헤더 필드는 HTTP 메시지를 구성하는 요소의 하나이다. 헤더 필드는 HTTP 프로토콜 중에서 클라이언트와 서버간의 통신에서 리퀘스트에도 리스폰스에도 사용되고 있고, 부가적으로 중요한 정보를 전달하는 역할을 담당하고 있다.
### 6.2.2 HTTP 헤더 필드의 구조
> 헤더 필드는 헤더 필드 명과 필드 값으로 구성되어 있고 콜론 `:` 으로 나뉘어져 있다.

> `헤더 필드 명 : 필드 값`

예를들어, 메시지 바디의 오브젝트의 타입을 가리키는 `Content-Type` 이라는 HTTP 헤더 필드가 포함되어 있다.

> `Content-Type:text/html`
### 6.2.3 4종류의 HTTP 헤더 구조
HTTP 헤더 필드는 용도에 따라 다음과 같이 4종류로 분류된다.

#### 일반적 헤더 필드(General Header Fields)
> 리퀘스트 메시지와 리스폰스 메시지 둘 다 사용되는 헤더

#### 리퀘스트 헤더 필드(General Header Fields)
> 클라이언트 측에서 서버 측으로 송신된 리퀘스트 메시지에 사용되는 헤더로 리퀘스트의 부가적 정보와 클라이언트의 정보, 리스폰스의 콘텐츠에 관한 우선 순위 등을 부가한다.

#### 리스폰스 헤더 필드(Response Header Fields)
> 서버 측에서 클라이언트 측으로 송신한 리스폰스 메시지에 사용되는 헤더로 리스폰스의 정보와 서버의 정보, 클라이언트의 추가 정보 요구 등을 부가한다.

#### 엔티티 헤더 필드(Entity Header Fields)
> 리퀘스트 메시지와 리스폰스 메시지에 포함된 엔티티에 사용되는 헤더로 콘텐츠 갱신 시간 등의 엔티티에 관한 정보를 부가한다.

### 6.2.4 HTTP/1.1 헤더 필드 일람

#### 일반 헤더 필드
![](https://github-production-user-asset-6210df.s3.amazonaws.com/22425650/279905031-658f1de3-2a2d-4d0d-bb71-7192e6bca784.png)

#### 리퀘스트 헤더 필드
![](https://github.com/woowacourse-teams/2023-yigongil/assets/22425650/d7bebe14-6492-4ba9-9bc0-65d7592a4837)
![](https://github.com/woowacourse-teams/2023-yigongil/assets/22425650/ff32bf2d-db01-4074-8afd-d888d030554c)
### 6.2.5 HTTP/1.1 이외의 헤더 필드
> HTTP에서 교환되는 HTTP 헤더 필드가 RFC2616에서 정의된 47종류만 있는 것은 아니다.
> 비표준 헤더 필드는 RFC4229 HTTP Header Field Registrations에 정리되어 있다.
### 6.2.6 End-to-end 헤더와 Hop-by-hop 헤더
>HTTP 헤더 필드는 캐시와 비캐시 프록시의 동작을 정의하기 위해서 두 가지 카테고리로 분류되어 있다.

#### End-to-end 헤더
> 리퀘스트나 리스폰스의 최종 수신자에게 전송된다.
> 캐시에서 구축된 리스폰스 중 보존되야 하고, 다시 전송되지 않으면 안되도록 되어 있다.

#### Hop-by-hop 헤더
> 한 번 전송에 대해서만 유효하고 캐시와 프록시에 의해서 전송되지 않는 것도 있다.

hop-by-hop 헤더에는 다음과 같은 것이 있다. 이것 외엔 전부 End-to-end 헤더에 분류된다.
- Connection
- keep-Alive
- Proxy-Authenticate
- Proxy-Autorization
- Trailer
- TE
- Trasfer-Encoding
- Upgrade
## 6.3 HTTP/1.1 일반 헤더 필드
### 6.3.1 Cache-Control
> 디레티브로 불리는 명령을 사용하여 캐싱 동작을 지정한다.

#### Public 디렉티브
> `Cache-control: public`

다른 유저에게도 돌려줄 수 있는 캐시를 해도 좋다는 것을 명시적으로 나타냄

#### Private 디렉티브
> `Cache-Control: private`

리스폰스는 특정 유저만을 대상으로 하고 있다는 것을 나타냄 public과 반대임

#### no-cache 디렉티브
> `Cache-Control: no-cache`

캐시로부터 오래된 리소스가 반환되는 것을 막기 위해 사용된다. 캐시된 리스폰스를 클라이언트가 받아 들이지 않음을 나타낸다,. 즉, 중간 캐시 서버가 오리진 서버까지 리퀘스트를 전송해야 한다.
캐시 서버는 리소스를 저장할 수가 없다. 오리진 서버 캐시 서버가 이후의 리퀘스트에서 리소스의 유효성을 재확인하지 않고는 그 리스폰스를 사용하지 못한다.

> `Cache-Control: no-cache=Location`

지정된 헤더 필드만 캐시할 수 없다. 즉, 지정된 헤더 필드 이외에는 캐시하는 것이 가능하다. 이 파라미터는 리스폰스 디렉티브만 사용할 수 있다.

### 캐시로 보존 가능한 것을 제어하는 디렉티브
#### no-store 디렉티브
> `Cache-Control: no-store`

리퀘스트(그와 대응되는 리스폰스) 혹은 리스폰스에 기밀 정보가 포함되어 있음을 나타낸다.
그렇기 때문에 캐시는 리퀘스트, 리스폰스의 일부분을 로컬 스토리지에 보존해서는 안 되도록 지정한다.

### 캐시 기한이나 검증을 지정하는 디렉티브
#### s-maxage 디렉티브
> `Cache-Control: s-maxage=604800 (단위 : 초)`

`max-age` 디렉티브와 동일하지만 다른 점은 여러 유저가 이용 할 수 있는 공유 캐시 서버에만 적용된다. 즉, 같은 유저에 반복해서 리스폰스를 반환하는 캐시 서버는 무효한 디렉티브이다.

#### max-age 디렉티브
> `Cache-Control: max-age=604800 (단위 : 초)`

지정되었던 값 보다 새로운 경우에는캐시되었던 리소스를 받아들일 수 있다. 또한 지정한 값이 0이면 캐시 서버는 리퀘스트를 항상 오리진 서버에 넘길 필요가 있다.

#### min-fresh 디렉티브
> `Cache-Control: min-fresh=60 (단위 : 초)`

캐시된 리소스가 적어도 지정된 시간은 최신 상태의 것을 반환하도록 캐시 서버에 요구한다.

### max-stale 디렉티브
>`Cache-control: max-stale=3600 (단위 : 초)`

캐시된 리소스의 유효 기한이 끝났더라도 받아들일 수 있음을 나타낸다.
디렉티브에 값이 지정되어 있지 않는 경우는 클라이언트는 아무리 시간이 경과했더라도 리스폰스를 받아 들인다.

#### only-if-cached 디렉티브
>`Cache-Control: only-if-cached`

클라이언트는 캐시 서버에 대해서 목적한 리소스가 로컬 캐시에 있는 경우만 리스폰스를 반환하도록 요구한다. 즉, 캐시 서버에서 리스폰스의 리로드와 유효성을 재확인하지 않도록 요구한다. 캐시 서버가 로컬 캐시로부터 응답할 수 없는 경우엔 `504 Gateway Timeout` 상태를 반환한다.

#### must-revalidate 디렉티브
>`Cashe-Control: must-revalidate

리스폰스의 캐시가 현재도 유효한지 아닌지의 여부를 오리진 서버에 조회를 요구한다. 프록시가 오리진 서버에 도달할 수 없고, 리소스를 다시 요구할 수 없는 경우에는 캐시는 클라이언트에 504를 반환한다.

#### Proxy-ravalidate 디렉티브
>`Cashe-Control: proxy-revalidate

모든 캐시 서버에 대해서 이후의 리퀘스트로 해당 리스폰스를 반환할 때는 반드시 유효성 재확인을 하도록 요구한다.

#### no-transform 디렉티브
>`Cashe-Control: no-transform`

리퀘스트와 리스폰스의 어느 쪽에 있어서도 캐시가 엔티티 바디의 미디어 타입을 변경하지 않도록 지정한다. 이렇게 해서 캐시 서버 등에 의해서 이미지가 압축되는 것을 방지한다.

### Cache-Control 확장
#### cache-extension 토큰
>`Cashe-Control: private, community="UCI"`

Cache-Control 헤더 필드는 cache-extension 토큰을 사용하여 디렉티브를 확장할 수 있다.
### 6.3.2 Connection
> Connection 헤더 필드의 두 가지 역할
#### 1. 프록시에 더 이상 전송하지 않는 헤더 필드를 지정
> Connection: 더 이상 전송하지 않는 헤더 필드 명

클라이언트의 리퀘스트 혹은 서버의 리스폰스에서 Connection 헤더 필드를 사용하며 프록시 서버에 더 이상 전송하지 않는 헤더필드를 지정할 수 있다.
#### 2. 지속적 접속 관리
> `Connection: Close`

HTTP/1.1에서는 지속적 접속이 디폴트로 되어있다. 그래서 리퀘스트를 송신했던 클라이언트는 접속이 계속 유지되면서 추가 리퀘스트를 송신하도록한다. 서버 측에서명시적으로 접속을 끊고 싶을 경우엔 위와 같이 Connection 헤더 필드에 Close라고 지정 한다.

>`Connection: Keep-Alive`

HTTP/1.1 이전의 버전은 지속적 접속이 디폴트가 아니었다. 그래서 오래된 버전의 HTTP에서 지속적 접속을 하고 싶은 경우엔 Connection 헤더 필드에 Keep-Alive라고 지정해야한다.
### 6.3.3 Date
> HTTP 메시지를 생성한 날짜를 나타냄
> `Date: Tue, 03 Jul 2012 04:40:59 GMT`
### 6.3.4 Pragma
> `Paragma: no-cache`

일반 헤더 필드이지만 클라이언트의 리퀘스트에서만 사용된다. 클라이언튼 캐시된 리소스의 리스폰스를 원하지 않음을 모든 중간 서버에 알리기 위해 사용된다.
### 6.3.5 Trailer
> 메시지 바디의 뒤에 기술되어 있는 헤더 필드를 미리 전달할 수 있다. HTTP/1.1에 구현되어 있는 청크 전송 인코딩을 사용하고 있는 경우에 사용가능하다.
### 6.3.6 Transfer-Encoding
> 메시지 바디의 전송 코딩 형식을 지정하는 경우에 사용된다.
> `Trasnfer-Encoding: chunked`
### 6.3.7 Upgrade
> HTTP 및 다른 프로토콜의 새로운 버전이 통신에 이용되는 경우에 사용된다.
> Upgrade 헤더 필드에 의해서 업그레이드 되는 대상은 클라이언트와 인접한 서버 사이뿐이기 때문에 Upgrade 헤더 필드를 사용하는 경우엔 Connection:Upgrade도 지정할 필요가 있다.
### 6.3.8 Via
> 클라이언트와 서버 간의 리퀘스트 혹은 리스폰스 메시지의 경로를 알기 위해서 사용된다. 프록시 혹은 게이트웨이는 자신의 서버 정보를 Via 헤더 필드에 추가한 뒤에 메시지를 전송한다. Via 헤더 필드는 전송된 메시지의 추적과 리퀘스트 루프의 회피 등에 사용되기 때문에 프록시를 경유하는 경우엔 반드시 부가할 필요가 있다.
### 6.3.9 Warning
> Warning 헤더는 HTTP/1.0 리스폰스 헤더가 HTT/1.1에서 변경된 것으로, 리스폰스에 관한 추가 정보를 전다한다. 기본적으로 캐시에 관한 문제의 경고를 유저에 전달한다.
> `Warning: 113 gw.hackr.jp:8080 "Heuristic expiration"Tue, 03 Jul => 2012 05:09:44 GMT`
> 다음 과 같은 헤더 형식을 따른다.
> `Warning: [경고코드][경고한 호스트:포트 번호]"[경고문]"([날짜])`

다음과 같이 HTTP/1.1에는 7개의 경고 코드가 존재한다.
1. 110 - Reponse is state - 프록시가 유효기한이 지난 리소스를 반환했다.
2. 111 - Revalidation failed - 프록시가 리소스의 유효성 재확인에 실패했다.(서버에 도달할 수 없는 등)
3. 112 - Disconnection operation - 프록시가 네트워크로부터 고의로 끊겨 있다.
4. 113 - Heuristic expiration - 리스폰스가 24시간이상 경과하고 있는 경우(캐시의 유효기간을 24시간 이상으로 설정하고 있는 경우)
5. 199 - Miscellaneous warning - 임의의 경고문
6. 214 - Transformation applied - 프록시가 인코딩과 미디어 타입 등에 대응해서 무언가의 처리를 한 경우
7. 299 - Miscellaneous persistent warning - 임의의 경고문
