# 2장

## HTTP는 클라이언트와 서버 간에 통신을 한다
- HTTP는 클라이언트와 서버 간에 통신을 한다.
- 한 번 통신을 할 때마다 반드시 어느 한 쪽은 클라이언트가 되고 다른 한 쪽은 서버가 된다.

<br>

## 리퀘스트와 리스폰스를 교환하여 성립
- HTTP는 클라이언트로부터 리퀘스트가 송신되며, 그 결과가 서버로부터 리스폰스로 되돌아온다.
- **통신의 시작은 클라이언트다.** 서버는 리퀘스트를 받지 않고는 리스폰스를 송신하는 일은 없다.

<br>

## HTTP는 상태를 유지하지 않는 프로토콜
- HTTP는 상태를 계속 유지하지 않는 스테이트리스(Stateless) 프로토콜이다.
- 리퀘스트와 리스폰스를 교환하는 동안에 상태를 관리하지 않는다.
- HTTP 프로토콜 레벨에서는 이전에 보냈던 리퀘스트나 이전에 되돌려는 리스폰스를 기억하고 있지 않는다.
- HTTP에서는 새로운 리퀘스트가 보내질 때 마다 새로운 리스폰스가 생성된다.
- 이렇게 간단하게 만들어진 이유는 **많은 데이터를 빠르고 확실하게 처리하는 범위성을 확보**하기 위함이다.
- 스테이트리스 특성만으로는 처리하기 어려운 일이 생기게 되었는데 예를 들면 로그인이 필요할 때다.
  - 로그인을 한 경우 다른 페이지로 이동해도 로그인 상태를 유지해야 할 필요가 있다.
  - HTTP/1.1은 상태를 유지하지 않는 프로토콜이다.
  - 상태를 유지하기 위해 쿠키라는 기술이 도입되었다.

<br>

## 리퀘스트 URI로 리소스를 식별
- HTTP는 URI를 사용하여 인터넷 상의 리소스를 지정한다. 이를 통해 인터넷 상의 어떤 장소에 있는 리소스라도 호출할 수 있다.
- 클라이언트는 리소스를 호출할 때 마다 리퀘스트를 송신할 때 리퀘스트 안에 URI를 리퀘스트 URI라고 불리는 형식으로 포함해야 할 필요가 있다.
  - 모든 URI를 리퀘스트 URI에 포함하는 경우
    ```
    GET http://hackr.jp/index.html HTTP/1.1
    ```
  - Host 헤더 필드에 네트워크 로케이션을 포함하는 경우
    ```
    GET /index.html HTTP/1.1
    Host: hackr.jp
    ```

<br>

## 서버에 임무를 부여하는 HTTP 메소드
- GET: 리소스 획득
  - 리퀘스트 URI로 식별된 리소스를 가져올 수 있도록 요구한다.
  - 가져올 리소스 내용은 지정된 리소스를 서버가 해석한 결과다.
- POST: 엔티티 전송
  - 엔티티를 전송하기 위해 사용한다.
  - GET으로도 엔티티를 전송할 수 있지만, 자주 사용하지 않고 일반적으로 POST를 사용한다.
  - POST는 GET과 기능이 비슷하지만 리스폰스에 의한 엔티티를 획득하는 것만이 목적은 아니다.
- PUT: 파일 전송
  - 파일을 전송하기 위해 사용한다.
  - FTP에 의한 파일 업로드와 같이, 리퀘스트 중 포함된 엔티티를 리퀘스트 URI로 지정한 곳에 보존하도록 요구한다.
  - HTTP/1.1 PUT 자체에는 인증 기능이 없어 누구든 파일을 업로드 할 수 있다는 보안 상의 문제가 있어 일반적인 웹 사이트에서는 사용되지 않는다.
- HEAD: 메시지 헤더 취득
  - GET과 같은 기능이지만 메시지 바디는 돌려주지 않는다.
  - URI 유효성과 리소스 갱신을 확인하는 목적 등으로 사용된다.
- DELETE: 파일 삭제
  - 파일을 삭제하기 위해 사용한다.
  - PUT 메소드와는 반대로 동작하며 리퀘스트 URI로 지정된 리소스의 삭제를 요구한다.
  - HTTP/1.1 PUT 자체에는 인증 기능이 없어 누구든 파일을 삭제 할 수 있다는 보안 상의 문제가 있어 일반적인 웹 사이트에서는 사용되지 않는다.
- OPTIONS: 제공하고 있는 메소드의 문의
  - 리퀘스트 URI로 지정한 리소스가 제공하고 있는 메소드를 조사하기 위해 사용한다.
- TRACE: 경로조사
  - Web서버에 접속해 자신에게 통신을 되돌려 받는 루프백을 발생시킨다.
  - 클라이언트는 해당 메서드를 사용하여 리퀘스트를 보낸 곳에 어떤 리퀘스트가 가공되어 있는지 조사할 수 있다.
  - 거의 사용되지 않으며 크로스 사이트 트레이싱(XST)과 같은 공격을 일으키는 보안 상의 문제도 있기 때문에 보통은 사용되지 않는다.

<br>

## 지속 연결로 접속량을 절약
- HTTP 통신을 한 번 할 때마다 TCP에 의해 연결과 종료를 할 필요가 있었다.
- 초기 당시 통신에서는 작은 사이즈의 텍스트를 보내는 정도였기 떄문에 이와 같은 방법이 문제가 없었다.
- 하나의 HTML에 여러 이미지가 포함되어 있는 경우 브라우저를 사용해서 리퀘스트를 하면 HTML 문서에 포함되어 있는 이미지를 획득하기 위해서 여러 리퀘스트를 송신해야 한다.
- 이 과정에서 쓸모없는 TCP 연결과 종료가 발생하기 때문에 통신량이 늘어나게 된다.

<br>

- **지속 연결**(Persistent Connections)
  - TCP 연결 문제를 해결하기 위해 이라는 방법을 고안했다.
  - 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지한다.
  - 지속 연결을 통해 TCP 커넥션의 연결과 종료를 반복하는 오버헤드를 줄일 수 있고, 서버에 대한 부하가 줄어든다.
  - 오버헤드를 줄인 만큼 HTTP 리퀘스트와 리스폰스가 빠르게 완료되기 때문에 웹 페이지를 더 빨리 표시할 수 있다.
- 지속 연결은 여러 리퀘스트를 보낼 수 있도록 **파이프라인화**를 가능하게 한다.
  - 파이프라인에 의해 리스폰스를 기다리지 않고 바로 다음 리퀘스트를 보낼 수 있다.

> 속도의 빠르기 비교  
파이프라인화 > 지속 연결 > 개별 연결

<br>

## 쿠키를 사용한 상태 관리
- HTTP는 스테이트리스(Stateless) 프로토콜이기 때문에, 이전에 교환한 내용을 기억하지 않는다.
- 스테이트리스 프로토콜에도 이점이 있다.
  - 상태를 유지하지 않는다는 점에서 서버의 CPU나 메모리 같은 리소스의 소비를 억제할 수 있다.
  - 단순한 프로토콜이기 때문에 다양한 곳에서 이용할 수 있다.
- 쿠키를 도입하여 상태를 관리한다.

<br>

- 쿠키는 리퀘스트와 리스폰스에 쿠키 정보를 추가해서 클라이언트의 상태를 파악하기 위한 시스템이다.
- 클라이언트가 같은 서버로 리퀘스트를 보낼 때 자동으로 쿠키 값을 넣어서 송신한다.
- 서버는 클라이언트가 보낸 쿠키를 통해 어느 클라이언트가 접속했는지 체크하고 서버의 기록을 확인하여 이전의 상태를 알 수 있다.
  - 쿠키를 가지지 않은 상태에서의 리퀘스트는 다음과 같다.  
  ```mermaid
  flowchart LR
    Client -->|Request| Server
    Server[Server: 누군지 모르겠으니 쿠키를 발행해야지] -->|Response + Cookie| Client

  ```
  - 쿠키를 가진 상태에서의 리퀘스트는 다음과 같다.  
  ```mermaid
  flowchart LR
    Client -->|Request + Cookie| Server[Server: 전에 왔던 녀석이다]
    Server -->|Response| Client

  ```

## 궁금한 점
> 왜 이름이 쿠키일까?
- 쿠키라는 이름은 유닉스 프로그래머들이 값을 변경하지 않고 주고 받는 데이터 패킷의 이름인 매직 쿠키에서 유래했다. 
- 매직 쿠키도 격언이나 운세가 적힌 쪽지가 속에 들어있는 과자인 포춘 쿠키에서 나온 이름이다. 
- 단어, 메시지, 정보가 들어있는 작은 조각이 HTTP 쿠키라고 생각해보면 바로 이해가 된다.