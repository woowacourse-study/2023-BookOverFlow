# Chapter 02 간단한 프로토콜 HTTP

## 2.1 HTTP는 클라이언트와 서버 간에 통신을 한다

TCP/IP에 있는 다른 많은 프로토콜과 마찬가지로 HTTP도 클라이언트와 서버간에 통신을 한다.
텍스트와 이미지 등과 같은 리소스를 필요하다고 요구하는 쪽이 **클라이언트**가 되고 이러한 리소스를 제공하는 쪽이 **서버**가 된다.

HTTP를 사용하여 2대의 컴퓨터 간에 통신을 하는 경우 한 번 통신을 할 때마다 반드시 어느 한쪽은 클라이언트가 되고 나머지 한쪽이 서버가 된다.
경우에 따라서 서버와 클라이언트가 서로 바뀌는 경우가 있지만, 한 번 통신했을 때만 본다면 반드시 클라이언트와 서버의 역할이 정해져있다.
HTTP는 서버와 클라이언트의 역할을 명확하게 구분하고 있다.
## 2.2 리퀘스트와 리스폰스를 교환하여 성립

HTTP는 클라이언트로부터 리퀘스트가 송신되며, 그 결과가 서버로부터 리스폰스로 되돌아 온다. 반드시 클라이언트측으로부터 통신이 시작되고, 서버 측은 리퀘스트를 받지 않고서는 리스폰스가 발생하는 일은 없다.

###  Request 송신
```
GET /index.html HTTP /1.1
Host: www.hackr.jp
```
- GET은 서버에 요구하는 종류를 나타내고 있으며 메소드라고 불린다.
- "/index.html"은 요구 대상인 리소스를 나타내고 있는데 리퀘스트 URI라고 한다
- "HTTP/1.1"은 클라이언트 기능을 식별하기 위한 HTTP 버전 번호이다.
- 여기서의 리퀘스트 내용은 HTTP 서버 상에 있는 "/index.html"이라는 리소스가 필요하다는 리퀘스트이다.
- 리퀘스트 메시지는 메소드, URI, 프로토콜버전, 옵션 리퀘스트 헤더 필드와 엔티티로 구성되어 있다.

### Response 송신
```
HTTP /1.1 200 OK
Date: Tue, 10 Jul 2012 06:50:15 GMT
Content-Length: 362
Content-Type: text/html


<html>
...
```

- "HTTP/1.1"은 서버의 HTTP 버전을 나타냄
- "200 OK"는 리퀘스트의 ㄹ처리 결과를 나타내는 상태 코드와 설명
- 리스폰스가 발생한 일시를 나타내고 있는데, 헤더 필드라고 불리는 것중 하나
- 빈줄로 구분하고 그 아래에 있는 부분을 바디라고 불리는 리소스 본체가 된다.
- 기본적으로 리스폰스 메시지는 프로토콜 버전, 상태코드와 그 상태코드를 설명한 프레이즈, 옵션의 리스폰스 헤더 필드와 바디로 구성되어 있다.
## 2.3 HTTP는 상태를 유지하지 않는 프로토콜

HTTP는 상태를 계속 유지하지 않는 스테이트리스(stateless) 프로토콜이다.
HTTP 프로토콜 독자적으로, 리퀘스트와 리스폰스를 교환하는 동안에 상태를 관리하지 않는다.
HTTP 프로토콜은 전에 보냈던 리퀘스트나 되돌려준 리스폰스를 스스로 기억할 수 있는 구조가 아니다.
상태를 유지할 필요가 있을 땐 쿠키(Cookie)라는 기술을 사용하여 HTTP를 이용한 통신에서도 상태를 계속 유지할 수 있게한다.
## 2.4 리퀘스트 URI로 리소스를 식별

HTTP는 URI(Uniform Resource Identifiers)를 사용하여 인터넷 상의 리소스를 지정한다.
이 URI가 있는 덕분에 인터넷 상의 어떤 장소에 있는 리소스도 호출할 수 있다.
클라이언트는 리소스를 호출할 때 마다 리퀘스트를 송신할 때에 리퀘스트 안에 URI를 리퀘스트 URI라고 불리는 형식으로 포함해햐 할 필요가 있다.

리퀘스트 URI를 지정하는 방법은 여러 종류가 있다.
- 모든 URI를 리퀘스트 URI에 포함한다.
    - GET http://hackjr/index.html HTTP/1.1
- Host 헤더 필드에 네트워크 로케이션을 포함한다.
    - GET /index.html HTTP/ 1.1
      Host: hackr.jp
- 특정 리소스가 아닌 서버 자신에게 리퀘스트를 송신하는 경우에는 리퀘스트 URI에 \*을 지정할 수 있다.
    - OPTIONS \* HTTP1.1
## 2.5 서버에 임무를 부여하는 HTTP 메소드

-  GET: 리소스 획득
    - 리퀘스트 URI로 식별된 리소스를 가져올 수 있도록 요구한다.
- POST: 엔티티 전송
    - GET으로도 엔티티를 전송할 수 있지만, 자주 사용하지 않고 일반적으로 POST를 사용한다.
- PUT: 파일전송
    - 파일을 전송하기 위해서 사용된다.
    - 단 자체 인증 기능이 없어 누구든지 파일을 업로드 가능하다는 보안 상의 문제도 있어서 일반적인 웹 사이트에서는 사용되지 않는다.
- HEAD: 메시지 헤더 취득
    - GET과 같은 기능이지만 메시지 바디는 돌려주지 않는다.
    - URI 유효성과 리소스 갱신 시간을 확인하는 목적 등으로 사용한다.
- DELETE: 파일 삭제
    - 파일을 삭제하기 위해 사용된다.
    - PUT과 반대로 동작하며 리퀘스트 URI로 지정된 리소스의 삭제를 요구한다.
    - PUT고 마찬가지로 자체 인증 기능이 없어 일반적인 웹 사이트에서는 사용되고 있지 않다.
    - 인증 기능과 짝을 이루어 사용하기도 한다.
- OPTIONS: 제공하고 있는 메소드 문의
    - 리퀘스트 URI로 지정한 리소스가 제공하고 있는 메소드를 조사하기 위해 사용된다.
- TRACE: 경로조사
    - Web 서버에 접속해서 자신에게 통신을 되돌려 받는 루프백을 발생시킨다.
    - 리퀘스트를 보낼 때 Max-Forwards라는 헤더 필드에 수치를 포함시켜 서버를 통과할 때마다 그 수치를 줄여간다. 수치가 0이 되는 곳을 끝으로 200 OK 리스폰스를 되돌려 준다.
    - 클라이언트는 TRACE를 사용함으로써 리퀘스트를 보낸 곳에 어떤 리퀘스트가 가공되어 있는지 등을 조사할 수 있다.
    - 근데 보안 상의 문제도 있어서 보통 사용되진 않는다.
- CONNECT: 프락시에 터널링 요구
    - 프락시에 터널 접속 확립을 요함으로써, TCP 통신을 터널링 시키기 위해서 사용된다.
    - 주로 SSL이랑 TLS 등의 프로토콜로 암호화된 것을 터널링 시키기 위해서 사용되고 있다.

## 2.6 메소드를 사용해서 지시를 내리다

리퀘스트 URI로 지정한 리소스에 리퀘스트를 보내는 경우엔 메소드라고 불리는 명령이 있다.

- 메소드 - 설명 - 지원하고 있는 HTTP 버전
- GET - 리소스 취득 - 1.0 1.1
- POST - 엔티티 바디 전송 - 1.0 1.1
- PUT - 파일 전송 - 1.0 1.1
- HEAD - 메시지 헤더 취득 - 1.0 1.1
- DELETE - 파일 삭제 - 1.0 1.1
- OPTIONS - 지원하고 있는 메소드 문의 1.1
- TRACE - 경로 조사 - 1.1
- CONNECT - 프락시에 터널링 요구 - 1.1
- LINK - 리소스 간에 링크 관계를 확립 - 1.0
- UNLINK - 링크 관계 삭제 - 1.0
## 2.7 지속 연결로 접속량을 절약

HTTP 초기 버전에서는 HTTP 통신을 한 번 할 때마다 TCP에 의해 연결과 종료를 할 필요가 있었다.
리퀘스트를 보낼 때마다 매번 TCP 연결과 종료를 하게 되는 쓸모없는 일이 발생되어 통신량이 늘어나게 된다.

이러한 문제를 해결하기 위해 HTTP/1.1와 HTTP/1.0에서는 TCP 연결 문제를 해결하기 위해서 지속 연결(Persistence Connection)이라는 방법을 고안하였다.
지속 연결의 특징은 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지한다.

지속 연결을 함으로써 TCP 커넥션의 연결과 종료가 반복되는 오버헤드를 줄여주기 때문에 서버에 대한 부하가 경감된다. 또한 오버헤드를 줄인 만큼 HTTP 통신이 빠르게 완료되기 때문에 웹 페이지를 빨리 표시 할 수 있다.

지속연결은 여러 리퀘스트를 보낼 수 있도록 파이프라인(HTTP pipelineing)화를 가능하게 한다.
파이프라인화에 의해서 이전엔 리퀘스트 송신 후에 리스폰스를 수신할 때까지 기다린 뒤에 리퀘스트를 발행하던 것을, 리스폰스를 기다리지 않고 바로 다음 리퀘스트를 보낼 수 있다.
이로인해 여러 리퀘스트를 병행해서 보내는 것이 가능하기 때문에 일일이 리스폰스를 기다릴 필요가 없다.
## 2.8 쿠키를 사용한 상태 관리
HTTP가 스테이트리스(stateless) 프로토콜이라는 특징은 남겨둔 채, 이와 같은 문제를 해결하기 위해 쿠키라는 시스템을 도입하였다.
쿠키는 리퀘스트와 리스폰스에 쿠키 정보를 추가해서 클라이언트의 상태를 파악하기 위한 시스템이다.

1. 쿠키는 서버에서 리스폰스로 보내진 Set-Cookie라는 헤더 필드에 의해 쿠키를 클라이언트에 보존하게 된다.
2. 다음 번에 클라이언트가 같은 서버로 리퀘스트를 보낼 때, 자동으로 쿠키 값을 넣어서 송신한다.
3. 서버는 클라이언트가 보내온 쿠키를 확인해서 어느 클라이언트가 접속했는지 체크하고 서버 상의 기록을 확인하여 이전 상태를 알 수 있다.
