# 6장. CPU 스케줄링

**기계어 명령의 종류** 

CPU 내에서 수행되는 명령 : 예) Add 명령. 명령의 수행 속도가 매우 빠르다.

메모리 접근을 필요로 하는 명령: 예) Load명령 - 메모리에 있는 데이터를 CPU로 읽어들이는 명령, Store - CPU에서 계산된 값을 메모리에 저장하는 명령. 메모리를 저장하는 명령은 비록 CPU 내에서 수행되는 명령보다는 시간이 오래 소요되지만 비교적 짧은 시간에 수행 가능

위의 두 명령은 사용자 프로그램이 직접 실행할 수 있는 일반명령.

입출력을 동반하는 명령: 예) 키보드로부터 입력, 화면 출력. 입출력을 수반하는 명령은 오랜시간이 소요된다. 모든 입출력 명령은 특권 명령으로, 사용자 프로그램이 직접 수행할 수 없고 운영체제를 통해 서비스를 대행한다. 

</br>

**사용자 프로그램이 수행되는 과정**

**CPU 작업(CPU Burst)** 과 **I/O 작업(I/O Burst)** 작업의 반복으로 구성.

각 프로그램마다 CPU 버스트와 I/O 버스트가 차지하는 비율이 균일하지는 않다. 

</br>

**I/O 바운드 프로세스(I/O bound process)** 

I/O 요청이 빈번해 CPU 버스트가 짧게 나타나는 프로세스.

주로 사용자로부터 인터랙션을 게속 받아가며 프로그램을 수행시키는 대화형 프로그램이 해당.

</br>

**CPU 바운드 프로세스(CPU bound process)**

I/O 작업을 거의 수행하지 않아 CPU 버스트가 길게 나타나는 프로세스.

프로세스 수행의 상당 시간을 입출력 작업없이 CPU 작업에 소모하는 계산 위주의 프로그램이 해당된다. 

CPU 스케줄링은 이와 같이 CPU를 사용하는 패턴이 상이한 여러 프로그램이 동일한 시스템 내부에서 함께 실행되기 때문에 필요한 것이다. 프로세스의 CPU 버스트가 모두 균일한 경우에는 CPU 스케줄링을 하는 것이 큰 의미가 없지만, CPU 버스트가 균일하지 않은 다양한 프로그램들이 공존하므로 효율적인 CPU 스케줄링 기법이 필요하다. 

CPU 버스트가 짧은 프로세스는 대부분 대화형 작업이므로 빠른 서비스가 필요하다. 따라서 CPU 스케줄링을 할 때 CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 ㅅ용할 수 있도록 하는 스케줄링이 필요하다. 즉, I/O 바운드 프로세스의 우선순위를 높여주는 것이 바람직하다는 의미가 된다. 

</br>

## CPU 스케줄러

CPU 스케줄러는 준비 상태에 있는 프로세스들 중 어떠한 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드이다 .

### CPU 스케줄링의 방식

**비선점형(nonpreemptive) 방식** 

CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지는 CPU를 빼앗기지 않는 방법

예) 실행 상태에 있던 프로세스가 I/O 요청 등에 의해 봉쇄(blocked) 상태가 되는 경우

CPU에서 실행 상태에 있는 프로세스가 종료되는 경우 

</br>

**선점형(preemptive) 방식** 

프로세스가 CPU를 계속 사용하기를 원하더라도 강제로 빼앗을 수 있는 스케줄링 방법. CPU를 빼앗는 방법으로는 할당시간을 부여한 후 타이머 인터럽트를 발생시키는 방법이 대표적이다. 

예) 실행 상태에 있던 프로세스가 타이머 인터럽트 발생에 의해 준비 상태로 되는 경우

I/O 요청으로 봉쇄 상태에 있던 프로세스의 I/O 작업이 완료되어 인터럽트가 발생하고 그 결과 이 프로세스의 상태가 준비 상태로 되는 경우

</br>

## 디스패처

CPU 스케줄러가 어떤 프로세스에게 CPU를  할당해야 할지 결정하고 나면 선택된 프로세스에게 실제로 CPU를 이양하는 작업이 필요하다. 이와 같이 새롭게 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경설정을 하는 운영체제의 코드를 디스패터라고 한다. 

### 디스패처의 수행 과정

디스패처는 현재 수행 중이던 프로세스의 문맥을 그 프로세스의 PCB에 저장

새롭게 선택된 프로세스의 문맥을 PCB로부터 복원 후 그 프로세스에게 CPU를 넘김

복원시킨 후에는 시스템의 상태를 사용자모드로 전환 해 사용자 프로그램에게 CPU의 제어권 넘김

디스패처가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간을 디스패치 지연시간이라고 하며, 이 시간의 대부분은 문맥교환 오버헤드에 해당한다.

</br>

## 스케줄링의 성능 평가

### 시스템 관점의 지표

**CPU 이용률** 

전체 시간 중에서 CPU가 일을 한 시간의 비율. CPU가 일을 하지 않고 휴면 상태에 머무르는 시간을 최대한 줄이는 것이 스케줄링의 중요한 목표이다.

**처리량**

주어진 시간동안 준비 큐에서 기다리고 있는 프로세스 중 몇 개를 끝마쳤는지를 나타낸다. 여러 프로세스가 CPU를 기다리고 있는 상황에서 주어진 시간에 더 많은 프로세스들이 CPU작업을 완료하기 위해서는 CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 할당하는 것이 유리하다. 

</br>

### 사용자 관점의 지표

**소요시간**

프로세스가 준비큐에 들어와 CPU를 요청한 시점부터 자신이 원하는 만큼 CPU를 다 쓰고 CPU 버스트가 끝날 때까지 걸린 시간이다. 해당 CPU 버스ㅌ가 완료될 때까지 소요된 시간으로, 프로그램 실행 시간과는 다르다. 

**대기시간**

CPU 버스트 기간 중 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합. 시분할 시스템에서는 CPU 버스트 중에도 준비 큐에서 기다린 시간이 여러번 발생할 수 있다. 이때 대기시간이란 이번 CPU 버스트가 끝나기까지 준비큐에서 기다린 시간의 합을 뜻하게 된다.

**응답시간** 

프로세스가 준비 큐에 들어온 후 첫번째 CPU를 획득하기까지 기다린 시간. 타이머 인터럽트가 빈번히 발생할 수록 처음 CPU를 얻기까지의 시간을 줄어들게 되어 응답시간이 향상된다.  응답 시간은 대화형 시스템에 적합한 성능 척도로서 사용자 입장에서 가장 중요한 성능 척도로 볼 수 있다. 

</br>

## 스케줄링 알고리즘

### 선입선출 스케줄링 (First-Come First Served: FCFS)

프로세스가 준비 큐에 **도착한 시간 순서대로** CPU에 할당하는 방식.

이 방식에서는 CPU를 먼저 요청한 프로세스에게 CPU를 먼저 할당하고, 그 프로세스가 자발적으로 CPU를 반납할 때까지 빼앗지 않는다. 

이 경우 CPU 버스트가 짧은 프로세스가 앞의 CPU 버스트가 긴 프로세스 하나를 위해 평균 대기 시간이 길어지게 되거나 I/O 장치들의 이용률까지 하락할 가능성이 있다. 

이 알고리즘에서는 먼저 도착한 프로세스의 성격에 따라 평균 대기시간이 크게 달라진다. 

CPU 버스트가 짧은 프로세스가 CPU 버스트가 긴 프로세스보다 나중에 도착해 오랜 시간을 기다려야 하는 현상을 **콘보이 현상**(Convoy effect)라고 하며, 이 현상이 FCFS 스케줄링의 대표적인 단점이다.

</br>

### 최단작업 우선 스케줄링 (Short-Job First: SJF)

CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식.

이 알고리즘은 평균 대기시간을 가장 짧게 하는 최적 알고리즘으로 알려져있다.

구현방식은 두가지가 있다.

**비선점형 방식**

현재 CPU를 점유하고 있는 프로세스가 CPU 버스트를 모두 수행하고 스스로 CPU를 내어놓을 때까지 스케줄링을 하지 않는다. 

**선점형 방식 → SRTF : Shortest Remaining Time First**

준비 큐에서 CPU 버스트가 가장 짧은 프로세스에게 CPU를 할당했다 하더라도, CPU 버스트가 더 짧은  프로세스가 도착할 경우 CPU를 뺴앗아 더 짧은 프로세스에게 부여

→ 프로세스들이 준비 큐에 도착하는 시간이 불규칙한 환경에서는 선점형 방식이 프로세스들의 평균 대기시간을 최소화하는 최적의 알고리즘이 된다.

</br>

SJF 스케줄링 기법의 구현에서 현실적으로 어려운 부분은 프로세스의 CPU 버스트 시간을 미리 알 수 없다는 점이다. 그래서 예측을 통해 CPU 버스트 시간을 구한 후 예측 치가 가장 짧은 프로세스에게 CPU를 할당한다. 

Tn : n번째 CPU 버스트의 예측시간

tn: 실제 n번째 CPU 버스트 시간

ɑ: 0과 1 사기의 상수.

최근의 CPU 버스트 시간일수록 오래전의 CPU 버스트 시간에 비해 가중치를 높인다. 

하지만 CPU 버스트가 짧은 프로세스가 계속 도착할 경우 CPU 버스트가 긴 프로세스는 계속해서 CPU를 할당받지 못할 수도 있다. 이러한 현상을 기아(starvation) 현상이라고 하며, SJF 알고리즘의 심각한 문제점이다.

</br>

### 우선순위 스케줄링

준비 큐에서 기다리는 프로세스들 중 우선순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당하는 방식. 이때 우선순위는 우선순위값을 통해 표시한다. 

우선순위를 결정하는 방식에는 여러 가지가 있을 수 있다. CPU 버스트 시간을 우선순위 값으로 정의하면 우선순위 스케줄링은 SFJ 알고리즘과 동일한 의미를 가지게 된다. 

구현방식은 두가지가 있다. → 비선점형 방식, 선점형 방식

우선순위 스케줄링 방식에서의 문제점 중 하나는 기아 현상이 발생할 수 있다는 점이다. 이 문제점을 해결하기 위해 노화(aging) 기법을 사용할 수 있다. 노화기법이란 기다리는 시간이 길어지면 우선순위를 조금씩 높여주는 방법이다. 

</br>

### 라운드 로빈 스케줄링

위의 스케줄링들과 달리 시분할 시스템이 성질을 가장 잘 활용한 새로운 의미의 스케줄링 방식.

각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간이 특정 시간으로 제한되며, 이 시간이 경과하면 해당 프로세스로부터 CPU를 회수해 준비 큐에 줄 서 있는 다른 프로세스에게 CPU를 할당한다.

할당시간이 너무 길면 FCFS와 같은 결과를 나타내게 되고, 할당시간이 너무 짧으면 CPU를 사용하는 프로세스가 빈번히 교체되어 문맥교환의 오버헤드가 커진다. 따라서 일반적으로 할당시간을 수십 밀리초 정도의 규모로 설정한다. 

라운드로빈 스케줄링은 여러 종류의 이질적인 프로세스가 같이 실행되는 환경에서 효과적이다. 예를 들어 n개의 프로세스가 준비큐에 있고 할당시간이 q이면 , 모든 프로세스가 (n-1)q 시간 내에 적어도 한번은 CPU를 할당받을 수 있다. 이와 같은 방식은 대화형 프로세스의 빠른 응답시간을 보장할 수 있다는 장점이 있다. 

라운드 로빈 스케줄링은 일반적으로 SJF 방식보다 평균대기 시간은 길지만 응답시간은 더 짧다.

할당시간이 만료되어 CPU를 회수하는 방법으로는 타이머 인터럽트를 사용하게 된다. 

프로세스의 CPU 버스트 시간이 균일하면 라운드로빈은 비효율적인 스케줄링 방식이다. 하지만 일반적인 시스템에서는 프로세스의 CPU 버스트 시간이 균일하지 않고 각자 다른 CPU 버스트 및 I/O 버스트를 가지는 경우가 대부분이다. 

</br>

### 멀티레벨 큐

준비 큐를 여러 개로 분할해 관리하는 스케줄링 기법.

멀티레벨 큐는 일반적으로 성격이 다른 프로세스들을 별도로 관리하고, 프로세스의 성격에 맞는 스케줄링을 적용하기 위해 준비 큐를 별도로 두게 된다. 일반적으로 멀티레벨 큐에서 준비 큐는 **대화형 작업을 담기 위한 전위 큐**(foreground queue)와 **계산 위주의 작업을 담기 위한 후위 큐**(background queue)로 분할하여 운영된다. 전위 큐에서는 응답시간을 짧게 하기 위해 라운드 로빈 스케줄링을 사용하는 반면, 계산 위주의 작업을 위한 후위 큐에서는 응답시간이 큰 의미를 가지지 않기 때문에 FCFS  스케줄링 기법을 사용해 문맥 교환 오버헤드를 줄이도록 한다. 

멀티레벨 큐에서는 또 다른 스케줄링이 필요한데, 이는 큐 자체에 대한 스케줄링이다. 여러 개의 큐 중에 어떤 큐에 CPU를 먼저 할당할 것인지 결정하는 스케줄링이다.

가장 쉬운 방식으로는 **고정 우선순위 방식**(fixed priority scheduling)이다. 즉 전위큐에게 먼저 CPU를 할당하고, 전위 큐가 비어 있는 경우에만 후위 큐에 있는 프로세스에게 CPU가 할당된다.

**타임슬라이스(time slice) 방식**을 사용할 수도 있다. 이 방식은 큐에 대한 기아 현상을 해소할 수 있는 방식으로, 각 큐에 CPU 시간을 적절한 비율로 할당한다. 예를 들어 CPU 시간을 전위 큐 80%, 후위 큐 20% 할당해 스케줄링하는 방식이 있다. 

</br>

### 멀티레벨 피드백 큐 : Multilevel Feedback Queue

CPU를 기다리는 프로세스를 여러 큐에 줄 세운다는 측면에서 멀티레벨 큐와 동일하나, 프로세스가 하나의 큐에서 다른 큐로 이동 가능하다는 점이 다르다. 멀티레벨 피드백 큐를 정의하는 요소들로는 큐의 수, 각 큐의 스케줄링 알고리즘, 프로세스를 상위 큐로 승격 / 하위 큐로 강등 시키는 기준, 프로세스가 도착했을 때 들어갈 큐를 결정하는 기준 등이 있다. 

왼쪽의 그림이 대표적인 멀티레벨 피드백 큐의 대표적인 방식이다. 상위에 있는 큐일수록 우선순위가 높다. 해당 큐에서 작업이 완료가 되지 않으면 아래 큐로 한칸 씩 이동을 한다. 할당시간이 10인 큐에서도 작업이 끝나지 않으면 이 프로세스는 CPU를 오래 사용하는 계산 위주의 프로세스로 간주되어 최하위 큐로 이동하게 된다. 최상위 큐가 우선적으로 CPU를 배당받고, 상위 큐가 비어있을 때만 하위 큐에 있는 프로세스들이 CPU를 할당받는다.  

이러한 방식은 작업시간이 짧은 프로세스일수록 더욱 빠른 서비스가 가능하도록하고, 작업시간이 긴 프로세스에 대해서는 문맥교환 없이 CPU 작업에만 열중할 수 있는 FCFS 방식을 채택할 수 있게한다.

### 다중처리기 스케줄링 : multi-processor system

CPU가 여러개인 시스템.

다중처리기 환경에서의 CPU 스케줄링은 CPU가 하나인 시스템에서 더욱 복잡한 문제가 된다. 프로세스를 한줄에 세워놓고 CPU가 알아서 다음 프로세스를 꺼내어 가도록 할 수 있다. (은행과 유사) 그러나 반드시 특정 CPU에서 수행되어야 하는 프로세스가 있으면 문제는 복잡해진다. (미용실 디자이너 지정과 유사) 이런 경우 각 CPU 별로 줄 세우기를 할 수 도 있다. 

한편 여러 줄로 줄 세우기를 하는 경우 일부 CPU에 작업이 편중되는 현상이 발생할 수 있다. 이러한 문제점을 방지하기 위해 각 CPU별 부하가 적절히 분산되도록 하는 부하균형(load balancing) 매커니즘을 필요로 한다. 

**대칭형 다중처리(symmetric multi-processing)**

각 CPU가 알아서 스케줄링을 결정

**비대칭형 다중처리(asymmetric multi-processing)**

하나의 CPU가 다른 모든 CPU의 스케줄링 및 데이터 접근을 책임지고 나머지 CPU는 거기에 따라 움직이는 방식

</br>

### 실시간 스케줄링

시분할 시스템에서는 작업의 처리가 빠를수록 좋지만 특정 시간 이내에 처리하지 못했다고 해서 심각한 상황이 발생하는 것은 아니다. 즉 작업에 데드라인이 존재하지 않는다. 이와 달리 실시간 시스템(real-time system)에서는 각 작업마다 주어진 데드라인이 있어 정해진 데드라인 안에 반드시 작업을 처리해야 한다. 

**경성 실시간 시스템(hard real-time system)**

미사일 발사, 원자로 제어 등 시간을 정확히 지켜야 하는 시스템을 말한다. 

**연성 실시간 시스템(soft real-time system)**

데드라인이 존재하지만 지키지 못했다고 해서 위험한 상황이 발생하지는 않는다. 예) 멀티미디어 스트리밍 시스템.

실시간 환경에서는 먼저 온 요청을 먼저 처리하기보다는 데드라인이 얼마 남지 않은 요청을 먼저 처리하는 EDF(Early Deadline First) 스케줄링을 널리 사용한다. 

</br>

## 스케줄링 알고리즘의 평가

**큐잉모델(queueing-model)**

주로 이론가들이 수행하는 방식으로, 확률분포를 통해 프로세스들의 도착률과 CPU의 처리율을 입력값으로 주면 복잡한 수학적 계산을 통해 각종 성능지표인 CPU의 처리량, 프로세스의 평균 대기시간 등을 구하게 된다. 

**구현 및 실측**

이론가와 정반대인 구현가들이 수행할 수 있는 방식으로, 운영체제 커널의 소스코드 중 CPU 스케줄링을 수행하는 코드를 수정해서 커널을 컴파일한 후 시스템에 설치하는 과정을 필요로 한다. 그런 다음 동일한 프로그램을 원래 커널과 CPU 스케줄러를 수정한 커널에서 수행시켜보고 실행시간을 측정하여 알고리즘의 성능을 평가한다.

**시뮬레이션**

실제 시스템에 구현해 수행시켜보는 것이 아니라 가상으로 CPU 스케줄링 프로그램을 작성한 후 프로그램의 CPU 요청을 입력 값으로 넣어 어떠한 결과가 나오는지를 확인하는 방법이다. 입력값은 가상으로 생성할 수도 있고 실제 시스템에서의 CPU 요청 내역을 추출해 사용할 수도 있다.

이때 실제 시스템에서 추출한 입력값을 트레이스(trace)라고 부른다. 트레이스는 몇 초에 어떤 프로세스가 도착하고, 각각 CPU 버스트 시간을 얼마로 하는지에 대한 정보를 시간 순서대로 적어놓은 파일을 말한다.
