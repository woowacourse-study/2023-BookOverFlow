# 6장 | CPU 스케쥴링

## 1. CPU 스케쥴러
- 준비 상태에 있는 프로세스들 중 어떠한 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드
- CPU 스케쥴링이 필요한 경우
  - 실행 상태에 있던 프로세스가 I/O 요청 등에 의해 봉쇄 상태로 바뀌는 경우
  - 실행 상태에 있던 프로세스가 타이머 인터럽트 발생에 의해 준비상태로 바뀌는 경우
  - I/O 요청으로 봉쇄 상태에 있던 프로세스의 I/O 작업이 완료되어 인터럽트가 발생하고 그 결과 이 프로세스의 상태가 준비 상태로 바뀌는 경우
  - CPU에서 실행 상태에 있는 프로세스가 종료되는 경우
  - CPU 스케줄링 방식
    - 비선점형(nonpreemptive) 방식
      - CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지는 CPU를 빼앗기지 않는 방법
    - 선점형(preemptive) 방식
      - 프로세스가 CPU를 계속 사용하기를 원하더라도 강제로 빼앗을 수 있는 스케줄링 방법
      - 할당시간을 부여하고 타이머 인터럽트를 발생시키는 방법이 대표적

## 2. 디스패처
- 새롭게 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경설정을 하는 운영체제의 코드
- 현재 수행 중이던 프로세스의 문맥(context)을 그 프로세스의 PCB에 저장하고, 새롭게 선택된 프로세스의 문맥을 PCB로부터 복원한 후 그 프로세스에게 CPU를 넘기는 과정을 수행한다.

## 3. 스케줄링의 성능 평가
- 스케줄링 기법의 성능을 평가하기 위해 여러 지표들이 사용되는데, 이 지표들을 크게 시스템 관점의 지표와 사용자 관점의 지표로 나누어볼 수 있음
- 시스템 관점의 지표
  - CPU 이용률
    - 전체 시간 중에서 CPU가 일을 한 시간의 비율
    - CPU가 휴면상태인 시간을 최대한 줄이는 것이 스케줄링의 중요한 목표
  - 처리량
    - 주어진 시간 동안 준비 큐에서 기다리고 있는 프로세스 중 몇 개를 끝마쳤는지를 나타냄
    - 여러 프로세스가 CPU를 기다리고 있는 상황에서 주어진 시간에 더 많은 프로세스들이 CPU 작업을 완료하기 위해서는 CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 할당하는 것이 유리하다.
- 사용자 관점의 지표
  - 소요시간
    - 프로세스가 CPU를 요청한 시점부터 자신이 원하는 만큼 CPU를 다 쓰고 CPU 버스트가 끝날 때까지 걸린 시간
  - 대기시간
    - CPU 버스트 기간 중 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합을 뜻함
    - 이번 CPU 버스트가 끝나기 까지 준비 큐에서 기다린 시간의 합을 뜻함
  - 응답시간
    - 프로세스가 준비 큐에 들어온 후 첫 번째 CPU를 획득하기까지 기다린 시간을 뜻함

## 4. 스케줄링 알고리즘

### 1. 선입선출 알고리즘 (First Come First Served)
- 프로세스가 준비 큐에 도착한 시간 순서대로 CPU를 할당하는 방식
- 먼저 도착한 프로세스의 성격에 따라 평균 대기시간이 크게 달라짐
- CPU 버스트가 긴 프로세스보다 나중에 도착해 오랜 시간을 기다려야 하는 현상을 콘보이 현상(Convoy effect)이라고 하며 대표적인 FCFS의 단점이다.

### 2. 최단작업 우선 스케줄링 (Shortest-Job First)
- CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식
- 평균 대기시간을 가장 짧게 하는 최적 알고리즘
- 비선점형 방식과 선점형 방식으로 구현 가능
  - 비선점형 방식
    - 현재 CPU를 할당받고 수행중인 프로세스가 비록 CPU를 할당받은 시점에서 가장 짧은 CPU 버스트 시간인 프로세스여도 더 짧은 프로세스가 등장하면?
    - 현재 CPU를 점유하고 있는 프로세스가 CPU 버스트를 모두 수행하고 스스로 CPU를 내어 놓을 때까지 스케줄링을 하지 않음
  - 선점형 방식
    - 현재 CPU를 할당받고 수행중인 프로세스가 비록 CPU를 할당받은 시점에서 가장 짧은 CPU 버스트 시간인 프로세스여도 더 짧은 프로세스가 등장하면?
    - 현재 수행중인 프로세스에게서 CPU를 선점해 CPU 버스트 시간이 더 짧은 프로세스에게 할당함
- SJF 방식에서 현실적으로 어려운 부분은 프로세스의 CPU 버스트 시간을 미리 알 수 없음 따라서 과거의 CPU 버스트 시간을 통해 예측을 함
- CPU 버스트가 상대적으로 짧은 프로세스가 게속 도착할 경우 프로세스가 계속해서 CPU를 할당 받지 못하는 현상을 기아 현상(starvation)이라고 함

### 3. 우선순위 스케줄링(priority scheduling)
- 준비 큐에서 기다리는 프로세스들 중 우선순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당하는 방식
- 우선순위 값을 사용하며 이 값이 작을 수록 높은 우선순위를 가지는 것으로 가정
- 비선점, 선점형으로 구현 가능
- 우선순위가 높은 프로세스가 계속 도착하는 상황에서 우선 순위가 낮은 프로세스는 CPU를 얻지 못한 채 계속 기다려야할 수 있기 때문에 노화기법을 사용한다.
  - 기다리는 시간이 길어지면 우선순위를 조금씩 높여, 언젠가는 가장 높은 우선순위가 되어 CPU를 할당받게 해주는 방법

### 4. 라운드로빈 스케쥴링(Round Robin Scheduling)
- 각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간이 특정 시간으로 제한되며, 이 시간이 경과하면 해당 프로세스로부터 CPU를 회수해 준비 큐에 줄 서 있는 다른 프로세스에게 CPU를 할당한다.
- 할당시간이 너무 길면 FCFS와 같은 결과를 나타냄
- 할당시간이 너무 짧으면 문맥교환의 오버헤드가 커짐

### 5. 멀티레벨 큐(Multi Level Queue)
- 준비 큐를 여러 개로 분할해 관리하는 스케줄링 기법
- 일반적으로 성격이 다른 프로세스들을 별도로 관리하고, 프로세스의 성격에 맞는 스케쥴링을 적용하기 위해 준비 큐를 별도로 두게 됨
- 큐 자체에 대한 스케줄링이 필요함

### 6. 멀티레벨 피드백 큐(Multilevel Feedback Queue)
- CPU를 기다리는 프로세스를 여러 큐에 줄 세운다는 측면에서 멀티레벨 큐와 동일하나, 프로세스가 하나의 큐에서 다른 큐로 이동 가능하다는 점이 다르다.
- 큐를 우선순위에 따라 분류하여 프로세스를 줄세움

### 7. 다중처리기 스케줄링(Multi Processor System)
- CPU가 여러 개인 시스템을 다중처리기 시스템
- 여러 줄로 프로세스들을 줄 세우기를 하는 경우 일부 CPU에 작업이 편중되는 현상이 발생
- 이로인한 부하균형(load balancing) 메커니즘을 필요로 함
- 다중처리기 스케줄링의 방식
  - 대칭형 다중처리(symmetric multi-processing)
    - 각 CPU가 각자 알아서 스케줄링을 결정하는 방식
  - 비대칭형 다중처리(asymmetric multiprogramming)
    - 하나의 CPU가 다른 모든 CPU의 스케줄링 및 데이터 접근을 책임 지고 나머지 CPU는 거기에 따라 움직이는 방식

### 8. 실시간 스케줄링(Real Time Scheduling)
- 빠른 서비스도 중요하지만 데드라인을 지키는 서비스가 더욱 중요
- 먼저 온 요청을 먼저 처리하는 EDF(Earlist DeadLine First) 스케줄링을 사용

## 5. 스케줄링 알고리즘의 평가
- 큐잉모델
  - 주로 이론가들이 수행하는 방식으로, 확률분포를 통해 프로세스들의 도착률과 CPU의 처리율을 입력값으로 주면 복잡한 수학적 계산을 통해 각종 성능지표인 CPU의 처리량, 프로세스의 평균 대기시간 등을 구하게 됨
- 세뮬레이션
  - 실제 시스템에 구현해 수행시켜보는 것이 아니라 가상으로 CPU 스케줄링 프로그램을 작성한 후 프로그램의 CPU 요청을 입력값으로 넣어 어떠한 결과가 나오는지 확인하는 방법
- 구현 및 실측
  - 운영체제 커널의 소스 코드 중 CPU 스케줄링을 수행하는 코드를 수정해서 커널을 컴파일한 후 시스템에 설치하는 과정을 필요
  - 동일한 프로그램을 원래 커널과 CPU 스케줄러를  수정한 커널에서 수행시켜보고 실행시간을 측정하여 알고리즘의 성능을 측정
