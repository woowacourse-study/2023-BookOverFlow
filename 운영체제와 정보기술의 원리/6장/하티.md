# 06. CPU 스케줄링

## CPU

- CPU: 프로그램의 기계어 명령을 실제로 수행하는 컴퓨터 내의 중앙처리장치

- 프로그램 시작 → 메모리에 올라감 → 프로그램 카운터(PC)라는 레지스터가 현재 CPU에서 수행할 코드의 메모리 주소값을 갖게 됨 → CPU는 PC가 가리키는 주소의 기계어 명령을 하나씩 수행

- CPU는 일반적으로 한 시스템 내에 하나 존재 → 매우 효율적인 관리가 필요

### 기계어 명령

- CPU 내에서 수행되는 명령
    - e.g. Add (레지스터에 있는 두 값을 더해 레지스터에 저장하는 명령)
    
    - 명령의 수행 속도가 매우 빠름
    
    - 일반명령
    
- 메모리 접근을 필요로 하는 명령
    - e.g. Load, Store
    
    - CPU 내에서 수행되는 명령보단 오래 걸리나, 비교적 짧은 시간에 수행 가능
    
    - 일반명령
    
- 입출력을 동반하는 명령
    - e.g. 키보드 입력, 화면에 출력, 디스크에서 읽어오기/저장하기
    
    - 오랜 시간이 소요
    
    - 특권명령 → 사용자 프로그램이 직접 수행 불가, 운영체제를 통해 이루어짐
    
- 사용자 프로그램 수행: CPU 작업과 I/O 작업의 반복
    - 사용자 프로그램이 CPU를 직접 가지고 빠른 명령을 수행하는 단계: **CPU 버스트(burst)**
        
        I/O 요청이 발생해 커널에 의해 입출력 작업을 진행하는 느린 단계: **I/O 버스트**
        
    - **CPU 바운드 프로세스**
        - CPU 버스트가 길게 나타내는 프로세스
        
        - 소수의 긴 CPU 버스트
        
        - e.g. 계산 위주의 프로그램

    - **I/O 바운드 프로세스**
        - I/O 요청이 빈번해 CPU 버스트가 짧게 나타나는 프로세스
        
        - 다수의 짧은 CPU 버스트
        
        - e.g. 사용자로부터 인터랙션을 받아가며 프로그램을 수행하는 대화형 프로그램
        
- CPU 스케줄링을 할 때, CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 사용하는 스케줄링이 필요
    - 대화형 작업은 사용자에 대한 빠른 응답이 중요하기 때문
    
    - 즉, I/O 바운드 프로세스의 우선순위를 높여주는 것이 바람직함

## CPU 스케줄러

- 준비 상태에 있는 프로세스들 중 어떠한 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드

### CPU 스케줄러가 필요한 경우

- 실행 상태의 프로세스가 I/O 요청 등에 의해 봉쇄 상태가 되는 경우 `비선점형`

- 실행 상태의 프로세스가 타이머 인터럽트 발생에 의해 준비 상태가 되는 경우 `선점형`

- I/O 요청으로 봉쇄 상태에 있던 프로세스의 I/O 작업이 완료되어 준비 상태가 되는 경우 `선점형`

- 실행 상태의 프로세스가 종료되는 경우 `비선점형`

### CPU 스케줄링 방식

- 비선점형(nonpreemptive) 방식
    - CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지 CPU를 빼앗기지 않는 방법
    
- 선점형(preemptive) 방식
    - 프로세스로부터 강제로 CPU를 빼앗을 수 있는 스케줄링 방법
    
    - CPU를 빼앗는 방법으로, **할당시간(time quantum)을 부여한 후 타이머 인터럽트를 발생시키는 방법**이 대표적

## 디스패처 (dispatcher)

- 새롭게 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경설정을 하는 운영체제의 코드

- 현재 수행 중이던 프로세스의 문맥을 프로세스의 PCB에 저장하고,
    
    새롭게 선택된 프로세스의 문맥을 PCB로부터 복원하고, 
    
    시스템의 상태를 사용자모드로 전환해
    
    그 프로세스에게 CPU를 넘기는 과정을 수행함
    
- 디스패치 지연시간 (idspatch latency)
    - 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간
    
    - **문맥교환 오버헤드**에 해당됨

## 스케줄링의 성능 평가

### 시스템 관점의 지표

- CPU 이용률 (CPU utilization)
    - 전체 시간 중에서 CPU가 일을 한 시간의 비율
    
    - CPU가 일을 하지 않고 휴면 상태에 머무르는 시간이 **최소화**되어야 함
    
- 처리량 (throughput)
    - 주어진 시간 동안 준비 큐에 있는 프로세스 중 몇 개를 끝마쳤는지 (CPU 버스트를 완료한 프로세스의 개수)
    
    - CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 부여하는 것이 유리

### 사용자 관점의 지표

- 소요시간 (turnaround time)
    - 프로세스가 CPU를 요청한 시점부터 CPU 버스트가 끝날 때까지 걸린 시간
    
    - 즉, 준비 큐에서 기다린 시간 + 실제로 CPU를 사용한 시간
    
    - e.g. CPU를 사용하다가 I/O 연산을 위해 자진반납 → 소요시간: 준비 큐에 들어왔을 때 ~ CPU를 반납할 때까지의 시간
    
- 대기시간 (waiting time)
    - CPU 버스트 기간 중 프로세스가 준비 큐에서 기다린 시간의 합
    
- 응답시간 (response time)
    - 프로세스가 준비 큐에 들어온 후 첫 번째 CPU를 획득하기까지 기다린 시간
    
    - 타이머 인터럽트가 빈번하게 발생할수록 처음 CPU를 얻기까지 걸리는 시간이 줄어 응답시간이 향상된다
    
    - 대화형 시스템에 적합한 성능 척도로서 사용자 입장에서 가장 중요한 성능 척도이다

## 스케줄링 알고리즘

### 선입선출 스케줄링

- FCFS(First-Come First-Served) 스케줄링

- 프로세스가 준비 큐에 도착한 시간 순서대로 CPU를 할당하는 방식

- 프로세스가 자발적으로 CPU를 반납하고, 빼앗지 않는다.

- 비효율적인 결과를 초래하기도 한다.
    - CPU 버스트가 긴 프로세스 하나가 먼저 도착했을 때, 평균 대기시간이 길어진다. (`**콘보이 현상`** (convoy effect))

### 최단작업 우선 스케줄링

- SJF(Shortest-Job First) 스케줄링

- CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식

- 평균 대기시간을 가장 짧게 하는 최적 알고리즘

- 비선점형 방식
    - 일단 CPU를 획득하면 자진 반납하기 전까지 빼앗지 않는 방식

- 선점형 방식
    - CPU 버스트가 더 짧은 프로세스가 도착하면, CPU를 빼앗아 더 짧은 프로세스에게 부여하는 방식 (SRTF: Shortest Remaining Time First)
    
    - 프로세스들이 준비 큐에 도착하는 시간이 불규칙한 환경에서 평균 대기시작이 최소화되는 방식
    
    - CPU 버스트가 짧은 프로세스가 계속 도착할 경우, 영원히 할당받지 못하는 CPU가 생길 수 있다. (`**기아 현상**`)

### 우선순위 스케줄링

- priority 스케줄링

- 준비 큐에서 기다리는 프로세스들 중 우선순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당하는 방식

- 우선순위는 우선순위값을 통해 표시 → 값이 작을수록 높은 우선순위

- 우선순위를 결정하는 방식
    - CPU 버스트 시간 → 최단작업 우선 스케줄링과 같음
    
    - 시스템 관련 중요 작업을 수행할수록 높은 우선순위
    
    - 등등…

- 비선점형 방식
    - 자진 반납하기 전까지 빼앗지 않는 방식

- 선점형 방식
    - 현재 수행중인 프로세스보다 우선순위가 높은 프로세스가 오면 빼앗아 새로운 프로세스에 부여하는 방식
    
    - 역시나 `기아 현상`이 발생할 수 있다.
    
    - → 이를 해결하기 위해 `**노화(aging) 기법**` 사용
        - 기다리는 시간이 길어지면 우선순위를 조금씩 높이는 방식

### 라운드 로빈 스케줄링

- Round Robin 스케줄링

- 시분할 시스템의 성질을 가장 잘 활용한 스케줄링 방식

- 각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간(`**할당시간(time quantum)**`)이 제한되며,
    
    `할당시간`이 경과하면 CPU를 회수해 준비 큐에 있는 다른 프로세스에게 CPU를 할당하고,
    
    기존 프로세스는 준비 큐의 맨 뒤로 가 차례를 기다린다.
    
- 할당시간이 너무 길다면 → FCFS와 같은 결과가 나타난다.

- 할당시간이 너무 짧다면 → 프로세스가 빈번하게 교체되어 문맥교환의 오버헤드가 커진다.

- 일반적으로 할당시간은 수십 밀리초 정도의 규모

- 여러 종류의 이질적인 프로세스가 같이 실행되는 환경에서 효과적

### 멀티레벨 큐

- multi-level queue

- 준비 큐를 여러 개로 분할해 관리하는 스케줄링 기법

- CPU가 하나밖에 없는데, 어떤 줄에 서 있는 프로세스를 우선으로 수행할 것인가?
    - 빠른 응답을 필요로 하는 대화형 작업을 **`전위 큐 (foreground queue)`**에 담고, 그렇지 않은 계산 위주의 작업을 `**후위 큐 (background queue)**`에 담아 별도의 줄에 세우고, 대화형 작업에게 우선적으로 CPU를 할당
    
    - 전위 큐는 응답시간 최소화를 위해 라운드 로빈 스케줄링을, 후위 큐에서는 응답 시간이 큰 의미를 갖지 않으므로 FCFS 스케줄링 기법을 사용

- 프로세스가 도착했을 대 어느 줄에 세워야 하는가?
    - 고정 우선순위 방식
        - 큐에 고정적인 우선순위를 부여

    - 타임 슬라이스 방식
        - 각 큐에 CPU 시간을 적절한 비율로 할당하여 기아 현상을 해소

### 멀티레벨 피드백 큐

- multilevel feedback queue

- 여러 큐에 프로세스를 줄 세운다는 점에서 멀티레벨 큐와 동일하나, **프로세스가 하나의 큐에서 다른 큐로 이동이 가능**하다는 차이점이 있다.

- 큐의 수, 각 큐의 스케줄링 알고리즘, 프로세스를 상위 큐로 승격시키는 기준, 프로세스를 하위 큐로 강등시키는 기준, 프로세스가 도착했을 때 들어갈 큐를 결정하는 기준 등

- 상위 큐는 라운드 로빈, 하위 큐는 FCFS 스케줄링

- 프로세스들은 우선순위가 높은 큐에 줄을 선다.
    
    그러나 CPU 버스트 시간이 긴 프로세스들은 하위 큐로 내려가 줄 서게 된다.
    
    하위 큐에서 작업이 계속 완료되지 않으면, 계산 위주의 프로세스로 간주되어 최하위 큐로 이동, FCFS 스케줄링을 적용받는다.
    
- 최상위 큐가 우선적으로 CPU를 배당받고, 상위 큐가 비어있으면 하위 큐의 프로세스에 CPU를 할당한다.

### 다중처리기 스케줄링

- multi-processor system

- CPU가 여러 개인 시스템에서의 스케줄링: 프로세스를 준비 큐에 한 줄로 세우고, 각 CPU가 알아서 다음 프로세스를 꺼내어간다.

- 특정 CPU에서 수행되어야 있는 프로세스가 있는 경우, 한 줄이 아니라 CPU 별로 줄 세우기를 할 수도 있다.

- 여러 줄로 줄 세우기를 하는 경우, 일부 CPU에 작업이 편중되는 현상을 방지하기 위해 `부하균형(load balancing) 매커니즘`이 필요하다.

- 대칭형 다중처리 (symmetric multi-processing)
    - 각 CPU가 알아서 스케줄링을 결정하는 방식

- 비대칭형 다중처리 (asymmetric multi-processing)
    - 하나의 CPU가 다른 모든 CPU의 스케줄링 및 데이터 접근을 책임지고, 나머지 CPU는 거기에 따라 움직이는 방식

### 실시간 스케줄링

- real-time system 에서는 각 작업마다 주어진 데드라인이 있고, 이 안에 반드시 작업을 처리해야 한다.

- 경성 실시간 시스템 (hard real-time system)
    - 정해진 시간을 정확히 지켜야 하는 시스템

    - e.g. 미사일 발사, 원자로 제어 등

- 연성 실시간 시스템 (soft real-time system)
    - 데드라인이 존재하나, 지키지 못해도 위험한 상황은 발생하지 않는다.

    - e.g. 멀티미디어 스트리밍 시스템

- 빠른 서비스보다 데드라인을 지키는 서비스가 더 중요함 → 먼저 온 요청보다, 데드라인이 얼마 남지 않은 요청을 먼저 처리하는 `**EDF (Earlist Deadline First) 스케줄링**`을 사용한다.

## 스케줄링 알고리즘의 평가

### 큐잉모델 (queueing model)

- 이론가들이 수행하는 방식

- 확률분포를 통해 프로세스들의 도착률, CPU 처리율을 받아 → 복잡한 수학적 계산을 통해 각종 성능 지표 (CPU 처리량, 평균 대기시간 등)을 구함

### 구현 및 실측 (implementation & measurement)

- (이론가와 정반대인) 구현가들이 수행하는 방식

- 커널의 소스코드 중 CPU 스케줄링을 수행하는 코드를 수정해서 커널을 컴파일한 후 시스템에 설치

- 그 뒤로 동일 프로그램을 기존 커널과 위에서 코드를 수정한 커널에서 수행시켜본 후,
    
    실행시간을 측정하여 알고리즘의 성능을 평가
    

### 시뮬레이션 (simulation)

- 가상으로 CPU 스케줄링 프로그램을 작성한 후 프로그램의 CPU 요청을 입력값으로 넣어 어떤 결과가 나오는지를 확인하는 방법

- 입력값은 가상으로 생성할 수도, 실제 시스템에서 CPU 요청내역을 추출한 값(`트레이스(trace)`)을 사용할 수도 있다.

- 트레이스: 몇 초에 어떤 프로세스가 도착하고 CPU 버스트 시간이 얼마인지에 대한 정보를 시간 순으로 적은 파일
