# 02. 운영체제 개요

## 운영체제의 정의

- 운영체제: 컴퓨터 하드웨어 바로 윗단에 설치되는 소프트웨어
- Operating system
- 사용자, 다른 모든 소프트웨어, 하드웨어를 연결하는 소프트웨어 계층
- 운영체제 자체도 하나의 소프트웨어 → 실행을 위해 전원이 켜짐과 동시에 메모리에 프로그램이 올라간다.
    - 운영체제는 규모가 큰 소프트웨어이므로, **필요한 부분**만 메모리에 올린다. 그 부분이 **커널(kernel)**이다.
- 좁은 의미의 운영체제: 커널
    
    넓은 의미의 운영체제: 커널 + 시스템을 위한 유틸리티들 (e.g. 복사 프로그램)
    

## 운영체제의 기능

### 하드웨어를 위한 역할

- 사용자가 직접 다루기 힘든 각종 하드웨어를 관리
- 운영체제 == 자원관리자
    - 자원: CPU, 메모리, 하드디스크 등 하드웨어 자원 + 소프트웨어 자원 모두 통칭
- 컴퓨터 시스템 내의 자원을 효율적으로 관리하여 가장 좋은 성능이 나오도록
    - 전체 성능 향상에 의한 불이익을 막기 위해 균형을 맞추는 것도 필요

### 소프트웨어를 위한 역할

- 편리한 인터페이스를 제공
- 컴퓨터 시스템을 편리하게 사용할 수 있는 환경 제공
- 그 외에도, 사용자와 운영체제 자신을 보호하는 역할 담당

## 운영체제의 분류

### 분류기준 1. 동시 작업 지원 여부

- 단일작업(single tasking)용 운영체제
    - 한 번에 하나의 프로그램만 실행시킬 수 있는 운영체제
    - 초창기 운영체제 대부분이 이에 속함
- 다중작업(multi tasking용 운영체제
    - 동시에 2개 이상의 프로그램을 처리할 수 있는 운영체제
    - 최근 대부분의 운영체제가 이에 속함
    - 서로 다른 창을 동시에 띄워놓을 수 있다.
- 시분할 시스템 (time sharing system)
    - **CPU의 작업시간을 여러 프로그램들이 조금씩 나누어 쓰는 시스템**
    - 다중작업을 처리할 때, 여러 프로그램이 CPU와 메모리를 공유
    - 짧은 시간 규모로 여러 프로그램들이 CPU에서 번갈아 실행됨 → 사용자 입장에서는 여러 프로그램이 동시에 실행되는 것처럼 보임
- 다중 프로그래밍 시스템 (multi-programming system)
    - 메모리 공간을 분할해 여러 프로그램들을 동시에 메모리에 올려놓고 처리하는 시스템
- 대화형 시스템 (interactive system)
    - 각 프로그램에 대한 입력의 결과를 곧바로 화면에 출력함
- 다중작업, 시분할, 다중 프로그래밍, 대화형 시스템은 모두 여러 프로그램이 하나의 컴퓨터에서 동시에 실행된다.
    
    사용자의 입력에 곧바로 응답한다는 측면에서 유사한 의미로 사용된다. 
    
    우리가 널리 사용하는 PC가 이 조건들을 만족하는 시스템이다.
    
- 다중처리기 시스템 (multi-processor system)
    - 하나의 컴퓨터 안에 CPU가 여러 개 설치된 컴퓨터

### 분류기준 2. 다중 사용자에 대한 동시 지원 여부

- 단일 사용자용 운영체제
    - 한 번에 한 명의 사용자만이 사용하도록 허용하는 운영체제
    - 한 번에 하나의 작업만 수행할 수 있는 경우 (e.g. DOS)
    - 혼자 사용하지만 다중작업이 가능한 경우 (e.g. MS 윈도우)
- 다중 사용자용 운영체제
    - 여러 사용자가 동시에 접속해 사용할 수 있게 하는 운영체제
    - e.g.) 이메일 서버, 웹 서버 (여러 사용자가 동시 접속해 사용이 가능)

### 분류기준 3. 작업을 처리하는 방식

- 일괄처리 (batch processing) 방식
    - 요청된 작업을 일정량씩 모아서 한꺼번에 처리하는 방식
    - 여러 작업들을 모아 일정량이 쌓이면 일괄적으로 처리, 모든 작업이 완전히 종료되어야 결과 도출
    - 응답시간이 길다
    - e.g.) 펀치 카드 처리 시스템
- 시분할 방식
    - 여러 작업을 수행할 때 컴퓨터의 처리 능력을 일정한 시간 단위로 분할해 사용하는 방식
    - 짧은 응답시간: 사용자의 요청에 대해 곧바로 결과를 얻음 ( == 대화형 시스템)
- 실시간 (real time) 방식
    - 정해진 시간 안에 어떠한 일이 반드시 처리됨을 보장해야 하는 시스템
    - 일정 시간 안에 작업이 완료되지 못할 경우 동작 자체가 되지 않거나 큰 위험이 초래될 가능성이 있는 시스템
    - 시간 제약의 중요성에 따라 세분화
        - 경성 실시간 시스템 (hard realtime system)
            - 주어진 시간을 지키지 못할 경우 매우 위험한 결과 초래 가능성
            - e.g.) 로켓, 원자로 제어 시스템 등
        - 연성 실시간 시스템 (soft realtime system)
            - 데이터가 정해진 시간 단위로 전달되어야 올바른 기능 수행 가능
            - e.g.) 멀티미디어 스트리밍 시스템 등

## 운영체제의 예

- 플러그 앤 플레이 (plug and play)
    - 시스템에 새로운 하드웨어를 장착하면 운영체제가 자동으로 하드웨어를 감지하여 그에 맞게 설정됨
- 소프트웨어의 이식성
    - 해당 소프트웨어를 다른 기종의 기계로 옮기는 것이 얼마나 용이한가를 나타내는 지표

## 운영체제의 자원 관리 기능

- 운영체제의 핵심 기능: 효율적인 자원 관리
- 하드웨어 자원
    - CPU, 메모리, 주변 장치 (보조기억장치-하드디스크, 입출력장치-키보드, 모니터 등)

### CPU를 관리하는 방법

- 매 시점 어떠한 프로세스에 CPU를 할당해 작업을 처리할 지 결정 필요
- **선입선출 (First Come First Served) 기법**
    - CPU를 사용하기 위해 도착한 프로세스들을 먼저 도착한 것부터 먼저 처리
    - 일상생활 줄 서기와 유사
    - CPU 자체의 효율적인 사용 - 문제 X
        
        전체 시스템 — 비효율적인 결과 초래 가능
        
        - 먼저 온 프로세스가 오래 걸리면 짧은 프로세스들 기다려야 함
- **라운드 로빈 (Round Robin) 기법**
    - CPU를 한 번 할당받아 사용할 수 있는 시간을 일정하게 고정
        - 일반적으로 **ms** (밀리초) 단위
    - CPU 할당받아 작업 → 시간 지나면 → 중단하고 CPU 대기열 맨 뒤로 이동
- **우선순위 기법 (priority) 기법**
    - CPU 사용을 위해 대기 중인 프로세스들에 우선순위를 부여하고, 우선순위가 높은 프로세스에 먼저 할당ㅇ
    - 상대적으로 더 중요한 프로세스가 먼저 CPU 획득
    - 기다린 시간이 늘어날수록 너무 기다리지 않게 우선순위를 높여주는 등의 방안 활용 가능

### 메모리를 관리하는 방법

- CPU가 직접 접근할 수 있는 컴퓨터 내부의 기억장치
- 프로그램이 실행되려면 해당 부분이 메모리에 올라가 있어야 한다.
- 한정된 메모리 공간에 여러 프로그램을 수용하기 위해 메모리 효율적 관리 필요
- 메모리 관리를 위해 메모리의 어떤 부분이 어떤 프로그램에 의해 사용되는 지를 파악해야 함 → `주소 (address)` 이용
    - 프로그램에 메모리가 필요할 때 할당
    - 더이상 필요하지 않으면 회수
- **고정분할 (fixed partition) 방식**
    - 물리적 메모리를 몇 개의 분할로 미리 나누어 관리
    - 각각의 분할에 프로그램이 적재
    - 단점
        - 메모리에 동시 적재되는 최대 프로그램의 수 == 분할 개수 ⇒ 융통성 X
        - 분할된 크기보다 큰 프로그램 적재 불가능 ⇒ 효율성 X
        - 분할된 크기보다 작은 프로그램일 경우 남는 영역 발생 (`**내부조각**`) ⇒ 공간 낭비
- **가변분할 (variable partition) 방식**
    - 매 시점 프로그램의 크기에 맞게 메모리를 분할해서 사용하는 방식
    - 물리적 메모리의 크기보다 큰 프로그램 실행 불가능
    - 분할의 크기와 개수 동적으로 변함
    - `**외부조각**`: 프로그램에 할당되지는 않았지만 크기가 작아 프로그램을 올리지 못하는 메모리 영역
- **가상 메모리 (virtual memory) 방식**
    - 가장 널리 사용되는 메모리 기법
    - 물리적 메모리보다 더 큰 프로그램 실행 가능
    - 실행될 수 있는 프로그램의 크기는 가상메모리 크기에 의해 결정
        - 모든 프로그램은 자신만의 가상메모리 주소를 갖고,
        - 이를 물리적 메모리 주소로 매핑하는 기술을 이용해 주소를 변환시킨 후 적재한다.
    - 어떻게 가능하죠?
        - 프로그램에서 현재 사용되고 있는 부분만 메모리에 올리고,
            
            나머지는 보조기억장치에 저장해두었다가 필요할 때 적재
            
    - 보조기억장치에 저장된 영역: `**스왑 영역 (swap area)**`
    - `페이지(page)`라는 동일한 크기의 작은 단위로 나뉘어( == 페이징 기법)
        
        물리적 메모리와 스왑 영역에 저장됨
        

### 주변장치 및 입출력 장치를 관리하는 방법

- `**인터럽트(interrupt)**` 매커니즘을 통해 관리
    - 인터럽트: CPU의 서비스가 필요한 경우에 서비스 요청을 위해 발생시키는 신호
- CPU는 CPU 스케줄링에 따라 주어진 작업하다가 → 인터럽트 발생 → 하던 일을 멈추고 요청 서비스 수행
- 인터럽트 처리루틴: 인터럽트가 발생했을 때 해주어야 할 작업을 정의한 프로그램 코드
    - 운영체제 커널 내에 존재
- 각 주변장치마다 그 장치에서 일어나는 업무 관리를 위한 `**컨트롤러**` 보유
    - 해당 장치에 대한 업무 처리, 메인 CPU에 인터럽트를 발생시켜 보고하는 역할
- 인터럽트를 발생시키는 경우
    - 키보드 글자 입력 → 키보드의 컨트롤러가 인터럽트 발생시켜 CPU에 입력 발생 알림 → 수행하던 작업의 상태 저장 → 커널에 정의된 키보드 인터럽트 처리루틴을 찾아가고 → 입력 데이터를 프로그램에 전달하는 절차 수행 → 하던 일 다시 …
