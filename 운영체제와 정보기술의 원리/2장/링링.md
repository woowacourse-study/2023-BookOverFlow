# 2장. 운영체제 개요

## 운영체제의 정의

운영체제랑 컴퓨터 하드웨어 바로 윗단에 설치되는 소프트웨어를 뜻한다. 

운영체제는 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층이다. 

소프트웨어가 컴퓨터 시스템에서 실행되기 위해서는 메모리에 그 프로그램이 올라가 있어야 한다. 
운영체제 자체도 하나의 소프트웨어로서 전원이 켜짐과 동시에 메모리에 올라간다. 

하지만 운영체제처럼 큰 프로그램이 모두 메모리에 올라가면 한정된 메모리 공간의 낭비가 심할 것이다. 
따라서 운영체제 중 항상 필요한 부분만을 전원이 켜짐과 동시에 메모리에 올려놓는데, 이 때 메모리에 상주하는 운영체제의 부분을 **커널(kernel)**이라고 부르며, 이를 좁은 의미의 운영체제라고도 부른다.

</br>

## 운영체제의 기능

운영체제의 주요 기능은 

**컴퓨터 시스템 내의 자원을 효율적으로 관리하는 것** 

자원 : CPU, 메모리, 하드디스크 등 하드웨어 자원뿐 아니라 소프트웨어 자원까지를 통칭

**컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공하는 것**

</br>

## 운영체제의 분류

### 운영체제는 동시 작업을 지원하는지의 여부에 따라

**단일작업용 운영체제**

한번에 하나의 프로그램만 실행가능. 초창기 운영체제의 대부분이 단일작업용

예) DOS

**다중작업용 운영체제**

최근의 운영체제는 동시에 2개 이상의 프로그램을 처리할 수 있는 다중 작업 지원

예) MS 윈도우, 유닉스

CPU의 작업시간을 여러 프로그램들이 조금씩 나누어 쓰는 시스템을 시분할 시스템이라고 부른다. 

메모리 공간을 분할해 여러 프로그램들을 동시에 메모리에 올려놓고 처리하는 시스템을 다중 프로그래밍 시스템(multi-programming system)이라고 부른다.

반면 다중처리기 시스템 (mulit-processor system)은 하나의 컴퓨터 안에 CPU가 여러개 설치된 경우를 뜻한다.

</br>

### 운영체제를 분류하는 또 다른 기준으로는 다중 사용자에 대한 동시 지원 여부

**단일 사용자용 운영체제**

한번에 한명의 사용자만이 사용하도록 허용

예) 이메일 서버, 웹서버 등

**다중 사용자용 운영체제**

여러 사용자가 동시에 좁속해 사용하도록 허용 

</br>

### 작업을 처리하는 방식

**일괄처리 방식 (batch processing)**

요청된 작업을 일정량씩 모아서 한꺼번에 처리하는 방식, 모든 작업이 완전히 종료된 후 결과를 얻을 수 있다. → 사용자 입장에서는 응답시간이 길다는 단점

**시분할 방식**

여러 작업 수행 시 컴퓨터의 처리 능력을 일정한 시간 단위로 분할해 사용하는 방식

현대의 범용 컴퓨터 대부분이 사용하는 방식.

**실시간 운영체제 (real time)**

정해진 시간안에 어떠한 일이 반드시 처리됨을 보장해야하는 시스템에서 사용.

예) 원자로, 공장 제어 시스템, 미사일 제어 시스템 등

시간 제약의 중요성에 따라 또 두가지로 나눌 수 있다. → 경성 실시간 시스템(hard realtime system) - 원자로 등, 연성 실시간 시스템(soft realtime system) - 동영상 스트리밍 등

</br>

## 운영체제의 자원 관리 기능

**하드웨어 자원**

CPU와 메모리를 비롯해 주변장치 또는 입출력 장치(보조기억장치-하드디스크, 키보드, 모니터 등)라 불리는 장치들로 구성된다.

**소프트웨어 자원**

</br>

### CPU 관리

CPU 스케줄링 : 매 시점 어떠한 프로세스에 CPU를 할당해 작업을 처리할 것인지 결정하는 일

CPU 스케줄링의 목표는 CPU를 가장 효율적으로 사용하면서도, 특정 프로세스가 불이익을 당하지 않도록 하는 것이다.

대표적인 CPU 스케줄링 기법

**선입선출**

CPU를 사용하기 위해 도착한 프로세스들 중 먼저 온 것을 먼저 처리해주는 방식.

CPU 자체의 효율적인 사용 측면에서는 문제가 없지만 전체 시스템 입장에서는 비효율적인 결과를 초래할 가능성이 있다. 
짧은 수행시간을 가진 프로세스들은 실행시간 이 긴 선행 프로세스가 작업을 마칠 떄까지 기다려야하는데, 이를 보완하기 위한 것이 라운드 로빈이다.

**라운드 로빈**

CPU를 한번 할당받아 사용할 수 있는 시간을 일정하게 고정된 시간으로 제한한다. 

라운드 로빈에서는 긴 작업을 수행하는 프로세스 때문에 무작정 기다려야하는 상황은 막을 수 있다.

그렇다면 사용시간을 얼마로 할당할까? 일반적으로 1회 할당 시간은 밀리초 단위를 사용한다.

**우선순위**

CPU 사용을 위해 대기 중인 프로세스들에 우선순위를 부여하고 운선운위 순으로 CPU를 할당한다. 
추가적으로 기다린 시간이 긴 프로세스에게 우선순위를 높여주는 것도 가능하다. 

</br>

### 메모리

운영체제의 또 다른 중요 관리 대상으로 메모리가 있다.

메모리 : CPU가 직접 접근할 수 있는 컴퓨터 내부의 기억장치이다. 

프로그램이 CPU에서 실행되기 위해서는 해당 부분이 메모리에 올라가 있어야 한다. 그래서 메모리 공간이 효율적으로 사용되어야 한다.

다수의 프로그램이 동시에 메모리에 올라간 경우 서로 다른 프로세스의 영역을 침범하지 않도록 보안을 유지하는 역할도 운영체제의 몫이다. 각 프로세스가 자신의 메모리 영역에만 접근할 수 있도록 해야한다. 

</br>

### 물리적 메모리를 관리하는 방식

**고정 분할 (fixed partition)**

물리적 메모리를 몇개의 분할로 미리 나누어 관리. 융통성이 없다. 동시 적재되는 최대 프로그램의 수가 분할 개수로 한정.분할의 크기보다 큰 프로그램은 적재 불가능 → 메모리 효율 사용 불가

분할이 고정적이어서 분할의 크기보다 작은 프로그램이 적재되는 경우 해당 분할 내에 남은 영역이 발생하는데 이를 내부 조각(internal fragmentation)이라고 한다.

**가변 분할 (variable partition)**

매 시점 프로그램의 크기에 맞게 메모리를 분할해서 사용하는 방식. 따라서 분할의 크기 떄문에 큰 프로그램의 실행이 제한되는 문제는 발생하지 않는다. 그러나 물리적 메모리의 크기보다 더 큰 프로그램의 실행은 여전히 불가능하다.

내부 조각은 발생하지 않지만 외부조각이 발생할 수 있다.

Buddy = fixed+variable 형태 있는데 이건 나중에 알려주겟지?

**가상 메모리 (virtual memory)**

현대의 범용 컴퓨터 환경에서 가장 널리 사용되는 메모리 관리 기법이다. 이 기법은 물리적 메모리보다 더 큰 프로그램이 실행되는 것을 지원한다. 

모든 프로그램은 물리적 메모리와는 독립적으로 0번지부터 시작하는 자신만의 가상 메모리 주소를 갖는다. 운영체제는 이 가상메모리의 주소를 물리적 메모리 주소로 매핑하는 기술을 이용해 주소를 변환시킨 후 프로그램을 물리적 메모리에 올리게 된다. 

프로그램 전체의 크기가 물리적 메모리의 크기보다 크더라도 전체를 모두 메모리에 올리는 것이 아닌 현재 사용되는 부분만 메모리에 올리고 나머지는 하드디스크와 같은 보조 기억 장치에 저장해 두었다가 필요할 때 적재하는 방식을 취한다. 이 때 사용되는 보조 기억장치의 영역을 **스왑영역**이라고 부른다. 프로그램을 구성하는 가상메모리 주소 공간은 **페이지(page)**라는 동일한 크기의 작은 단위로 나뉘어 물리적 메모리와 스왑 영역에 일부분씩 저장된다. 이렇게 동일한 단위로 메모리를 나누는 기법을 페이징 기법이라고 한다. 

</br>

### 인터럽트

주변 장치 및 입출력 장치는 CPU나 메모리와 달리 인터럽트라 불리는 메커니즘을 통해 관리가 이루어진다. 

주변 장치들은 CPU의 서비스가 필요한 경우에 신호를 발생시켜 서비스를 요청하는데, 이때 발생시키는 신호를 인터럽트라고 한다. 

운영체제는 인터럽트 처리 직전에 수행 중이던 작업의 상태를 저장해 둔다. 

인터럽트는 요청하는 장치와 발생 상황에 따라 다양한 종류가 있기 떄문에 운영체제는 인터럽트의 종류마다 서로 다른 인터럽트 처리 루틴을 가지고 있다. 이것은 운영체제 커널 내에 존재하는 코드로 CPU 스케줄링, 메모리 관리 루틴 등 다양한 기능을 위한 커널 코드의 일부분이라고 할 수 있다.
