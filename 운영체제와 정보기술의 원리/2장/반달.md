# 2장 | 운영체제 개요

## 1. 운영체제의 정의
- 컴퓨터를 작동시키기 위해서 필요한 기본적인 소프트웨어
- 사용자 입장에서는 하드웨어 자체를 다루는 것이 쉽지 않으므로 운영체제의 도움을 받음
- 운영체제 전부가 메모리에 올라가는 것이 아닌 항상 필요한 부분만 메모리에 올라가게 된다.
    - 메모리에 상주하게 되는 운영체제의 부분을 커널(kernel)이라고 부르며, 이를 좁은 의미의 운영체제라고 부름
- 넓은 의미의 운영체제는 커널뿐만 아니라 시스템을 위한 유틸리티들을 광범위하게 포함하는 개념

## 2. 운영체제의 기능

### 1. 하드웨어를 위한 역할

- 컴퓨터 시스템 내의 자원을 효율적으로 관리하는 것이 중요한 핵심 기능
    - 이러한 역할 때문에 운영체제를 자원관리자라고도 한다.
    - 여기서 자원이란 CPU, 메모리와 같은 하드웨어적 자원 뿐만 아니라 소프트웨어 자원까지 통틀어 뜻함
- 전체적인 성능을 향상키기려다 보면 일부 프로그램 또는 사용자가 불이익을 당할 수 있다.
    - 따라서 사용자 및 프로그램들 간에 자원이 형평성 있게 분배되도록 하는 균형자 역할도 필요
- 효율성이 가장 큰 목표이지만, 이로인해 일부가 지나치게 희생되는 것도 고려해야하는 형평성 역시 운영체제가 고려해야할 중요한 목표
- 보안 및 보호의 기능 또한 수행해야함
- 정리하자면 효율성관리, 형평성관리, 보안관리가 주된 일이다.

### 2. 사용자를 위한 역할

- 운영체제가 여러 사용자 및 프로그램들에게 각각 독자적으로 컴퓨터를 사용하는 것과 같은 환상을 제공하는 것
- 운영체제는 사용자에게 추상화된 컴퓨터를 제공하며 사용자는 하드웨어의 다루는 데 자세한 원리를 알 필요가 없다.

## 3. 운영체제의 분류

동시 작업을 지원하는지 여부에 따라 다음과 같이 두가지로 분류

- 단일작업(single tasking)용 운영체제
    - 한 번에 하나의 프로그램만 실행시킬 수 있음.
    - 초창기 운영체제의 형태
    - 윈도우가 나오기 전 DOS가 이에 해당
- 다중작업(multi tasking)용 운영체제
    - 동시에 2개 이상의 프로그램을 처리할 수 있는 다중 작업을 지원
    - CPU가 하나밖에 없어서 매 순간 하나의 프로그램만 CPU에서 실행될 수 있더라도 CPU의 처리 속도가 워낙 빨라 밀리초 이내의 짧은 시간 규모로 여러 프로그램들이 CPU에서 번갈아 실행되면 사용자 입장에서 여러 프로그램이 동시에 실행되는 것처럼 보인다. → 이런 시스템을 시분할 시스템이라고 한다.
    - 여러 프로그램들이 조금씩 메모리 공간을 보유하며 동시에 메모리에 올라가게하여 처리하는 시스템을 다중 프로그래밍 시스템이라고 한다. → 대화형 시스템(interactive system)이라고도 한다.
    - 다중작업, 시분할, 다중 프로그래밍, 대화형 시스템은 모두 여러 프로그램이 하나의 컴퓨터에서 동시에 실행된다.
    - 다중처리기 시스템(multi-processor system)은 하나의 컴퓨터 안에 CPU가 여러 개 설치된 경우를 뜻하므로 앞의 용어들과는 다르다.

다중 사용자에 대한 동시 지원 여부

- 단일 사용자용 운영체제
    - 한 번에 한 명의 사용자만이 사용하도록 허용하는 운영체제
    - DOS와 같이 하나의 작업만 수행할 수 있는 경우
- 다중 사용자용 운영체제
    - 여러 사용자가 동시에 접속해 사용할 수 있게 하는 운영체제
    - 대표적으로 서버

작업을 처리하는 방식

- 일괄처리 방식 (batch processing)
    - 요청된 작업을 일정량씩 모아서 한꺼번에 처리하는 방식
    - 처리해야할 여러 작업들을 모아 일정량이 쌓이면 일괄적으로 처리하고 모든 작업이 완료되어야 결과를 얻을 수 있다.
    - 사용자가 응답받기에 시간이 길다는 단점이 있음
    - 초창기 컴퓨터에 사용된 펀치카드처리 시스템이 이런 일괄처리 방식
- 시분할 방식 (time sharing)
    - 여러 작업을 수행할 때 컴퓨터의 처리 능력을 일정한 시간 단위로 분할해 사용하는 방식
    - 현대의 범용 컴퓨터가 대부분 시분할 방식을 사용한다.
    - 인간이 인지할 수 없는 아주 짧은 단위로 작업을 번갈아 처리하기 때문에 사용자 입장에선 일괄처리 방식에 비해 빠른 응답을 받을 수 있다.
    - 사용자의 요청에 대해 결과를 곧바로 얻을 수 있는 시스템이라 대화형 시스템이라고도 표현
- 실시간 (real time)
    - 정해진 시간안에 어떠한 일이 반드시 처리 됨을 보장해야 하는 시스템에서 사용된다.
    - 시간 제약의 중요성에 따라 다음과 같이 두 가지로 세분화 된다.
        - 경성 실시간 시스템(hard realtime system)
            - 주어진 시간을 지키지 못할 경우 매우 위험한 결과를 초래할 수 있는 로켓 원자로 제어시스템 등을 말함
        - 연성 실시간 시스템(soft realtime system)
            - 멀티미디어 스트리밍 시스템과 같이 데이터가 정해진 시간 단위로 전달되어야 올바른 기능을 수행할 수 있는 시스템을 말한다.
            - 상대적으로 경성 실시간 시스템에 비해 시간제약을 지키지 못했을 때 위험한 일이 초래되진 않는다.

## 4.  운영체제의 예

### MS 윈도우

- 마이크로소프트 사에서 MS-DOS와 윈도우 3.1 등을 발전 시킨 PC 운영체제이다.
- MS-DOS는 초보자가 사용하기 어려웠음
- 윈도우는 초보자가 사용하기는 괜찮았으나 이 또한 MS-DOS로 부터 독립적으로 실행할 수 없었다.
- 이걸 해결하여 독자적으로 실행되는 그래픽 인터페이스 기능을 가진 윈도우 95가 탄생했다.
- 이후 98, XP, vista, 7, 10에 이르게 되었다.
- XP 부터는 그래픽 환경과 명령어로 사용하는 환경 둘 다 지원
- 또다른 특징으로 시스템에 새로운 하드웨어를 장착하면 운영체제가 자동으로 하드웨어를 감지하여 그에 맞게 설정되는데 이걸 플러그 앤 플레이(plug and play)라고 한다.
- 유닉스 보단 안전성이 떨어졌지만 사용하기가 편리하다는 장점으로 대중들에게 보편화 되었다.

### 유닉스

- 1969년 벨 연구소에서 최초로 개발된 것으로 운영체제 분야에서는 주목할만한 사례
- 개발환경을 위해 설계된 운영체제로 이식성이 좋고 운영체제 커널의 크기가 작고, 소스코드가 공개되어있다.
- 확장성을 지원해 현재까지도 사용하고 있음
- 당시 대부분의 운영체제는 어셈블리로 작성되었다는 반면 유닉스는 C언어로 작성되었다.
- 리눅스의 등장으로 개인용 컴퓨터에서도 유닉스를 널리 사용할 수 있게 되었다.
- 안정성이 제일 큰 장점
- 그래픽 인터페이스를 지원하는 프로그램이 개발되면서 초보자도 쉽게 사용할 수 있는 방법이 제공되고 있다.

## 5. 운영체제의 자원 관리 기능

### 운영체제의 기능

- CPU 스케쥴링
    - 어떤 프로그램에 CPU를 줄 것인가?
- 메모리 관리
    - 한정된 메모리를 어덯게 나누어 사용할 것인가?
- 파일 관리
    - 디스크에 파일을 어떻게 보관할 것인가?
- 입출력 관리
    - 각기 다른 입출력 장치와 컴퓨터 간에 어떻게 정보를 주고받을 것인가?
- 프로세스 관리
    - 프로세스의 생성과 삭제
    - 자원 할당 및 반환
    - 프로세스 간 협력
- 그 외
    - 보호 시스템
    - 네트워킹
    - 명령어 해석기

### CPU 스케쥴링

CPU가 하나밖에 없는 가장 기본적인 컴퓨터 구조에서도 프로세스는 여러개가 동시에 수행될 수 있다.
그러므로 매 시점 어떠한 프로세스에 CPU를 할당해 작업을 처리할 것인지 결정하는 일이 필요하다.
CPU 스케쥴링의 목표는 가장 효율적으로 CPU를 사용하면서도 특정 프로세스가 불이익 당하지 않도록 하는 것

대표적인 CPU 스케쥴링 기법

- 선입선출 (First Come First Serve)
    - CPU를 사용하기 위해 도착한 프로세스들 중 가장 먼저 온걸 먼저 처리해주는 방식
    - 전체 시스템 입장에서 비효율적인 결과를 초래할 가능성이 있음
        - 긴 수행시간을 가진 프로세스가 먼저 오고 짧은 수행시간을 가진 프로세스가 온다면 긴 수행시간을 가진 프로세스가 끝나기 전까지 짧은 수행시간을 가진 프로세스는 계속해서 대기해야함
- 라운드 로빈(Round Robin)
    - 선입선출 기법을 보완하기 위해 탄생한 기법
    - CPU를 한 번 할당받아 사용할 수 있는 시간을 일정하게 고정된 시간으로 제한함
    - 긴 수행시간을 가진 프로세스 더라도 일정 시간 CPU를 사용하면 CPU 대기열의 제일 뒤로 가야함
- 우선순위(priority)
    - CPU 사용을 위해 대기중인 프로세스들에 우선순위를 부여
    - 상대적으로 더 중요한 프로세스의 우선순위를 높여 CPU를 먼저 획득할 수 있게 함
    - 지나치게 오래기다리는 프로세스가 발생하지 않도록 우선순위를 점차 높여주는 방안도 활용될 수 있음

### 메모리

메모리는 CPU가 직접 접근할 수 있는 컴퓨터 내부의 기억장치

프로그램이 CPU에서 실행되려면 해당 부분이 메모리에 올라가 있어야함

메모리의 어느 부분이 어떤 프로그램에 의해 사용되고 있는지를  파악하여 이를 유지하게 되는데, 이러한 정보는 주소를 통해 관리된다.

물리적 메모리를 관리하는 방식

- 고정분할(fixed partition) 방식
    - 물리적 메모리를 몇 개의 분할로 미리 나누어 관리
    - 나뉜 영역은 하나의 프로그램만 적재될 수 있다.
    - 메모리에 동시 적재되는 최대 프로그램의 수가 분할 개수로 한정됨 → 융통성이 없음
    - 분할한 영역 100에 80에 일을 한다면 20의 공간은 낭비가 된다 → 내부조각
- 가변분할(variable partition) 방식
    - 매 시점 프로그램의 크기에 맞게 메모리를 분할해서 사용하는 방식
    - 분할의 크기 때문에 큰 프로그램의 실행이 제한되는 문제는 발생하지 않음
    - 내부조각은 발생하지 않지만 외부조각은 발생할 수 있음
    - 외부조각 → 프로그램에 할당되지는 않았지만 그 크기가 작아 프로그램을 올리지 못하는 경우
- 가상메모리(virtual memory) 방식
    - 현대의 범용 컴퓨터 환경에서 가장 널리 사용되는 메모리 관리 기법
    - 물리적 메모리 보다 더 큰 프로그램이 실행이 될 수 있다.
    - 모든 프로그램은 물리적 메모리보다 더 큰 프로그램이 실행되는 것을 지원.
    - 모든 프로그램은 물리적 메모리와는 독립적으로 0번지부터 시작하는 자신만의 가상메모리 주소를 가짐.
    - 운영체제는 이 가상메모리의 주소를 물리적 메모리 주소로 매핑하는 기술을 이용해 주소를 변환시킨 후 프로그램을 물리적 메모리에 올림
    - 가상 메모리 기법에서는 물리적 메모리의 크기와 상관없이, 사용할 수 있는 메모리의 크기가 충분히 크다고 가정하고 프로그램을 개발할 수 있음.
    - 프로그램의 크기가 크더라도 항상 동시에 전체가 사용되는 것은 아니므로 필요한 부분만 메모리에 올리고 나머지는 보조기억장치에 저장해두었다 필요할 때 적재하는 방식
    - 이 때 사용되는 보조기억장치의 영역을 스왑 영역(swap area)이라 한다.
    - 프로그램을 구성하는 가상메모리 주소 공간은 페이지(page)라는 동일한 크기의 작은 단위로 나뉘어 물리적 메모리와 스왑 영역에 일부분씩 저장됨.
    - 동일한 메모리를 나누는 기법을 페이징(paging) 기법 이라고 한다.

### 인터럽트
- 주변장치 및 입출력 장치는 CPU나 메모리와 달리 인터럽트(interrupt)라는 매커니즘을 통해 관리된다.
- 주변장치들은 CPU의 서비스가 필요한 경우 신호를 발생시켜 서비스를 요청하는데, 이때 발생시키는 신호를 인터럽트라고 한다.
- CPU는 평소에 주어진 작업을 하다가 인터럽트가 발생하면 하던 일을 잠시 멈춰 인트럽트에 의한 요청 서비스를 수행한다.
- 운영체제는 인터럽트를 처리한 후 원래 수행하던 작업으로 돌아오기 위해 인터럽트 처리 직전에 수행 중이던 작업의 상태를 저장해둔다.

### 인터럽트 처리 루틴
- 인터럽트가 발생했을 때 해주어야 할 작업을 정의한 프로그램 코드
- 운영체제 커널 코드의 일부분이며 인터럽트가 발생하면 운영체제는 해당하는 인터럽트 처리루틴을 찾아서 정의된 코드에 따라 일을 수행하게 된다.

### 컨트롤러
- 주변장치들의 각 장치마다 그 장치에서 일어나는 업무를 관리하기위한 일종의 작은 CPU
- 해당 장치에 대한 업무를 처리하고, 이를 메인 CPU에 인터럽트를 발생시켜 보고하는 역할

### 인터럽트가 발생했을 시 주변장치와 CPU 처리 과정
1. 키보드에 사용자가 입력
2. 키보드 컨트롤러가 인터럽트를 발생시켜 CPU에 알림
3. CPU는 현재 작업 상태 저장
4. 커널 코드에 정의된 키보드 인터럽트 처리 루틴을 찾음
5. 키보드 인터럽트 처리 루틴은 키보드로부터 입력받은 내용을 메모리에 특정 부분에 저장
6. 해당 프로그램에 키보드 입력이 들어왔음을 알리게 되고 인터럽트 처리완료
7. 인터럽트가 발생하기 직전의 상태를 복구시켜 중단되었던 작업 재개
