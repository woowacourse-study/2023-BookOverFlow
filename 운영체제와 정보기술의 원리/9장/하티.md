# 09. 디스크 관리

## 디스크

- 컴퓨터 시스템의 대표적인 2차 저장장치
- 메모리 → 휘발성 저장장치이므로, **영구한 보관**을 위해 디스크와 같은 2차 저장장치가 필요하다.

## 디스크의 구조

- 디스크 외부에서 → 디스크를 **일정한 크기의 저장공간**들로 이루어진 1차원 배열로 취급
    - 일정한 크기의 저장공간: `논리블록 (logical block)`
- 논리블록 단위로 데이터 저장, 입출력 시 전송 단위
- 배열을 접근하듯이, 해당 **논리블록의 인덱스 번호**를 디스크에 전달한다.
    - `섹터 (sector)`: 논리블록이 저장되는 디스크 내의 물리적인 위치
    - 섹터 : 논리블록 = 1 : 1
- 물리적인 구조
    - 마그네틱 원판
    - 하나의 원판 = 트랙 (track)
    - 각 트랙은 섹터로 나뉨
    - `실린더 (cylider)`: 여러 개의 원판에서 상대적 위치가 동일한 트랙들의 집합
    - `암 (arm)`이 해당 섹터가 위치한 실린더로 이동한 후, 워난이 회전하여 디스크 헤드가 저장된 섹터 위치에 도달 → 읽고쓰기..

## 디스크 스케줄링

- **접근시간 (access time)** = 탐색시간, 회전지연시간, 전송시간
- 탐색시간 (seek time)
    - 디스크 헤드를 해당 실린더 위치로 이동시키는 데 걸리는 시간
    - 데이터가 원판의 안쪽 혹은 바깥쪽에 있느냐에 따라 헤드를 움직이는 데 걸리는 시간
- 회전지연시간 (rotational latency)
    - 디스크가 회전해서 읽고 쓰려는 섹터가 헤드 위치에 도달하기까지 걸리는 시간
- 전송시간 (transfer time)
    - 해당 섹터가 헤드 위치에 도달한 후, 실제 섹터에 데이터를 읽고 쓰는 데 걸리는 시간
- 효율
    - 입출력의 효율을 높이려면 → 접근시간 최소화
    - 회전지연/전송 시간은 상대적으로 수치가 작고, 운영체제가 통제하기 힘들다.
    - 즉, 접근시간을 최소화하기 위해 운영체제는 **탐색시간**을 줄이고,
        
        탐색시간을 줄이기 위해 **헤드의 움직임을 최소화하는 스케줄링 작업**을 한다.
        
    - 디스크 스케줄링 (disk scheduling): 효율적인 디스크 입출력을 위해 **여러 섹터들에 대한 입출력 요청**을 **어떤 순서로 처리할 것인지** 결정하는 매커니즘
        
        → 디스크 헤드의 이동거리 줄이기 ! (엘리베이터 스케줄링이랑 비슷하다)
        

### FCFS 스케줄링

- 말그대로 선착순
- 디스크의 양쪽 끝을 번갈아 도착하면 최악의 상황

### SSTF 스케줄링

- Shortest Seek Time First
- 현재 위치로부터 가장 가까운 위치에 있는 요청을 제일 먼저 처리하는 알고리즘
- 장점: 헤드의 이동거리를 줄여 디스크 입출력의 효율성 증가
- 단점: 기아 현상 발생 가능
- 이동거리 측면에서 가장 우수하지도 않다 !

### SCAN 알고리즘

- 헤드가 디스크 원판의 안쪽 끝, 바깥쪽 끝을 오가며, 그 경로에 존재하는 모든 요청을 처리
- e.g. 버스가 경로를 따라 이동하면서 승객들을 태우는 것과 비슷하다.
- 또한, 엘리베이터 스케줄링 알고리즘과도 비슷해서, **엘리베이터 스케줄링 알고리즘** 이라고도 부른다.
- 불필요한 헤드의 이동 X, 기아 현상 X → 효율성과 형평성이 모두 만족됨
- 다만, 제일 안쪽/바깥쪽보다 가운데가 기다리는 평균시간이 더 짧다 (공평하지 않다)

### C-SCAN 알고리즘 (Circular-SCAN)

- SCAN처럼 한쪽 끝 → 반대쪽 끝으로 이동하며 모든 요청을 처리한 후,
    
    → 곧바로 출발점으로 **이동만** 한다
    
- SCAN에 비하여 이동거리는 길어지지만, 탐색시간의 편차가 줄어든다.

### LOOK과 C-LOOK 알고리즘

- LOOK
    - SCAN처럼 한쪽 끝 → 반대쪽 끝으로 이동하다가, 그 방향에 더 이상 **대기 중인 요청이 없으면 방향을 바꾼다.**
- C-LOOK
    - 한쪽 방향으로만 이동하는데, 전방에 요청이없을 때 방향을 바꾼다.

## 다중 디스크 환경에서의 스케줄링

- 다중 디스크의 사용
    - 포털사이트 등 수많은 동시 사용자를 서비스하는 서버
    - 동일 정보를 여러 디스크에 중복 저장 → 인기 있는 데이터를 동시에 서비스 가능, 일부 디스크에 오류가 발생해도 서비스 지속 가능, 정보의 유실 방지
    - 즉, 시스템의 성능과 신뢰성 향상
- 다중 디스크 스케줄링 문제
    - 여러 개의 디스크 중 어느 디스크에서 요청을 처리할 것인가?
    - 디스크 내의 입출력 요청의 처리 순서 결정 **+ 작업을 수행할 디스크 결정**
    - e.g. 탐색 시간을 줄이고 싶다 ⇒ 헤드의 현재 위치가 요청한 데이터와 가장 가까운 디스크 선택
- **디스크 간의 부하균형 (load balancing)**을 이루도록 스케줄링 중요
    - 많은 요청을 동시에 처리할 수 있도록, 일부 디스크가 과부하 상태에 이르지 않도록
        
        모든 디스크에 요청을 골고루 분배
        
- **전력 소모를 줄이는 것** 역시 최근 중요
    - 전력을 절감하기 위해, 일부 디스크에 요청을 집중시키고 나머지 디스크는 회전을 정지시키는 것이 효율적
    - e.g. 사용자가 많지 않으면 엘리베이터 한 대만 운영하는 것이 효과적

## 디스크의 저전력 관리

### 비활성화 기법

- 디스크의 상태 (by 전력 소모 기준)
    - **활동(active) 상태**: 현재 헤드가 데이터를 읽거나 쓰고 있는 상태
    - **공회전(idle) 상태**: ****디스크가 회전 중이지만 데이터를 읽거나 쓰지는 않는 상태
    - **준비(standby) 상태**: 디스크가 회전하진 않지만 인터페이스가 활성화된 상태
    - **휴면(sleep) 상태**: 디스크가 회전도 안하고, 인터페이스도 비활성화된 상태
    - 디스크가 정지하고 있는 상태가 전력 소모가 적다.
    - 각 상태로 전환할 때, 부가적인 전력 및 시간이 소모된다.
        - 후속 요청까지의 시간 간격이 일정 시간 이상일 경우에만 디스크의 회전을 정지시키는 것이 전력 소모 절감에 효과적
        
        → 장치를 비활성화할 시점을 결정하기 위해 미래의 요청이 도착하는 시간과 간격을 예측하는 것이 중요하다
        
- 디스크를 비활성화하는 시점을 결정하는 방법
    - **시간기반(timeout based) 기법**: 일정 시간 동안 디스크가 공회전 상태이면 장치를 정지, 요청 오면 다시 활성화
    - **예측기반(prediction based) 기법**: 과거 요청을 관찰하여 다음 공회전 구간의 길이를 예측하여 비활성화 시점 결정
    - **확률기반(stochastic based) 기법**: 디바이스의 상태변경 시간 간격을 구하기 위해 확률분포를 통해 요청을 모델링, 통계적 모델 이용

### 회전속도 조절 기법

- 디스크의 전력 소모를 줄이기 위해 `디스크의 회전 속도(Rotations Per Minute: RPM)`를 가변적으로 조절하는 기법
- 운영체제에서 디스크의 회전속도를 관리하는 지능형 전력 관리 기법 연구 진행 중 → 하드웨어 혼자 전력 관리를 할 때보다 더 많은 전력 절감 효과
- 수많은 시도들..
    - 워크로드의 특성을 활용한 회전속도 조절 시도
    - 멀티미디어 환경에서 디스크 스케줄링 시도 (주기성, 규칙성으로 비교적 정확한 예측 가능)
    - 실시간 응용 프로그램의 재생률과 버퍼 크기에 따라 회전속도를 조절하는 기법 제안

### 디스크의 데이터 배치 기법

- 디스크의 용량은 매년 빠르게 증가하지만, 디스크의 접근 속도는 큰 발전이 없는 실정
- 디스크 내에 데이터의 복제본을 많이 만들어, 헤드 위치에서 가까운 복제본에 접근하도록 함으로써 빠른 응답시간과 전력 소모량 절감을 얻는 FS2 파일 시스템이 제안되었다.
    - 일관성 문제 → 가까운 복제본에 데이터를 쓰고 나머지 복제본들에 대해서는 주소 테이블에 무효화 연산만 수행

### 버퍼캐싱 및 사전인출 기법

- 미래에 요청될 데이터를 미리 알거나 예측할 수 있다면, 디스크 활성 상태일 때 헤드 위치로부터 가까운 데이터를 사전인출함으로써 → 디스크의 비활성화 가능성 증가+전력 소모 절감
- 긴급한 요청이 아닌 경우, 디스크의 활성 상태에 따라 요청을 지연시키는 방식으로 전력 소모 절감

⇒ 디스크가 저전력 모드일 때 입출력 처리를 최대한 지연시키고,

디스크가 정상 전력 모드로 돌아왔을 대 사전인출을 공격적으로 함

→ 디스크의 상태 변화 횟수를 최소화하는 방법 연구된 바 있다.

### 쓰기전략을 통한 저전력 디스크 기법

- 대상 디스크가 비활성 상태일 때에는 디스크 쓰기를 하지 않고 기다리다가, 활성 상태로 돌아왔을 때 쓰는 방식
- 대상 디스크가 비활성 상태일 때에는 일단 블록들을 로그 디스크에 썼다가, 활성 상태로 돌아왔을 때 쓰는 방식