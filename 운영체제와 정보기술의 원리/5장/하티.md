# 05. 프로세스 관리

## 프로세스의 개념

- process : program in execution 즉, 실행중인 프로그램

- 실행파일 형태로 디스크에 존재하던 프로그램이 - 메모리에 올라가 실행되기 시작하면 - 그것이 프로세스

- CPU를 획득해 자신의 코드를 수행하기도, CPU를 반환하고 입출력 작업을 수행하기도 함

### 프로세스 문맥
- 프로세스가 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보

- CPU를 다시 획득해 명령을 재개할 때, 직전 수행 시점의 정확한 상태를 재현하기 위해 필요한 정보

- 프로세스의 주소 공간, 레지스터에 보유하던 값이 무엇인지, 시스템 콜을 통해 커널에서 수행한 일의 상태, 커널이 관리하고 있는 각종 정보 등을 포함

- 분류: 하드웨어 문맥, 프로세스의 주소 공간, 커널 상의 문맥

- 하드웨어 문맥: CPU이 수행 상태. 프로그램 카운터값, 각종 레지스터에 저장하고 있는 값들

- 주소 공간: 코드, 데이터, 스택으로 구성되는 자기 자신만의 독자적인 주소 공간

- 커널 상의 문맥: PCB, 커널스택 등 프로세스를 관리하기 위한 자료구조 유지

## 프로세스의 상태
- 실행, 준비, 봉쇄

- 실행 running 상태
	+ CPU를 보유하고, 기계어 명령을 실행하고 있는 상태
	
	- 매 시점 실행 상태에 있는 프로세스는 단 하나 뿐

- 준비 ready 상태
	+ 프로세스가 CPU만 보유하면 당장 명령을 실행할 수 있지만 할당받지 못한 상태

- 봉쇄 blocked/wait/sleep 상태
	+ CPU를 할당받더라도 당장 명령을 실행할 수 없는 상태

	- e.g. 입출력 작업이 진행 중인 경우

- 상태를 구분하는 이유: 컴퓨터 자원을 효율적으로 관리하기 위함

- 시작 상태
	+ 프로세스가 시작되고 자료구조도 생성되었지만 메모리 획득을 승인받지 못한 상태
	
- 완료 상태
	+ 프로세스가 종료되었지만 관련 자료구조를 완전히 정리하지 못한 상태
	
- 하나의 프로세스는 하나의 상태에 머무르고, 시간이 흐름에 따라 변화

- 문맥교환 (context switch): 실행 프로세스를 변경하기 위해, 기존 프로세스의 문맥을 저장하고, 새로운 프로세스의 문맥을 세팅하는 과정

- CPU 디스패치 (dispatch): 준비 상태의 프로세스들 중 CPU를 할당받을 프로세스를 선택한 후 실제로 제어권을 넘겨받는 과정

- 입출력을 요청한 프로세스의 상태 변화
    - 실행 상태인 프로세스(A) → CPU를 할당받고 기계어 명령을 하나씩 수행하는 중
    
    - 입출력 명령이 포함된 경우 → 이 작업은 상대적으로 오래 걸리는 작업 → CPU를 점유하고 있어도 후속 명령 수행 불가 → CPU 낭비
    
    - 그러므로 입출력이 완료될 때까지 CPU를 반환한 다음, 봉쇄 상태로 바뀜
    
    - CPU 스케줄러는 준비 상태의 프로세스들 중 하나를 선정해 CPU를 할당, 해당 프로세스(B)는 실행 상태로 변경
    
    - 입출력을 요청한 프로세스(A)는 디스크 컨트롤러로부터 서비스를 받음(==원하는 데이터를 읽어옴)
    
    - 입출력이 완료되면, 디스크 컨트롤러가 CPU에 인터럽트를 발생시킴
    
    - CPU는 인터럽트가 발생됨을 확인하고, 그에 대응하는 루틴을 수행
    
    - 이 때, 수행되던 프로세스(B)는 사용자모드 실행 상태 → 커널모드 실행 상태로 변경
    
    - 입출력이 완료된 프로세스(A)의 상태는 봉쇄 상태 → 준비 상태가 되고, 장치의 로컬버퍼에 있는 내용을 메모리로 이동시킴
    
    - 인터럽트 처리가 끝나면, 인터럽트 처리루틴 이전에 수행되는 프로세스에 CPU를 다시 할당함 <br/>
    (입출력이 완료된 프로세스가 더 우선순위가 높은 경우, 문맥교환을 통해 CPU제어권을 이양시킬 수 있음)

## 프로세스 제어블록 (PCB)

- Process Control Block: 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조

### 구성

- 프로세스의 상태
    - CPU를 할당해도 되는지 여부를 결정하기 위함
- 프로그램 카운터값
    - 다음에 수행할 명령의 위치를 가리킴
- CPU 레지스터값
    - CPU 연산을 위해 현 시점에 레지스터에 어떤 값을 저장하고 있는지
- CPU 스케줄링 정보
    - 프로세스의 CPU 스케줄링을 위해 필요한 정보
- 메모리 관리 정보
    - 메모리 할당을 위해 필요한 정보
- 자원 사용 정보
    - 자원 사용 요금을 계산해 청구하는 등의 용도
- 입출력 상태 정보
    - 프로세스의 입출력 관련 상태 정보

## 문맥교환 (Context Switch)

- 문맥교환: 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정

- 예시
    - 프로세스 A 실행 중 → 타이머 인터럽트가 발생 <br/> → CPU의 제어권은 운영체제에게 넘어감 <br/> → 운영체제는 인터럽트 처리루틴으로 가고, 직전까지 수행 중이던 A의 프로세스 문맥을 저장, 새로운 B에게 CPU 이양 <br/> → A는 준비 상태, B는 실행 상태가 됨 <br/> → A는 자신의 문맥을 PCB에 저장, B는 자신의 문맥을 PCB로부터 복원
    
- 타이머 인터럽트가 발생하는 경우, 실행 중이던 프로세스가 봉쇄 상태가 되는 경우 (입출력 요청, 다른 조건 등을 충족하지 못해 CPU를 회수당했을 때) 등에 문맥교환이 발생됨

- 시스템 콜, 인터럽트 등에 의해 CPU의 제어권이 운영체제로 넘어와 커널의 코드가 실행되는 경우 ⇒ 문맥교환 X. 실행모드가 사용자 모드→커널모드로 바뀌었을 뿐
    - 모드 변경에 비해, 문맥교환에는 훨씬 많은 overhead가 뒤따름 (문맥교환에 소요되는 시간 등)
    
- CPU 할당시간이 너무 작다면 → 문맥교환이 빈번하게 발생, 오버헤드가 매우 커짐
    
    CPU 할당시간이 너무 크다면 → 시분할 시스템의 의미가 퇴색
    
    적절한 할당시간을 정하는 것이 중요하다!
    

## 프로세스를 스케줄링하기 위한 큐

- 준비 상태에 있는 프로세스들을 줄 세우기 위한 `**준비 큐 (ready queue)**`

- 준비 큐의 맨 앞에 있는 프로세스에 먼저 CPU를 할당함
    - 줄 세우는 방법은 CPU 스케줄링 방법에 따라 달라짐
    
- 특정 자원을 기다리는 프로세스들을 줄 세우기 위한 `**장치 큐 (device queue)**`
    - e.g. 디스크에 입출력 서비스를 요청한 프로세스들 → 디스크 입출력 큐 (disk I/O queue)
        
        줄 서 있는 순서대로 입출력 작업 수행 → 작업이 완료되면 인터럽트 발생 → 작업이 완료된 프로세스는 인터럽트 처리루틴에 의해 **I/O queue**에서 빠져나와 **ready queue**에 줄을 선다.
        
- 공유 데이터에 접근 역시 큐에 줄을 서 기다려야 함 - 데이터의 일관성을 유지하기 위해
- `**작업 큐 (job queue)**`: 시스템 내의 모든 프로세스를 관리하기 위한 큐. 프로세스의 상태와 무관하게, 현재 시스템 내의 모든 프로세스가 속하게 된다.
    - 준비 큐, 장치 큐의 프로세스들은 모두 작업 큐에 속해 있다.
    
- 운영체제가 어떻게 자료구조로 구현하는가?
    - 큐의 가장 앞부분에 큐헤더(queue header)가 있다
    
    - 큐는 각 프로세스의 PCB를 연결 리스트 형태로 관리하고, 포인터를 사용해 순서를 정한다.

## 스케줄러 (scheduler)

- 스케줄러: 어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드

### 장기 스케줄러 (long term scheduler)

- 작업 스케줄러 (job scheduler)

- 시작 상태의 프로세스들 중 어떠한 프로세스를 **준비 큐**에 진입시킬지 결정

- 특성
    - 수십 초, 수 분 단위로 가끔 호출됨 → 속도가 느려도 됨
    
    - 메모리에 동시에 올라가 있는 프로세스의 수를 조절
    
    - 현대의 시분할 시스템에는 장기 프로세스가 잘 없다.. (과거, 자원이 부족할 때 주로 사용됨) → 대신, 중기 스케줄러를 많이 사용

### 단기 스케줄러 (short term scheduler)

- CPU 스케줄러

- 준비 상태의 프로세스들 중 어떠한 프로세스를 다음 번에 **실행 상태**로 만들 것인지(== CPU를 할당할지) 결정
- 특성
    - 밀리초 정도의 시간 단위로 매우 빈번하게 호출됨 → 수행 속도가 빠름

### 중기 스케줄러 (medium term scheduling)

- 너무 많은 프로세스에 메모리를 할당해 시스템의 성능이 저하되는 경우, 이를 해결하기 위해 메모리에 적재된 프로세스의 수를 동적으로 조절

- 너무 많은 프로세스가 메모리에 적재 → 프로세스당 보유하는 메모리양이 아주 적어서 프로세스 주소공간도 메모리에 올리기 어려워지면 → 디스크 입출력이 수시로 발생, 성능 저하

- 메모리에 올라와 있는 프로세스 중 일부의 메모리를 통째로 빼앗아 디스크의 스왑 영역에 저장함 ： `**스왑 아웃 (swap out)**`

- 스왑 아웃을 시킬 프로세스 선정

    - 1 봉쇄 상태에 있는 프로세스들
        - 당장 CPU를 획득할 가능성이 없기 때문
        
    - 2 타이머 인터럽트가 발생해 준비 큐로 이동하는 프로세스
        - 당장 실행하게 될 프로세스에게 메모리를 추가로 부여하는 것이 더 효율적
        
- 중기 스케줄러의 등장으로 `**중지 상태**`가 추가됨

## 프로세스의 생성

- 시스템 부팅 후 **최초**의 프로세스는 운영체제가 직접 생성

- 그 이후는 이미 존재하는 프로세스(`부모 프로세스`)가 다른 프로세스를 복제 생성 (`자식 프로세스`)

- 이를 통해 프로세스는 족보와 같은 **계층**이 형성됨

- 자식 프로세스가 먼저 죽어, 이에 대한 처리는 부모 프로세스가 담당한다.
    - 모든 후손 프로세스들이 종료되어야 본인이 종료될 수 있다.

### 생성된 프로세스가 작업을 수행하기 위해 자원을 획득하는 방법

- 운영체제 및 자원의 종류에 따라 상이함
    - 운영체제로부터 직접 할당을 받을 수도, 부모 프로세스와 자원을 공유할 수도
    
- 프로세스가 수행되는 모델
    - 부모와 자식이 공존하며 수행되는 모델
        
        → 자식과 부모가 CPU를 획득하기 위해 경쟁관계가 됨
        
    - 자식이 종료(terminate)될 때가지 부모가 기다리는(wait) 모델
        
        → 부모: 봉쇄 상태 → 자식 프로세스가 종료 → 부모: 준비 상태
        
- 프로세스가 생성되면 자신만의 독자적인 주소 공간 (address space) 생김
    - 처음 생성 시에는 부모 프로세스의 주소 공간 내용을 그대로 복사하여 생성
    
    - 자식 프로세스가 다른 프로그램을 수행하기 위해 그 공간 위에 새로운 프로그램의 주소 공간을 덮어씌워 실행
- 프로세스 종료
    - 프로세스가 마지막 명령을 수행한 후 운영체제에 이를 알리는 자발적 종료
        - 명령을 모두 수행한 후, `exit()` 라는 시스템 콜을 통해 종료를 알림
        
        - 개발자가 명시적으로 호출하지 않아도 컴파일러가 자동으로 삽입함
        
    - 부모 프로세스가 자식 프로세스의 수행을 강제로 종료시키는 비자발적 종료
        - `abort()`라는 함수를 통해 이루어짐
        
        - (1) 자식 프로세스가 할당 자원의 한계치를 넘어서는 많은 양의 자원을 요구하는 경우
        
        - (2) 자식 프로세스에게 할당된 작업이 더 이상 필요하지 않는 경우
        
        - (3) 부모 프로세스가 종료되는 경우
- 프로세스 생성
    - 프로세스가 `fork()` 시스템 콜
        
        → CPU의 제어권이 커널에게 감 
        
        → 커널은 fork를 호출한 프로세스를 복제해 자식 프로세스를 생성 (모든 문맥이 그대로 복제됨, 프로세스 식별자만 다름) (부모의 과거 기억까지 모두 기억하고, 본인이 복제됨까지 기억하는..)
        
        → fork() 함수의 결괏값이 양수: 원본, 0: 복제본
        
    - 프로세스 주소 공간에 새로운 프로그램을 덮어씌우는 `exec()` 시스템 콜
        - 프로세스가 지금까지 수행했던 상태를 잊어버리고,
            
            그 주소 공간을 완전히 새로운 프로그램을 덮어씌운 후,
            
            새로운 프로그램의 첫 부분부터 다시 실행을 시작하도록 함
            
    - 자식 프로세스가 종료되기를 기다리며 부모 프로세스가 봉쇄 상태에 머무르도록 하는 `wait()` 시스템 콜
        - 부모 봉쇄 상태 → 자식 프로세스 종료 → 부모 준비 상태
        
        - 부모 프로세스 - 자식 프로세스 간의 동기화(synchronization) 가능

## 프로세스 간의 협력

- 프로세스는 각자 자신만의 독립적인 주소 공간을 갖고 수행

- 프로세스가 다른 프로세스의 주소 공간을 참조할 수 없음

⇒ 즉, 다른 프로세스와 정보를 주고받을 방법이 없으므로, 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미칠 수 없음

- 경우에 따라서는 프로세스들이 협력될 때 업무의 효율성이 증진될 수도 있다. - 부분적인 처리 결과나 정보를 공유, 처리 속도 향상 등 - ⇒ 프로세스 간의 **협력 메커니즘**을 제공

### IPC (Inter-Process Communication: 인터프로세스 커뮤니케이션)

- 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신

- 의사소통 기능 제공, 동기화 보장
    - 공유 데이터의 불일치 문제 발생 방지를 위해..
    
    - 하나의 프로세스가 공유 데이터를 변경할 동안, 다른 프로세스는 접근 불가능

### IPC 방법

- 메시지 전달(message passing) 방식
    - 프로세스 간의 공유 데이터를 일체 사용하지 않고 커널을 통해 메시지를 주고받으면서 통신
    
    - 두 프로세스는 **커뮤니케이션 링크**를 생성한 후, **커널**에게 `send`, `receive` 연산을 제공 받아, 시스템 콜 방식으로 메시지를 주고 받음
        - 커뮤니케이션 링크 구현: 물리적인 방법, 논리적인 방법이 있다.
        
    - 직접통신
        - 메시지의 전송 대상이 다른 프로세스
        
        - 통신하려는 프로세스의 이름을 명시적으로 표시
        
        - 커뮤니케이션 링크는 자동적으로 생성됨
        
        - 하나의 링크는 한 쌍의 프로세스에게 할당됨.
        
        - 대부분 양방향성 링크
        
    - 간접통신
        - 메시지의 전송 대상이 메일박스(일종의 저장공간) 또는 포트
        
        - 각 메일박스에는 고유의 ID가 있고, 이 메일박스를 공유하는 프로세스들 간 통신
        
        - 커뮤니케이션 링크는 프로세스 간에 메일박스를 공유하는 경우에만 생성됨
        
        - 하나의 링크는 여러 프로세스들에게 할당될 수 있고, 이 링크를 공유할 수 있음
        
        - 단방향성 또는 양방향성 링크
        
- 공유메모리(shared memory) 방식
    - 프로세스들이 주소 공간의 일부를 공유한다.
    
    - 공유메모리 영역은 각자의 주소 공간에 공통적으로 포함 → 여러 프로세스가 읽고 쓰기 가능
    
    - 이 주소 공간이 물리적 메모리에 매핑될 대, 공유메모리 주소 영역은 동일한 물리적 메모리 주소로 매핑됨
    
    - 서로의 데이터에 대한 일관성 문제에 대해 커널이 책임지지 않고, **프로세스들끼리 직접 공유메모리 접근에 대한 동기화 문제를 책임져야 함**
