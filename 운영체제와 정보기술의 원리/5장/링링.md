# 5장. 프로세스 관리

## 프로세스의 개념

### 프로세스

실행 중인 프로그램 (program in execution)

디스크에 실행파일 형태로 존재하던 프로그램이 메모리에 올라가서 실행되기 시작하면 프로세스

</br>

### 프로세스 문맥

프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보

그 프로세스의 주소 공간 (코드, 데이터, 스택 상태)을 비롯해 레지스터에 어떤 값을 가지고 있었는지와, 시스템콜 등을 통해 커널에서 수행한 일의 상태, 그 프로세스에 관해 커널이 관리하고 있는 각종 정보 등을 포함하게 된다.

</br>

### 프로세스 문맥 3가지

**하드웨어 문맥** : CPU의 수행 상태를 나타내는 것으로 PC값과 각종 레지스터에 저장하고 있는 값들

**프로세스의 주소 공간** : 프로세스는 코드, 데이터, 스택으로 구성되는 자기 자신만의 독자적인 주소공간을 가지므로 프로세스의 문맥을 결정 짓는 중요한 요소 중 하나이다.

**커널상의 문맥** : 프로그램이 수행되어 프로세스가 되면 운영체제는 프로세스를 관리하기 위한 자료구조를 유지한다. PCB와 커널 스택이 이에 해당한다.

</br>

## 프로세스의 상태

### 프로세스의 상태

프로세스의 상태는 크게 실행(running), 준비(ready), 봉쇄(blocked, wait, sleep)의 세 가지로 나눌 수 있다. 

프로세스의 상태를 나누는 이유는 컴퓨터의 자원을 효율적으로 관리하기 위해서이다.

**실행 상태** : 프로세스가 CPU를 보유하고, 기계어 명령을 실행하고 있는 상태. 일반적으로 컴퓨터 시스템 내에 CPU는 하나뿐이므로 컴퓨터 내에서 여러 프로세스는 매 시점 하나뿐이다. 

**준비 상태** : 프로세스가 CPU만 보유하면 당장 명령을 실행할 수 있지만 CPU를 할당받지 못한 상태

**봉쇄 상태** : CPU를 할당받더라도 당장 명령을 실행할 수 없는 프로세스의 상태. 예를 들어 입출력 작업이 진행 중인 경우

**시작 상태** : 프로세스가 시작되어 그 프로세스를 위한 자료구조는 생성되었지만 아직 메모리 획득을 승인받지 못한 상태

**완료 상태** : 프로세스가 종료되었으나 운영체제가 그 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태

</br>

### context switch : 문맥 교환

실행시킬 프로세스를 변경하기 위해 원래 수행 중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정

</br>

### CPU dispatch : CPU 디스패치

준비 상태에 있는 프로세스들 중에서 CPU를 할당받을 프로세스를 선택한 후 실제로 CPU의 제어권을 넘겨받는 과정

</br>

## 프로세스 제어블록 : PCB(Process Control Block)

운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담은 커널 내의 자료구조

### 구성 요소

**프로세스 상태**: CPU 할당 가능 여부 판단을 위해 필요

**프로그램 카운터 값**: 다음에 수행할 명령의 위치

**CPU 레지스터 값**: CPU 연산을 위해 현 시점에 레지스터에 어떤 값을 저장하고 있는지

**CPU 스케줄링 정보**: 프로세스를 스케줄링하기 위한 정보

**메모리 관리 정보**: 프로세스의 메모리 관리하기 위한 정보

**자원 사용 정보**: 사용자에게 자원 사용 요금을 계산해 청구

**입출력 상태 정보**: 프로세스가 오픈한 파일 정보 등 프로세스의 입출력 관련 상태 정보

</br>

## 문맥 교환

하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정

문맥 교환 중에 원래 CPU를 보유하고 있던 프로세스는 프로세스의 문맥을 자신의 PCB에 저장하고, 새롭게 CPU를 할당받을 프로세스는 예전에 저장햇던 자신의 문맥을 PCB로부터 실제 하드웨어로 복원시키는 과정을 거친다.

👻 모드 변경 VS 문맥 교환

CPU를 점유한 프로세스가 바뀜 → 문맥 교환

프로세스의 실행모드만 변경, 이 경우에도 프로세스의 문맥을 PCB에 저장한다. → 모드 변경

모드 변경보다 문맥 교환에 훨씬 더 많은 overhead가 뒤따른다.

타이머 인터럽트가 발생하거나 프로세스가 입출력 요청 시스템 콜을 하여 봉쇄 상태에 들어가는 경우에는 문맥교환이 일어나지만, 그 밖의 인터럽트나 시스템 콜 발생 시에는 문맥교환이 일어나지 않고 실행 모드는 변경된다.

</br>

## 프로세스를 스케줄링하기 위한 큐

### 하드웨어 자원을 기다리기 위한 큐

CPU를 기다리는 프로세스를 줄세우기 위한 큐

자원 별 장치 큐 (디스크 입출력 큐, 키보드 입출력 큐 등..)

### 소프트웨어 자원을 기다리기 위한 큐

공유 데이터(일종의 소프트웨어 자원)에 대한 접근 권한 등..

이와 같이 프로세스의 상태 관리는 커널의 주소 영역 중 데이터 영역에 다양한 큐를 두어 수행하게 된다. 

운영체제는 준비 큐(ready queue)와 장치 큐(device queue) 외에 작접 큐(job queue)를 추가로 유지한다. 작업 큐는 시스템 내의 모든 프로세스를 관리하기 위한 큐로, 프로세스의 상태와 무관하게 현재 시스템 내에 있는 모든 프로세스가 작업 큐에 속하게 된다. 그러므로 작업 큐에 있다고 해서 반드시 메모리를 가지는 것은 아니다.

준비 큐에 속한 프로세스들은 준비 상태에 있고, 장치 큐에 속한 프로세스들은 봉쇄 상태에 있으므로 프로세스는 상태 변화에 따라 준비 큐와 장치 큐를 오가며 실행된다. 준비 큐와 장치 큐에 있는 프로세스들은 모두 작업 큐에 속해있다.

</br>

### 운영체제가 큐를 관리하는 자료구조

장치 큐는 각가의 자원마다 큐가 하나씩 존재, 큐 헤더가 존재

큐는 각 프로세스의 PCB를 연결리스트 형태로 관리하며 포인터를 사용해 순서를 정렬한다. 

</br>

## 스케줄러

어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드를 지칭한다. 

### 장기 스케줄러 (long term scheduler)

작업 스케줄러(job scheduler)라고도 부르며, 어떤 프로세스를 준비 큐에 진입시킬지 결정하는 역할을 한다.

처음 프로세스가 생성되면 시작 상태를 거쳐 준비 상태에 이르게 되는데 장기 스케줄러는 이때 시작 상태의 프로세스들 중 어떠한 프로세스를 준비 큐에 삽입할 것인지 결정하는 역항릉 하게 된다. 즉, 시작 상태의 프로세스에게 메모리 할당을 승인할 지 여부를 결정한다.

**특징**

수십 초 내지 수 분 단위로 가끔 호출되기 때문에 상대적으로 속도가 느린 것이 허용된다. 

메모리에 동시에 올라가있는 프로세스의 수를 조절하는 역할을 한다. 

</br>

### 단기 스케줄러 (short term scheduler)

CPU 스케줄러라고도 하며, 준비 상태의 프로세스 중에서 어떤 프로세스를 다음번에 실행 상태로 만들 것인지 결정하는 역할을 한다. 예를 들어 시분할 시스템에서는 타이머 인터럽트가 발생하면 단기 스케줄러가 호출된다.

**특징**

밀리초 정도의 시간 단위로 매우 빈번하게 호출되끼 때문에 수행 속도가 충분히 빨라야한다. 

그러나 현대의 시분할 시스템에서 사용되는 운영체제에는 일반적으로 장기 스케줄러를 두지 않는 경우가 대부분이다. 장기 스케줄러는 과거 자원이 매우 빈약하던 시절에 주로 사용되었다. 과거에는 적은 양의 메모리를 많은 프로세스들에게 할당하면 프로세스 당 메모리 보유량이 지나치게 적어져 시스템의 효율이 매우 떨어졌기 떄문에 장기 스케줄러가 이를 조절하는 역할을 담당했기 떄문이다. 이에 비해 현대의 시분할 시스템용 운영체제에서는 프로세스가 시작 상태가 되면 장기 스케줄러 없이 곧바로 그 프로세스에 메모리를 할당해 준비 큐에 넣어주게 된다. 

→ 현대의 시분할 시스템용 운영체제에서는 장기 스케줄러 대신 중기 스케줄러를 두는 경우가 많다. 

</br>

### 중기 스케줄러

swapper라고도 불린다. 

**스와핑(Swapping)** : 일부 프로세스를 메모리에서 디스크로 보내고(**swap-out**), 시간이 흘러 메모리에 여유가 생기면 다시 적재(**swap-in**)한다

너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우 이를 해결하기 위해 메모리에 적재된 프로세스의 수를 동적으로 조절하기 위해 추가된 스케줄러

만약 너무 많은 프로세스가 메모리에 적재되어 메모리양이 극도로 적어져 CPU 수행에 당장 필요한 프로세스의 공간조차도 메모리에 올려놓고 이려운 상황이 발생할 수 있다. 중기 스케줄러는 이런 경우 스와핑을 통해 관리한다. 스왑아웃하는 0순위 프로세스는 **봉쇄 상태** 프로세스이다. 봉쇄 상태 프로세스들을 모두 스왑아웃 시킨 후에도 메모리 공간이 부족한 경우, 중기 스케줄러는 보통 타이머 인터럽트가 발생해 준비큐로 이동하는 프로세스를 추가적으로 스왑아웃시킨다.

중기 스케줄러로 인해 새로운 프로세스 상태가 생긴다. 

**중지(suspend, stopped) → 중지준비(suspended ready), 중지봉쇄(suspended block)**

![image](https://github.com/woowacourse-study/2023-cs-study/assets/88828858/20209c3e-9d86-4097-b117-b8268a5403c2)


## 프로세스의 생성

시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성.

그 다음부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성. 부모 - 자식 프로세스

자식이 먼저 죽고, 이에 대한 처리는 자식을 생성했던 부모 프로세스가 담당한다.

프로세스가 생성되면 자신만의 독자적인 주소 공간을 갖게 된다.

부모프로세스가 자식 프로세스를 생성하면 별도의 주소 공간을 가지게 되는데, 처음 주소 공간을 생성할 때는 부모 프로세스의 주소 공간 내용을 그대로 복사해서 생성한다.

</br>

### 프로세스 종료

**자발적 종료**

프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려 이루어지는 종료.

프로세스는 명령을 모두 수행한 후, 마지막에 exit()이라는 시스템콜을 호출하여 운영체제에게 자신이 종료됨을 알린다. 그러면 운영체제는 이 프로세스로부터 자원을  회수하고 시스템 내에서 이 프로세스를 정리한다.

**비자발적 종료**

부모 프로세스가 자식 프로세스의 수행을 강제 종료

- 자식 프로세스가 할당 자원의 한계치를 넘어서는 많은 양의 자원을 요구할 때
- 자식 프로세스에게 할당된 작업이 더 이상 필요하지 않을 때
- 부모 프로세스가 종료되는 경우

</br>

### 자식 프로세스 생성

프로세스가 fork() 시스템 콜을 호출하면 똑같은 프로세스가 하나 생성된다.

이렇게 해서 생긴 자식 프로세스는 부모 프로세스와 동일한 문맥을 갖는다. 즉, 부모 프로세스의 주소 공간을 비롯해 프로그램 카운터 등 레지스터 상태, PCB 및 커널스택 등 모든 문맥을 그대로 복제한다. 따라서 자식 프로세는 부모 프로세스의 처음부터 수행을 하는 것이 아니라 부모 프로세스가 현재 수행한 시점(PC)부터 수행하게 된다. 프로세스 식별자가 다른 것이 유일한 차이점이다.

복제된 프로세스는 자기가 복제본이 아니라 원본이며, 자기를 복제해서 복제본이 생성되었다고 생각한다. 이 프로세스가 복제되었다는 사실은 fork() 함수의 결과값으로 알 수 있다. 원본은 양수, 복제본은 0. 유닉스에서는 프로세스의 주소 공간에 새로운 프로그램을 덮어 씌우는 exec() 시스템 콜을 지원한다. exec()은 프로세스가 지금까지 수행했던 상태를 잊어버리고 그 주소 공간을 완전히 새로운 프로그램으로 덮어씌운 후 새로운 프로그램의 첫 부분부터 다시 실행을 시작하도록 하는 시스템 콜이다. 

프로세스의 생성과 관련된 fork(), exec() 등은 사용자 프로세스가 직접 수행할 수 없는 특권명령이다.

wait() 시스템콜은 자식 프로세스가 종료되기를 기다리며 부모 프로세스가 봉쇄 상태에 머무르도록 할 때 사용된다. 이 함수를 통해 부모프로세스와 자식 프로세스 간이ㅡ 동기화가 가능하다. 

</br>

## 프로세스 간의 협력

부모 프로세스와 자식 프로세스는 각가 자신의 독자적인 주소 공간만을 참조한다. 사실상 둘은 자원을 획득하기 위해 경쟁적인 관계에 있는 것이다. 경우에 따라서는 독립적인 프로세스들이 협력 할 때 업무의 효율성이 증진될 수 도 있다. 

### IPC : Inter-Process Communication

프로세스 간의 협력 매커니즘을 위해 운영체제가 제공하는 대표적인 매커니즘이다.

IPC는 프로세스들 간의 통신 과 동기화를 이루기 위한 매커니즘이다. 

대표적인 방법으로는 **메시지 전달 방식**과 **공유 메모리 방**식이 있다. 둘의 차이점은 프로세스 사이에 공유 데이터를 사용하는가, 사용하지 않는가 이다.

</br>

### 메시지 전달 방식

프로세스 간에 공유 데이터를 일체 사용하지 않고 메시지를 주고받으면서 통신하는 방식.

이때 두 프로세스의 주소 공간이 다르므로 메시지 전달을 직접 할 수 없으므로 커너링 그 역할을 한다. 통신하기를 원하는 두 프로세스는 커뮤니케이션 링크를 생성한 후 send()와 recieve()를 통해서 메시지를 주고 받는다. 커뮤니케이션 링크의 구현 방법은 물리적인 방법과 논리적인 방법이 있다.

다음 두가지 통신의 차이는 연산의 인터페이스에 대한 차이일 뿐 실제 메시지 전송이 이루어지는 내부 구현은 커널의 중재에 의해 사실상 동일한 방식으로 이뤄진다.

**직접 통신**

메시지의 전송 대상이 다른 프로세스

통신하려는 프로세스의 이름을 명시적으로 표시한다. send(P, message), receive(Q, message)

링크는 자동적으로 생성되고, 하나의 링크는 정확히 한 쌍의 프로세스에게 할당된다. 또한 각 쌍의 프로세스에게는 오직 하나의 링크만이 존재하고, 링크는 단방향성일 수 있으나 대부분의 경우 양방향성이다.

**간접 통신**

메시지의 전송 대상이 메일박스 또는 포트라는 일종의 저장 공간

각 메일박스에는 고유의 ID가 있으며 메일 박스를 공유하는 프로세스들만 서로 통신이 가능하다. 

하나의 링크가 여러 프로세스들에게 할당될 수 있으며 각 프로세스의 쌍은 여러 링크를 공유할 수 있다. send(A, message), receive(A, message)

P1, P2, P3가 있다고 가정할 때, P1이 보낸 메시지를 누가 받는건지 확신할 수 없다. 그래서 2개의 프로세스에게만 링크를 할당하는 방법이 있다. P2, P3에게 각각 따로 링크를 생성하는 것이다. 

</br>

### 공유 메모리 방식

프로세스들이 주소 공간의 일부를 공유한다. 

공유 메모리 공간은 각자의 주소 공간에 공통적으로 포함되는 영역이다. 

공유메모리 방식은 프로세스 간의 통신을 수월하게 만드는 인터페이스를 제공하지만 서로의 데이터에 일관성 문제가 있을 수 있다. 이에 대해서는 커널이 책임지지 않기 때문에 프로세스들끼리 직접 공유 메모리 접근에 대한 동기화 문제를 책임져야한다.
