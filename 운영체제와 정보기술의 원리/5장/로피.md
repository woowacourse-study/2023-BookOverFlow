# 5장 프로세스 관리

## 1. 프로세스의 개념

**프로세스**

- 실행 중인 프로그램
- CPU를 획득해 자신의 코드를 수행하기도 하고, 때로는 CPU를 반환하고 입출력 작업을 수행
- 자신의 임무를 다 수행하고 나면 종료되어 사라진다.
- 코드, 데이터, 스택으로 구성되는 자기 자신만의 독자적인 주소 공간을 가지고 있다.

**프로세스 문맥**

- 프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보를 의미
- 프로세스의 주소공간(코드, 데이터, 스택 상태)을 비롯해 레지스터에 어떤 값을 가지고 있었는지와, 시스템 콜 등을 통해 커널에서 수행한 일의 상태, 그 프로세스에 관해 커널이 관리하고 있는 각종 정보 등 포함
- 하드웨어 문맥
    - CPU의 수행 상태를 나타내는 것
    - 프로그램 카운터값과 각종 레지스터에 저장하고 있는 값들을 의미
- 프로세스 주소 공간
    - 프로세스의 문맥을 결정짓는 중요한 요소
- PCB와 커널스택
    - 프로그램이 수행되어 프로세스가 되면 운영체제는 프로세스를 관리하기 위해 유지하는 자료구조
    - 프로세스의 문맥을 결정짓는 중요한 요소

## 2. 프로세스의 상태

**프로세스 상태(실행,준비, 봉쇄)**

- 실행
    - 프로세스가 CPU를 보유하고, 기계어 명령을 실행하고 있는 상태
    - CPU는 하나뿐이므로 컴퓨터 내에서 여러 프로세스가 동시에 수행된다고 해도 실제로 실행 상태에 있는 프로세스는 매 시점 하나뿐
- 준비
    - 프로세스가 CPU만 보유하면 당장 명령을 실행할 수 있지만 CPU를 할당받지 못한 상태
- 봉쇄
    - CPU를 할당받더라도 당장 명령을 실행할 수 없는 프로세스의 상태
- 시작
    - 프로세스가 시작되어 그 프로세스를 위한 각종 자료구조는 생성되었지만 아직 메모리 획득을 승인받지 못한 상태
- 완료
    - 프로세스가 종료되었으나 운영체제가 그 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태

프로세스의 상태를 구분하는 이유는 컴퓨터의 자원을 효율적으로 관리하기 위해서

하나의 프로세스는 항상 어느 한 상태에 머물러있게 된다. 그 상태는 시간의 흐름에 따라 변화한다.

**문맥 교환(context switch)**

- 실행시킬 프로세스를 변경하기 위해 원래 수행 중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정

**CPU 디스패치(dispatch)**

- 준비 상태에 있는 프로세스들 중에서 CPU를 할당받을 프로세스를 선택한 후 실제로 CPU의 제어권을 넘겨받는 과정

## 3. 프로세스 제어블록

**프로세스 제어블록**

- 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조
- 프로세스의 상태
    - CPU를 할당해도 되는지 여부를 결정하기 위해 필요하다.
- 프로그램 카운터의 값
    - 다음에 수행할 명령의 위치
- CPU 레지스터의 값
    - CPU 연산을 위해 현 시점에 레지스터에 어떤 값을 저장하고 있는지 나타낸다.
- CPU 스케줄링 정보
    - 각 프로세스의 CPU 스케줄링
- 메모리 관리 정보
    - 메모리 할당을 위해 필요한 정보
- 자원 사용 정보
    - 사용자에게 자원 사용 요금을 계산해 청구하는 등의 용도
- 입출력 상태 정보
    - 프로세스가 오픈한 파일 정보 등 프로세스의 입출력 관련 상태 정보 나타낸다.

## 4. 문맥교환

**문맥교환**

- 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정
- 원래 CPU를 보유하고 있던 프로세스는 프로세스의 문맥을 자신의 PCB에 저장, 새롭게 CPU를 할당받을 프로세스는 예전에 저장했던 자신의 문맥을 PCB로부터 실제 하드웨어로 복원시킨다.
- 하나의 프로세스의 실행모드만이 사용자에서 커널모드로 바뀌는 것은 CPU를 점유하는 프로세스가 다른 사용자 프로세스로 변경되는 과정이 아니기 때문에 문맥교환이라고 할 수 없다.
- 많은 오버헤드가 뒤따름
- 문맥교환에 소요되는 시간이 일종의 오버헤드

## 5. 프로세스를 스케줄링하기 위한 큐

준비 큐

- 준비 상태에 있는 프로세스들을 줄 세우기 위해 있는 큐
- 제일 앞에 줄 서 있는 프로세스에 제일 먼저 CPU를 할당
- 줄 세우는 방법은 CPU 스케줄링 방법에 따라 달라짐

장치 큐

- 특정 자원을 기다리는 프로세스들을 줄 세우기 위해 자원별로 두는 큐

소프트웨어 자원을 기다리는 경우에도 큐가 필요

여러 프로세스가 공유 데이터에 동시에 접근하려고 할 경우 공유 데이터를 기다리는 큐에 줄 서게 하여 현재 그 데이터를 사용하고 있는 프로세스가 데이터를 반납하기 전까지는 접근하지 못하게 하고, 반납할 경우 큐에 줄 서 있는 순서대로 데이터의 접근 권한 부여

> 프로세스의 상태 관리는 커널의 주소 영역 중 데이터 영역에 다양한 큐를 두어 수행
→ 각 프로세스가 CPU를 기다리는 지, 입출력을 기다리는지 등의 정보를 커널이 총체적으로 관리
>

작업 큐

- 시스템 내의 모든 프로세스를 관리하기 위한 큐
- 프로세스의 상태와 무관하게 현재 시스템 내에 있는 모든 프로세스가 작업 큐에 속함
- 반드시 메모리를 가지고 있는 것은 아님

> 작업 큐가 가장 넓은 개념, 준비 큐와 장치 큐는 작업 큐에 속해 있다.
>

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/11248ec0-4f3c-43b8-a056-1626a2cd6571/Untitled.png)

장치큐는 각각의 자원 마다 큐가 하나씩 존재, 큐헤더는 큐의 가장 앞 부분

## 6. 스케줄러

**스케줄러**

- 어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드를 지칭
- 장기 스케줄러
    - 작업 스케줄러
    - 어떤 프로세스를 준비 큐에 진입시킬지 결정하는 역할( 시작 상태의 프로세스들 중 어떠한 프로세스를 준비 큐에 삽입할 것인지 결정하는 역할)
    - 프로세스에게 메모리를 할당하는 문제에 관여
    - 수십 초 내지 수 분 단위로 가끔 호출되기 때문에 상대적으로 속도가 느린 것이 허용된다.
    - 메모리에 동시에 올라가 있는 프로세스의 수를 조절하는 역할(시작 상태의 프로세스에게 메모리 할당을 승인할지 여부를 장기 스케줄러가 결정하기 때문)
    - 현대의 시분할 시스템에서 사용되는 운영체제는 장기 스케줄러 두지 않는 경우가 대부분
- 단기 스케줄러
    - CPU 스케줄러
    - 준비 상태의 프로세스 중에서 어떤 프로세스를 다음번에 실행 상태로 만들 것인지 결정
    - 밀리초 정도의 시간 단위로 매우 빈번하게 호출되기 때문에 수행 속도가 충분히 빨라야 한다.
- 중기 스케줄러
    - 현대의 시분할 시스템용 운영체제에서 사용
    - 너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우 이를 해결하기 위해 메모리에 적재된 프로세스의 수를 동적으로 조절하기 위해 추가된 스케줄러
    - 프로세스당 보유 메모리양이 지나치게 적어진 경우 이를 완화시키기 위해 일부 프로세스를 메모리에서 디스크로 스왑 아웃시키는 역할 수행
    - 스왑 아웃시키는 0순위 프로세스는 봉쇄 상태의 프로세스
        - 봉쇄 상태인 프로세스들의 경우 당장 CPU를 획득할 가능성이 없기 때문
    - 봉쇄 상태를 모두 스왑 아웃시켜도 메모리가 부족한 경우에는, 준비 큐로 이동하는 프로세스 추가적으로 스왑 아웃
    - 메모리에 올라와 있는 프로세스의 수를 조절

  중기 스케줄러의 등장으로 중지 상태가 등장

    - 중지 상태는 외부적인 이유로 프로세스의 수행이 정지된 상태
        - 메모리 자원이 당장 필요하지 않다.
        - 중지상태의 프로세스는 메모리를 통째로 빼앗기고 디스크로 스왑 아웃
        - 중지준비 상태
            - 준비 상태에 있던 프로세스가 중기 스케줄러에 의해 디스크로 스왑아웃 되었을 때 프로세스의 상태
        - 중지봉쇄 상태
            - 봉쇄 상태에 있던 프로세스가 중기 스케줄러에 의해 디스크로 스왑아웃 되었을 때 프로세스의 상태
        - 중지봉쇄 상태의 프로세스가 봉쇄되었던 조건 만족하면 중지준비 상태로 바뀜
    - 중지 상태는 메모리를 조금도 보유하지 않고 디스크에 통째로 스왑아웃된 상태

## 7. 프로세스의 생성

부모 프로세스

- 프로세스를 생성한 프로세스

자식 프로세스

- 새롭게 생성된 프로세스

> 프로세스 세계는 자식이 먼저 죽고, 이에 대한 처리는 자식을 생성했던 부모 프로세스가 담당하는 방식
→ 후손들이 많은 프로세스를 종료될 경우에는 그 프로세스가 생성했던 모든 후손 프로세스들을 연쇄적으로 종료시킨 후에야 본인이 종료됨
>

프로세스가 수행되는 모델

- 부모와 자식이 공존하며 수행되는 모델
    - 자식과 부모과 같이 CPU를 획득하기 위해 경쟁하는 관계
- 자식이 종료될 때까지 부모가 기다리는 모델
    - 자식 프로세스가 종료될 때까지 부모 프로세스는 아무 일도 하지 않고 봉쇄 상태에 머물러 있다가, 자식 프로세스가 종료되면 그때 부모 프로세스가 준비상태가 되어 다시 CPU를 얻을 권한이 생긴다.

프로세스가 생성되면 자신만의 독자적인 주소공간을 갖는다

- 자식 프로세스는 부모 프로세스와 별도의 주소 공간을 가지게 된다.
- 처음 주소공간을 생성할 때는 부모의 주소공간을 그대로 복사한다.
- 자식 프로세스가 다른 프로그램을 수행하기 위해서는 생성된 주소공간에 새로운 프로그램의 주소공간을 덮어씌운다.

프로세스 종료

- 자발적 종료
    - 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려 이루어진다.
    - 종료를 통보받은 운영체제는 프로세스로부터 자원을 회수하고 시스템 내에서 프로세스 정리
    - exit()은 개발자가 명시적 호출하지 않아도 프로세스 종료직전에 항상 호출된다.
- 비자발적 종료
    - 부모 프로세스가 자식 프로세스의 수행을 강제로 종료 시키는 것
    - abort() 함수를 통해 이루어짐
    - 강제 종료가 발생하는 경우
        - 자식 프로세스가 할당 자원의 한계치를 넘어서 많은 양의 자원을 요구할 때
        - 자식 프로세스가 할당된 작업이 더 이상 필요하지 않을 때
        - 부모 프로세스가 종료되는 경우
    - 부모 프로세스가 종료되어도 자식 프로세스를 계속 실행시키고 싶으면 종료되지 않을 다른 프로세스의 양자로 자식 프로세스를 보낸다.

프로세스가 자식 프로세스를 생성하는 법

- fork() 시스템 콜 사용하여  fork() 함수를 호출한 프로세스와 똑같은 프로세스를 하나 생성
- fork()를 통해 생성된 프로세스는 부모 프로세스와 모든 문맥을 동일하게 가지고 있다.
- 프로세스 식별자는 서로 다르다.
- 프로세스가 복제된 프로세스라는 사실을 알 수 있는 단서
    - fork() 함수의 결괏값으로 원본에게는 양수를 주고 복사본에게는 0을 준다.
- exec()
    - 자식 프로세스에게 부모와는 다른 독자적인 프로그램을 수행시킬 수 있는 매커니즘
    - 프로세스가 지금까지 수행햇던 상태를 잊어버리고 완전히 새로운 프로그램으로 덮어씌운 후 새로운 프로그램의 첫 부분부터 다시 실행을 시작하도록 하는 시스템 콜
- wait()
    - 자식 프로세스가 종료되기를 기다리며 부모 프로세스가 봉쇄 상태에 머무르도록 할 때 사용
    - 부모 프로세스와 자식 프로세스간의 동기화 가능
    - 일반 봉쇄처럼 자원을 기다리며 줄 서 있는 것이 아니라 자식 프로세스가 종료되기를 기다리며 수면 상태에 머무르게 되는 것, 자식 프로세스가 종료되는 순간 준비 큐에 재진입해 다시 CPU 얻을 권한 획득
