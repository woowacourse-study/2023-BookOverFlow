# 3장 컴퓨터 시스템의 동작 원리

## 1. 컴퓨터 시스템의 구조

컴퓨터 시스템의 구조 → 컴퓨터 내부장치(CPU, 메모리) + 컴퓨터 외부장치(디스크, 키보드, 마우스, 모니터, 네트워크 장치)

컴퓨터는 `외부장치에서 내부장치로 데이터를 읽어와 각종 연산을 수행한 후, 그 결과를 외부장치로 다시 내보내는 방식`으로 업무를 처리한다.

- 컴퓨터 내부로 데이터가 들어오는 것 `입력`
- 컴퓨터 외부 장치로 데이터가 나가는 것 `출력`
- 컴퓨터 외부장치 `입출력장치`

**컨트롤러**

- 일종의 작은 CPU
- 각 하드웨어 장치마다 존재하면서 이들을 제어

운영체제는 컴퓨터가 부팅되었을 때부터 항상 수행되면서 각종 자원들을 관리해야 하므로 항상 메모리에 올라가 있음.

- 운영체제의 모든 코드를 메모리에 상주시키면 메모리 낭비 발생
- 항상 메모리에 올라가 있는 부분은 전체 운영체제 중 핵심적인 부분 한정 → 이 부분 `커널`

## 2. CPU 연산과 I/O 연산

입출력 장치들의 I/O 연산 → 입출력 컨트롤러 담당

컴퓨터 내에서 수행되는 연산 → 메인 CPU 담당

> 입출력 장치와 메인 CPU는 동시 수행 가능
>

**로컬 버퍼(local buffer)**

- 장치 컨트롤러가 가지고 있는  장치로부터 들어오고 나가는 데이터를 임시로 저장하기 위한 작은 메모리
- 장치에서 데이터를 읽어오는 경우, 로컬버퍼에 데이터가 임시로 저장된 후 메모리에 전달된다.
- 장치에서 로컬버퍼로 읽어오는 일은 컨트롤러에서 담당
- 장치 컨트롤러는 인터럽트를 발생시켜 CPU에 작업이 끝났는지 보고
    - 인터럽트란? 컨트롤러들이 CPU의 서비스가 필요할 때 이를 통보하는 방법

> CPU는 매 시점 메모리에서 명령을 하나씩 읽어와서 수행, 이 때 CPU 옆에는 `인터럽트 라인` 이 있어서, CPU가 자신의 작업을 하던 중간에 인터럽트 라인에 신호가 들어오면 일을 멈추고 인터럽트와 관련된 일 먼저 처리
→ CPU는 명령 하나를 수행할 때마다 인터럽트 발생했는지 확인
>

## 3. 인터럽트의 일반적 기능

**인터럽트 처리루틴**

- 운영체제 커널 내에 있다.
- 다양한 인터럽트에 대해 각각 처리해야 할 업무들을 정의

**하드웨어 인터럽트와 소프트웨어 인터럽트**

- 공통점
    - CPU 옆에 있는 인터럽트 라인에 신호를 보내서 인터럽트가 발생했음을 알려주는 방식
    - 인터럽트가 발생하면 CPU는 하던 일을 멈추고 운영체제 커널 내에서 해당 인터럽트의 처리를 위해 정의된 코드를 찾게 된다.
- 차이점
    - 하드웨어 인터럽트는 하드웨어(컨트롤러 등) 장치가 CPU의 인터럽트 라인을 세팅한다.
    - 소프트웨어 인터럽트는 소프트웨어가 CPU 인터럽트 라인을 세팅한다.

**인터럽트 벡터**

- 운영체제가 할 일을 쉽게 찾아가기 위해 가지고 있는 것
- 인터럽트 종류마다 번호를 정해서, 번호에 따라 처리해야 할 코드가 위치한 부분을 가리키고 있는 자료구조
- 실제 처리해야할 코드는 인터럽트 루틴 or 인터럽트 핸들러에 정의

**소프트웨어 인터럽트**

- 트랩(trap)으로 불림
- ex) 예외상황과 시스템 콜
    - 예외상황은 비정상적인 작업을 하거나, 권한이 없을 작업을 시도할 때 이에 대한 처리를 위해 발생시키는 인터럽트
    - 시스템 콜은 사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 때 운영체제에 서비스를 요청하는 방법

## 4. 인터럽트 핸들링

**인터럽트 핸들링**

- 인터럽트가 발생한 경우에 처리해야 할 일의 절차
- 인터럽트가 발생하면 실행되고 있는 프로그램의 현재 상태를 먼저 저장한다.
    - 현재상태란? 현재 CPU에서 실행 중인 명령의 메모리 주소를 포함해 몇 가지 부가적인 정보들을 의미
    - CPU에서 명령이 실행될 때 레지스터(CPU 내에 있는 임시 기억장치)에 데이터를 읽거나 쓰면서 작업 → 인터럽트가 발생해 새로운 명령 실행하면 기존의 레지스터 값들이 지워지게 되므로 CPU 내의 상태 저장

**프로세스 제어블록(PCB)**

- 운영체제가 현재 시스템 내에서 실행되는 프로그램들을 관리하기 위해 둔 자료구조
- 각각의 프로그램마다 하나씩 존재하며 해당 프로그램의 어느 부분이 실행 중이었는지(코드의 메모리 주소, 레지스터값, 하드웨어 상태)를 저장

운영체제가 CPU를 점유하는 경우는 인터럽트에 의하지 않고는 발생하지 않는다.

But, 운영체제는 컴퓨터 시스템 내의 모든 하드웨어 및 소프트웨어 자원을 체계적이고 효율적으로 관리 가능

## 5. 입출력 구조

**입출력**

- 컴퓨터 시스템이 컴퓨터 외부의 입출력 장치들과 데이터를 주고받는 것
- 동기식 입출력
    - 어떤 프로그램이 입출력을 요청 했을 때 입출력 작업이 완료된 후에야 그 프로그램이 후속 작업을 수행할 수 있는 방식
    - CPU는 입출력 연산이 끝날 때까지 인터럽트를 기다리며 자원을 낭비
    - 프로그램이 입출력을 수행 중인 경우 CPU를 다른 프로그램에게 이양해 CPU가 계속 쉬지 않고 일할 수 있도록 관리한다.
    - 입출력 수행 중인 프로그램의 경우 봉쇄 상태로 전환
        - 봉쇄 상태의 경우 CPU를 할당하지 않고, CPU 할당 시 곧바로 명령을 수행할 수 있는 프로그램에만 CPU를 할당한다.
    - 입출력 연산시 CPU를 다른 프로그램에 할당하지 않는다면 매 시점 시스템 내에서는 하나의 입출력 연산만 수행 → 동기화는 자동적으로 이루어질 수 있다.
    - 입출력 요청의 동기화를 위해(동기성 보장) 장치별로 큐를 두어 요청한 순서대로 처리할 수 있도록 한다.
- 비동기식 입출력
    - 입출력 연산을 요청한 후에 연산이 끝나기를 기다리는 것이 아니라 CPU의 제어권을 입출력 연산을 호출한 그 프로그램에게 곧바로 다시 부여하는 방식
    - 입출력과 상관없이 수행할 수 있는 일을 먼저 수행하고, 읽어오는 데이터가 반드시 있어야 수행할 수 있는 일들은 입출력이 완료된 후에 수행

## 6. DMA

원칙적으로 메모리는 CPU에 의해서만 접근 가능

→ CPU 외의 장치가 접근하려고 하는 경우에는 CPU에게 인터럽트를 발생시켜 CPU가 이를 대행

→ 이렇게 CPU에서만 접근 연산이 이루어지는 경우, 입출력 장치가 메모리 접근을 원할 때마다 인터럽트에 의해 CPU의 업무가 방해를 받게 되어 CPU 사용의 효율성이 떨어짐

**DMA**

- 비효율성 극복하기 위해 CPU 이외에 메모리 접근이 가능한 장치
- 일종의 컨트롤러
- CPU가 입출력 장치들의 메모리 접근 요청에 의해 자주 인터럽트 당하는 것을 막아주는 역할
- 로컬버퍼에서 메모리로 읽어오는 작업을 CPU 담당이 아니라 DMA에서 대행
- 블록이라는 큰 단위 정보를 메로리로 읽어온 후 CPU에게 인터럽트 발생시켜 작업의 완료 알려준다.
    - 이런 식으로 CPU의 인터럽트 빈도를 줄여 CPU를 좀 더 효율적으로 관리

## 7. 저장장치의 구조

**주기억장치**

- 메모리라고 부름
- 전원이 나가면 저장되었던 내용이 모두 사라져버리는 `휘발성` , RAM을 매체로 사용

**보조기억장치**

- 전원이 나가도 저장된 내용을 기억할 수 있는 `비휘발성`, 마그네틱 디스크를 주로 사용
- ex) 플래시 메모리, CD, 마그네틱 테이프, 하드 디스크
- 용도
    - 파일 시스템용
        - 전원이 나가도 유지해야할 정보가 있으면 파일 형태로 보조기억장치에 저장
        - 메모리는 휘발성 매체이기 때문에 비휘발성 매체인 디스크를 파일 시스템용으로 사용
    - 스왑 영역용
        - 메모리는 크기가 한정되고, 가격이 비싸며, 용량이 적음 → 다수의 프로그램이 메모리에 올라가 동시에 수행되는 현대의 컴퓨터 환경에서는 메모리 공간 부족
        - 운영체제는 프로그램 수행에 당장 필요한 부분만 메모리에 올려놓고 그렇지 않은 부분은 디스크의 스왑 영역에 내려놓게 된다.
            - 디스크에 내려놓는 일은 `스왑 아웃`
        - 스왑 영역으로는 하드디스크를 널리 사용
            - 스왑 영역은 프로그램이 실행될 때 내용을 저장했다가 프로그램이 종료될 때 삭제하는 메모리의 연장 공간

**하드디스크**

- 보조기억장치 중 가장 대표적인 저장매체
- 여러개의 마그네틱 원판들이 있고, 암(arm)이 이동하며 원판에 저장된 데이터를 읽고 쓰는 방식으로 동작
- 원판의 표면은 트랙으로 나뉘고, 각 트랙은 섹터로 나뉜다.
    - 섹터는 최소한의 단위 정보를 저장

## 8. 저장장치의 계층 구조

저장장치는 빠른 저장장치부터 느린 저장장치까지 단계적인 계층 구조로 이루어진다.

- 빠른 저장장치
    - 단위 공간당 가격이 높기 때문에 적은 용량 사용
- 느린 저장장치
    - 가격이 저렴해 대용량 사용, 접근 속도가 느리다.
- 당장 필요한 정보는 빠른 저장장치에 넣어두어 수행 속도를 높이고 그렇지 않은 정보는 상대적으로 느린 저장장치에 보관

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4a68aa7b-6437-42b0-898c-8462cdcfbcf5/Untitled.png)

상위 저장장치 계층으로 갈수록 접근 속도가 월등히 빠르지만 용량은 상대적으로 적다.

- 당장 필요한 정보만을 선별적으로 저장하면 하위에 있는 큰 용량의 저장장치를 가지고 있는 것과 비슷한 성능효과를 낸다.
- 캐싱기법 - 상대적으로 용량이 적은 빠른 저장장치를 이용해 느린 저장장치의 성능을 향상시키는 총체적 기법
    - 느린 저장장치에 있는 내용 중 바로 사용될 정보나 빈번하게 사용될 정보를 빠른 저장장치에 선별적으로 저장함으로써 두 저장장치 사이의 속도를 완충

## 9. 하드웨어의 보안

운영체제는 **다중 프로그래밍 환경**에서 동작한다. 그러므로 각 프로그램이 다른 프로그램의 실행을 방해하거나 프로그램 간에 충돌을 일으키는 문제를 막기 위해 하드웨어 보안 필요

**커널모드**

- 운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행하는 모드
- 모든 종류의 명령을 다 실행할 수 있다.

**사용자모드**

- 일반 사용자 프로그램이 실행되며 제한적인 명령만을 수행

> 시스템에 중요한 영향을  미치는 연산은 커널모드에서만 실행 가능하도록 함으로써 보안 유지
>

**모드비트**

- CPU 내부에서 사용자 프로그램을 감시
- 0으로 세팅되어 있으면 커널모드로서 모든 명령 수행
- 1로 세팅되어 있으면 사용자 모드로서 제한된 명령만을 수행
- CPU는 보안과 관련된 명령을 수행하기 전에 항상 모드비트를 조사해 값이 0인 경우에만 명령 수행
- 운영체제가 CPU를 점유해 자신의 코드를 수행하다가 사용자 프로그램에게 CPU의 제어권을 넘길 때 모드비트를 1로 세팅해 넘긴다.
- 모드비트가 0으로 세팅되어 있으면 특권명령 수행 가능
    - 특권명령이란, 시스템의 보안과 관련된 명령
    - 커널모드에서 운영체제에 의해서만 수행할 수 있음

하드웨어에서 보안이 유지되는 방식

- 모든 입출력 명령은 특권명령으로 규정해서 사용자 프로그램이 직접 입출력 하는 것을 차단
- 입출력이 필요할 때에는 운영체제에 요청하여 운영체제가 입출력 명령은 대신 수행
- 입출력은 특권명령이기 때문에 모드비트가 0일 때에만 수행할 수 있으며, 사용자 프로그램이 입출력을 하고 싶으면 시스템 콜로 운영체제에 요청

## 10. 메모리 보안

> 여러 프로그램이 메모리에 동시에 올라가서 실행되기 때문에 하나의 사용자 프로그램이 다른 사용자 프로그램이나 운영체제가 위치한 메모리 영역을 침범할 수 있기 때문에 메모리 보안이 필요하다.
>

**2개의 레지스터를 사용해 프로그램이 접근하려는 메모리 부분이 합법적인지 체크 → 메모리 관리 기법**

- 기준 레지스터(base register)
    - 어떤 프로그램이 수행되는 동안 그 프로그램이 합법적으로 접근할 수 있는 메모리 상의 가장 작은 주소 보관
- 한계 레지스터(limit register)
    - 프로그램이 기준 레지스터값부터 접근할 수 있는 메모리의 범위를 보관하고 있다.
- 사용자 프로그램은 기준 레지스터에 있는 주소부터 기준 레지스터 + 한계 레지스터값 사이의 주소 영역에만 접근 가능, 접근하려는 주소가 이 범위 안에 없으면 불법적인 메모리 접근이므로 예외상항이라는 인터럽트 발생
    - 예외상황은 운영체제에 소프트웨어 인터럽트를 발생시켜 CPU의 제어권을 해당 프로그램으로부터 운영체제로 이양시키고, 운영체제는 예외상황을 발생시킨 프로그램을 강제로 종료

> 메모리 접근 연산은 특권명령은 아니다! 하지만 기준 레지스터와 한계 레지스터 값을 세팅하는 연산은 특권명령으로 규정해야 한다.
>

사용자모드 → 기준 레지스터와 한계 레지스터를 사용해서 메모리 보호

커널모드 → 메모리에 무제한 접근 가능

## 11. CPU 보호

**타이머**

- CPU가 하나의 프로그램에 의해 독점되는 것을 막기 위해 사용하는 하드웨어
- 정해진 시간이 지나면 인터럽트 발생시켜 운영체제가 CPU의 제어권을 획득할 수 있도록 하는 역할 수행
- 일정한 시간 단위로 세팅, 매 클럭 틱때마다 1씩 감소한다.
- 타이머가 0이 되는 순간 인터럽트 발생
- 타이머의 값을 세팅하는 명령(로드 타이머) → 특권명령
- 시분할 시스템에서 현재 시간을 계산하기 위해서도 사용

## 12. 시스템 콜을 이용한 입출력 수행

**시스템 콜**

- 일종의 소프트웨어적인 인터럽트로서 사용자 프로그램이 시스템 콜을 할 경우 트랩이 발생해 CPU의 제어권이 운영체제로 넘어가게 된다.
- 운영체제는 해당 시스템 콜을 처리하기 위한 루틴으로 가서 정의된 명령을 수행
