# 03. 컴퓨터 시스템의 동작 원리

## 컴퓨터 시스템의 구조

- 내부장치 - CPU, 메모리

- 외부장치 - 디스크, 키보드, 마우스, 모니터, 네트워크 장치 등

- 외부장치에서 내부장치로 데이터를 읽어와 (입력, input) 각종 연산을 수행한 후, <br/> 
그 결과를 외부장치로 다시 내보내는 (출력, output) 방식으로 업무를 처리한다. : **입출력 (I/O)**

- e.g. 키보드로 입력받아 연산을 하고 그 결과를 모니터에 출력,
- 디스크에서 내용을 읽어 연산을 한 후 디스크에 데이터를 저장

- 컨트롤러
	+ 메모리 및 입출력장치 등의 하드웨어 장치에 붙어 장치를 제어하는 일종의 작은 CPU	

## CPU 연산과 I/O 연산

- 연산을 한다 == CPU가 무언가 일을 한다.

- 입출력 장치들의 I/O 연산은 입출력 컨트롤러가, 컴퓨터 내에서 수행되는 연산은 메인 CPU가 담당한다.

- 두 가지 일이 다른 곳에서 발생하면 동시에 수행되는 것이 가능하다.

- 장치 컨트롤러는 장치로부터 들어오고 나가는 데이터를 임시 저장할 수 있는 작은 메모리를 갖고 있다. -> **로컬 버퍼 (local buffer)**

- 데이터를 읽어옴 -> 로컬버퍼에 데이터가 임시로 저장 (컨트롤러) -> 로컬버퍼로 읽어옴이 끝났는지 컨트롤러가 인터럽트를 발생시켜 CPU에 보고 

- 인터럽트: 컨트롤러들이 CPU의 서비스가 필요할 때 이를 통보하는 방법

- CPU는 매 시점 메모리에서 **명령(instruction)**을 하나씩 읽어와서 수행

- 이 때, CPU 옆에 **인터럽트 라인(interrupt line)**에 신호가 들어오면 인터럽트 관련 일을 먼저 처리

## 인터럽트의 일반적 기능

- 운영체제 커널에는 인터럽트 처리 루틴이 포함되어 있다.

- 인터럽트 발생 -> CPU는 하던 일을 멈추고 인터럽트 처리를 수행 (디스크의 로컬버퍼에 있는 내용을 사용자 프로그램의 메모리로 전달, 해당 프로그램이 CPU를 할당받을 경우 다음 명령을 수행할 수 있음을 표시)

- 인터럽트의 종류
	+ 하드웨어 인터럽트
		* 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅
	
	- 소프트웨어 인터럽트 (트랩)
		+ 소프트웨어가 그 일을 수행
		
		- e.g. 예외상황, 시스템 콜 등
		
	- 인터럽트 라인에 신호를 보내어 인터럽트 발생을 알림은 같음
	
- **인터럽틉 벡터**가 인터럽트 종류마다 정해진 번호에 따라 처리해야 할 코드의 위치를 가리키고, 실제 처리해야 할 코드는 **인터럽트 처리루틴, 또는 인터럽트 핸들러**에 정의됨

- 인터럽트 처리를 완료하고 다시 하던 일을 이어서 하기 위해 저장을 별도로 함

## 인터럽트 핸들링 (interrupt handling)

- 인터럽트가 발생한 경우에 처리해야 할 일의 절차

- 현재 시스템 내에서 실행되는 프로그램들을 관리하기 위해 PCB(프로세스 제어 블록) 이라는 자료구조를 둔다.
	+ 각각의 프로그램마다 하나씩 존재
	
	- 프로그램이 실행 중이던 코드의 메모리 주소, 레지스터값, 하드웨어 상태 등이 저장
	
- 인터럽트 발생 -> 실행 상태를 PCB에 저장 -> CPU 제어권은 인터럽트 처리루틴으로 넘어감 -> 끝나면 PCB로부터 상태를 복원, 작업 재개

- 운영체제가 직접 CPU를 점유하는 경우는 인터럽트에 의하지 않고는 발생하지 않는다.

## 입출력 구조

- I/O: 컴퓨터 시스템이 컴퓨터 외부의 입출력 장치들과 데이터를 주고받는 것

### 동기식 입출력

- 입출력 요청 -> 입출력 작업이 완료된 후에야 그 프로그램이 후속 작업을 수행 가능한 방식

- CPU는 입출력 연산이 끝날 때까지 인터럽트 기다리며 자원 낭비

- 효율적인 CPU 사용을 위해 입출력 수행하는 동안 CPU 양도 -> 다수의 입출력 연산 발생
	
- 입출력 요청의 동기화를 위해 장치별로 큐(queue)를 두어 요청 순서대로 처리

### 비동기식 입출력

- 입출력 연산을 요청한 후에 CPU 제어권을 입출력 연산을 호출한 프로그램에게 곧바로 다시 부여하는 방식

- 읽어오는 결과와 관련 없이 수행할 수 있는 작업을 먼저 수행, 관련 있는 작업들은 입출력이 완료된 후에 수행

## DMA (Direct Memory Access)

- CPU 이외에 메모리 접근이 가능한 장치

- CPU가 입출력 장치들의 메모리 접근 요청에 의해 자주 인터럽트 당하는 것을 막아주는 역할
	+ 이럴 때마다 CPU 업무에 방해받아 매우 비효율적

- 로컬버퍼 - 메모리 읽어오는 작업을 대행

- byte가 아닌 block 이라는 큰 단위로 메모리를 읽어온 후에, CPU에 인터럽트를 발생시켜 작업의 완료를 알림

## 저장장치의 구조

### 주기억장치

- 메모리

- 전원이 나가면 내용이 사라지는 휘발성의 RAM을 매체로 사용하는 경우가 대부분

### 보조기억장치

- 비휘발성의 마그네틱 디스크를 주로 사용

- 플래시 메모리, CD, 마그네틱 테이프 등

- 용도
	+ (1) 파일 시스템 용
		* 전원이 나가도 유지해야 할 정보
		
	+ (2) 메모리의 연장 공간인 스왑 영역(swap area) 용
		* 프로그램 수행에 당장 필요하지 않은 부분을 디스크의 스왑 영역에 내려놓음 (== swap out)
		
## 저장장치의 계층 구조

- 빠른 ~ 느린 저장장치까지 단계적인 계층 구조

- 상위 계층: 빠른 저장장치
	+ 단위 공간당 높은 가격, 적은 용량
	
- 하위 계층: 느린 저장장치
	+ 저렴한 가격으로 대용량
	+ 느린 접근 속도
	
- (primary) 레지스터 > 캐시 메모리 > 메인 메모리 > 마그네틱 디스크 > 광디스크 > 마그네틱 테이프 (secondary)

- 캐시 메모리: 캐싱 기법을 이용해 적은 용량도 효율적으로 동작하도록 관리
	+ 캐싱 기법: 빠른 저장장치를 이용해 느린 저장장치의 성능을 향상시키는 총체적 기법
	
	- 느린 저장장치에 있는 중 당장 사용될, 빈번히 사용되는 정보를 선별적으로 저장
	
## 하드웨어의 보안

- 여러 프로그램이 동시에 실행되는 다중 프로그래밍 환경에서, 각 프로그램 간의 방해 혹은 충돌을 막기 위한 보안 기법이 필요

- 하드웨어적인 보안을 위해 모드 분리: 커널 모드, 사용자 모드

- CPU 내부에 모드비트 (mode bit)를 두어 사용자 프로그램을 감시
	+ 모드비트 0: 커널모드로서 모든 명령 수행 가능
	
	+ 모드비트 1: 사용자모드, 제한된 명령만 수행 가능

- 특권명령: 시스템의 보안과 관련된 명령들, 커널모드에서 운영체제에 의해서만 수행 가능
	+ 입출력도 특권명령이다 !?
	
## 메모리 보안

- 여러 프로그램이 동시에 메모리에 올라가 수행 -> 다른 프로그램 혹은 운영체제가 위치한 메모리 영역 침범 방지

- 두 개의 레지스터를 사용해서 프로그램이 접근하려는 메모리 부분이 합법적인지 더블체크
	+ 기준 레지스터, 한계 레지스터
	
	+ 기준 레지스터: 어떤 프로그램이 수행되는 동안 합법적으로 접근 가능한 메모리상의 가장 작은 주소 보관
	+ 한계 레지스터: 프로그램이 기준 레지스터값으로부터 접근할 수 있는 메모리의 범위 보관

## CPU 보호

- 하나의 프로그램에 의해 독점되는 것을 막기 위해 타이머 (timer) 사용

- 타이머는 정해진 시간이 지나면 인터럽트를 발생시켜 운영체제가 CPU 제어권을 획득할 수 있도록 함

- 현재 프로그램으로부터 CPU를 빼앗아 다른 프로그램에게 이양

## 시스템 콜을 이용한 입출력 수행

- 사용자 프로그램은 입출력 명령을 직접 수행하는 대신 **시스템 콜**이라는 서비스 대행 요청을 하여 입출력을 수행한다.

- 시스템 콜: 일종의 소프트웨어적 인터럽트. 시스템 콜 -> 트랩 발생 -> CPU 제어권이 운영체제로 넘어감 -> 시스템 콜을 처리하기 위한 루틴으로 가서 정의된 명령을 수행
