# 4장. 프로그램의 구조와 설명

## 프로그램의 구조와 인터럽트

프로그램이 CPU에서 명령을 수행하려면 해당 명령을 담은 프로그램의 주소 영역이 메모리에 올라가 있어야 한다. 이때 프로그램의 주소 영역은 크게 코드(code), 데이터(data), 스택(stack) 영역으로 구분된다. 

### 코드

작성한 프로그램 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령 (machine instruction) 형태로 변환되어 저장되는 부분

### 데이터

전역 변수 등 프로그램이 사용하는 데이터를 저장하는 부분

### 스택

함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는데 사용되는 공간

일반적으로 프로그램 내에서 발생되는 함수호출에 필요한 복귀 주소는 각 프로그램의 주소 공간 중 스택 영역에 보관된다. 반면 인터럽트 때문에 CPU를 빼앗긴 위치는 운영체제가 관리하는 **프로세스 제어블록**에 저장된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e8a72af8-ffae-45cb-95c8-d4997fa3bc24/Untitled.png)

</br>

## 컴퓨터 시스템의 작동 개요

CPU는 인간의 뇌처럼 스스로 생각하고 판단하는 것이 아닌, 매 시점 메모리의 특정 주소에 존재하는 명령을 하나씩 읽어와 그대로 수행한다. 이때 CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터를 **프로그램 카운터** (Program Counter: **PC**)라고 부른다. 즉 CPU는 매번 PC가 가리키는 메모리 위치의 명령을 처리하게 된다. 

컴퓨터 시스템의 동작이 CPU에 의해서만 이루어지는 것은 아니다. (디스크 파일 읽어오기, 키보드로 입력 받기 등) 

컴퓨터 시스템을 구성하는 하드웨어로는 먼저 **CPU**와 **메모리**, 이 밖에 각 **입출력 장치**와 이들 장치를 전담하는 작은 CPU와 메모리가 있다. 이를 각 **입출력 컨트롤러**와 **로컬버퍼**라고 부른다.

메모리에는 사용자 프로그램들과 운영체제가 같이 올라가 수행된다. 이때 CPU는 PC가 가리키는 메모리 위치의 프로그램을 수행한다. 

사용자 프로그램은 스스로 특권명령(디스크 파일 접근, 화면 출력 등..)을 수행할 수 없으므로 운영체제에게 특권명령의 대행을 요청한다. 이와 같은 서비스 요청을 **시스템 콜(system call)**이라고 부른다. 사용자 프로그램이 시스템 콜을 하게 되면 운영체제는 사용자의 프로그램 코드가 아닌 커널 영역에 정의된 시스템 콜 처리 코드를 수행하게 된다. 

</br>

## 프로그램의 실행

“프로그램 실행이 되고 있다”라는 것은 컴퓨터 시스템 차원에서 볼 때 크게 두 가지 중요한 의미를 가진다. 

1. 디스크에 존재하던 실행파일이 메모리에 적재된다.
2. 프로그램이 CPU를 할당받고 명령을 수행하고 있는 상태이다. 

프로그램은 코드, 데이터, 스택으로 구성된다, 프로그램마다 독자적으로 존재하는 이와 같은 주소 공간을 우리는 가상 메모리 (virtual memory) 또는 논리적 메모리 (logical memory)라고 부른다. 이는 실제 물리적 메모리의 주소와 독립적으로 각 프로그램마다 독자적인 주소 공간을 가지기 때문에 지칭하는 용어이다. 

운영체제도 하나의 프로그램이므로 운영체제 커널 역시 코드, 데이터, 스택의 주소 공간 구성을 갖고 있다. 커널의 데이터 영역에는 각종 자원을 관리하기 위한 자료구조가 저장된다. CPU나 메모리와 같은 하드웨어 자원을 관리하기 위한 자료구조뿐 아니라 현재 수행 중인 프로그램을 관리하기 위한 자료구조도 커널의 데이터 영역에 유지된다. 이때 현재 수행 중인 프로그램을 **프로세스(process)**라고 부르고, 커널의 데이터 영역 내에는 각 프로세스의 상태, CPU의 사용 정보, 메모리 사용 정보 등을 유지하기 위한 자료구조인 PCB를 두고 있다. 이와 같이 커널의 데이터 영역에는 하드웨어와 소프트웨어를 포함하는 시스템 내의 모든 자원을 관리하기 위한 자료구조를 각각 유지하고 있다. 

커널의 스택 영역은 일반 프로그램의 스택 영역과 마찬가지로 함수호출시의 복귀 주소를 저장하기 위한 용도로 사용된다. 일반 사용자 프로그램의 스택과 다른 점은 현재 수행 중인 프로세스마다 별도의 스택을 두어 관리한다는 것이다. 이는 프로세스가 특권 명령을 수행하려고 커널에 정의된 시스템 콜을 호출하고 시스템 콜 내부에서 다른 함수를 호출하는 경우 그 복귀주소는 커널 내부의 주소가 되어 사용자 프로그램의 스택과는 별도의 저장공간이 필요하게 된다. 또한 커널은 일종의 공유 코드로서 모든 사용자 프로그램이 시스템 콜을 통해 커널의 함수를 접근할 수 있으므로, 일관성 유지를 위해 각 프로세스마다 커널 내에 별도의 스택을 두게 되는 것이다. 

→ 프로그램이 자기 자신의 코드 내에서 함수호출 및 복귀 주소를 유지하기 위해서는 자기 주소 공간 내의 스택을 사용하고, 시스템 콜이나 인터럽트 등으로 운영체제의 코드가 실행되는 중에 함수호출이 발생할 경우 커널 스택을 사용하게 되는 것이다. 

주의할 점은, 시스템 콜이나 인터럽트 발생으로 CPU의 수행 주체가 운영체제로 바뀔 때에는 프로그램의 복귀 정보를 스택이 아닌 PCB에 저장한다. 

</br>


## 사용자 프로그램이 사용하는 함수

프로그램이 사용하는 함수는 크게 3가지

### 사용자 정의함수

프로그래머 본인이 직접 작성한 함수

프로그램 코드 영역에 기계어 명령 현태로 존재 
→ 프로그램이 실행 시 해당 프로세스의 주소 공간에 포함, 함수 호출 시에도 자신의 주소 공간에 있는 스택 사용

</br>

### 라이브러리 함수

프로그래머 본인이 작성하지는 않았지만 이미 누군가 작성해놓은 함수를 호출만 하여 사용하는 경우

프로그램 코드 영역에 기계어 명령 현태로 존재 
→ 프로그램이 실행 시 해당 프로세스의 주소 공간에 포함, 함수 호출 시에도 자신의 주소 공간에 있는 스택 사용

</br>

### 커널함수

운영체제 커널의 코드에 정의된 함수

종류 : 사용자 프로그램이 운영체제의 서비스를 요청하기 위해 호출하는 **시스템 콜 함수**와, 각종 하드웨어 및 소프트웨어가 CPU의 서비스를 요청하기 위해 발생시키는 **인터럽트 처리함수**가 있다.

운영체제 커널의 주소 공간에 코드 정의

</br>

## 인터럽트

현재 수행 중인 프로세스로부터 CPU를 회수해  CPU가 다른 일을 수행하도록 하기 위해서는 인터럽트 매커니즘이 필요하다.

CPU는 매번 프로그램 카운터가 가리키고 있는 지점의 명령을 하나씩 수행하고 나서, 다음 명령을 수행하기 직전에 인터럽트 라인이 세팅되었는지 체크한다. 

인터럽트 처리 중에 또 다른 인터럽트가 발생하는 경우는 어떻게 처리되는가?

원칙적으로는 인터럽트 도중 다른 인터럽트의 발생을 허용하지 않는다. (데이터 일관성이 유지되지 않는 문제때문에) 더 시급하거나 CPU를 당장 사용해야하는 일에는 예외를 둔다. 인터럽트마다 중요도가 다르기 때문에 인터럽트를 우선순위에 따라 처리하게 된다. 

</br>

## 시스템 콜

시스템 콜은 비록 함수호출이지만, 자신의 주소 공간을 거스르는 영역에 존재하는 함수, 즉 커널이라는 다른 프로그램의 주소 공간에 존재하는 함수를 호출하는 것이다. 

</br>

## 프로세스의 두 가지 실행 상태

사용자모드에서의 실행상태, 커널모드에서의 실행상태

시스템 콜을 통해 실행되는 것이 프로세스 A의 코드가 아닌 운영체제 커널의 코드이지만, 시스템 콜이 수행되는 동안 커널이 실행 상태에 있다고 하지 않고 프로세스 A가 실행 상태에 있다고 말한다. 사실상 커널이 프로세스 A의 일을 대행해 주는 것이므로 프로세스 A는 여전히 실행중이고, 상태를 나누어 말하는 것이다.  (프로세스 A가 커널 모드에서 실행중)