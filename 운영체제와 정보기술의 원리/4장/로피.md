# 4장 프로그램의 구조와 실행

## 1. 프로그램의 구조와 인터럽트

컴퓨터 프로그램의 내부 구조는 `함수들` 로 구성

**프로그램의 주소 영역**

- 코드, 데이터, 스택 영역으로 구분
    - 코드 영역 ? 작성한 프로그램 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 변환되어 저장되는 부분
    - 데이터 영역 ? 전역변수 등 프로그램이 사용하는 데이터를 저장하는 부분
    - 스택 영역 ? 함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데에 사용되는 공간
    - 함수가 호출되면 다음에 실행할 명령의 메모리 위치가 바뀌게 된다.

프로그램 내에서 발생되는 함수호출에 필요한 복귀 주소는 각 프로그램의 주소 공간 중 스택 영역에 보관

인터럽트 때문에 CPU를 빼앗긴 위치는 운영체제가 관리하는 프로세스 제어블록에 저장

## 2. 컴퓨터 시스템의 작동 개요

**CPU**

- 매 시점 메모리의 특정 주소에 존재하는 명령을 하나씩 읽어와 그대로 실행한다.
- CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터 → `프로그램 카운터`
- CPU는 매번 프로그램 카운터가 가리키는 메모리 위치의 명령 처리

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3d853e27-09c5-4652-8e99-c0ffce58dfd6/Untitled.png)

CPU는 프로그램 카운터가 가리키는 메모리 위치의 프로그램을 수행

- 프로그램 카운터가 운영체제 부분을 가리키고 있으면 운영체제 코드를 진행중이며, 커널모드가 수행중
- 프로그램 카운터가 사용자 프로그램 부분을 가리키고 있으면 사용자 프로그램 진행 중, 사용자모드에서 CPU가 수행중

CPU가 수행하는 명령

- 일반 명령
    - 메모리에서 자료를 읽어와 CPU에서 계산하고 결과를 메모리에 쓰는 일련의 명령
    - 모든 프로그램이 수행할 수 있는 명령
- 특권 명령
    - 보안이 필요한 명령으로 입출력 장치, 타이머 등 각종 장치에 접근하는 명령
    - 운영체제만 수행할 수 있는 명령
- 컴퓨터는 이 두 명령 실행가능성을 체크하기 위해 모드비트를 둔다.

**시스템 콜**

- 사용자 프로그램이 운영체제에게 특권명령의 대행 요청
- 운영체제는 사용자 프로그램의 코드가 아닌 커널 영역에 정의된 시스템 콜 처리 코드 수행

주변 장치는 인터럽트 라인을 세팅해서 CPU에게 인터럽트를 발생시키고, CPU는 매번 명령을 수행한 후 인터럽트 라인을 체크해 서비스 요청이 들어왔는지 확인한다.

인터럽트가 발생하면 CPU는 해당 인터럽트를 처리하기 위한 루틴으로 넘어가서 커널 내의 인터럽트 처리 코드 수행한다.

## 3. 프로그램의 실행

‘**프로그램이 실행되고 있다’**

- 디스크에 존재하던 실행파일이 메모리에 적재된다.
    - 실행파일 일부분만 메모리에 올라가고 나머지는 디스크의 특정 영역에 내려가 있음
- 프로그램이 CPU를 할당받고 명령을 수행하고 있는 상태이다.

**가상메모리(논리적 메모리)**

- 각각의 프로그램마다 프로세스의 주소공간을 별도로 가지며, 프로그램마다 독자적으로 존재하는 주소 공간
- 실제 물리적 메모리의 주소와 독립적으로 각 프로그램마다 독자적인 주소 공간을 가진다.

**커널 주소 공간 구성**

- 코드
    - CPU, 메모리 등의 자원을 관리하기 위한 부분과 사용자에게 편리한 인터페이스를 제공하기 위한 부분
    - 시스템 콜 및 인터럽트를 처리하기 위한 부분
- 데이터
    - 각종 자원을 관리하기 위한 자료구조가 저장
    - 하드웨어 자원을 관리하기 위한 자료구조 + 현재 수행 중인 프로그램(프로세스)을 관리하기 위한 자료구조
    - 각 프로세스의 상태, CPU 사용 정보, 메모리 사용 정보 등을 유지하기 위한 자료구조(PCB)
- 스택
    - 함수호출 시의 복귀 주소를 저장하기 위한 용도로 사용
    - 현재 수행 중인 프로세스마다 별도의 스택을 두어 관리
        - 자기 자신의 코드 내에서 함수호출 및 복귀 주소를 유지하기 위해 사용
        - 운영체제의 코드가 실행되는 중에 함수 호출이 발생할 경우 커널 스택 사용

> ⚠️ 프로그램 내의 함수호출 시 해당 프로그램의 스택에 복귀 주소를 저장하지만, 시스템 콜이나 인터럽트 발생으로 CPU의 수행 주체가 운영체제로 바뀌는 순간 직전에 수행되던 프로그램의 복귀정보를 스택이 아닌 PCB에 저장
>

## 4. 사용자 프로그램이 사용하는 함수

**프로그램이 사용하는 함수**

- 사용자 정의함수
    - 프로그래머 본인이 직접 작성한 함수
    - 프로그램의 코드 영역에 기계어 명령 형태로 존재
    - 프로그램이 실행될 때 해당 프로세스의 주소 공간에 포함
    - 함수 호출 시에도 자신의 주소 공간에 있는 스택 사용
- 라이브러리 함수
    - 프로그래머 본인이 직접 작성하지는 않았지만 이미 누군가 작성해놓은 함수를 호출만 하여 사용하는 경우
    - 프로그램의 코드 영역에 기계어 명령 형태로 존재
    - 프로그램이 실행될 때 해당 프로세스의 주소 공간에 포함
    - 함수 호출 시에도 자신의 주소 공간에 있는 스택 사용
- 커널 함수
    - 운영체제 커널의 코드에 정의된 함수
    - 운영체제 커널의 주소공간에 코드가 정의
    - 시스템 콜 함수
        - 사용자 프로그램이 운영체제의 서비스를 요청하기 위해 호출하는 함수
        - read(), write()
    - 인터럽트 처리 함수
        - 각종 하드웨어 및 소프트웨어가 CPU의 서비스를 요청하기 위해 발생시키는 함수

## 5. 인터럽트

CPU는 매번 프로그램 카운터가 가리키고 있는 지점의 명령을 하나씩 수행하고 나서, 다음 명령을 수행하기 직전에 인터럽트 라인이 세팅되었는지 체크

→ 체크를 통해 인터럽트가 발생했으면 CPU는 현재 수행하던 프로세스를 멈추고 운영체제의 인터럽트 처리루틴으로 이동해서 인터럽트 처리를 수행한다.

→ 처리를 마치면 인터럽트가 발생하기 직전의 프로세스에게 CPU의 제어권이 넘어간다.

인터럽트 처리 중 또 다른 인터럽트가 발생하는 경우

- 원칙적으로 인터럽트 처리 중에 또 다른 인터럽트가 발생하는 것을 허용하지 않는다.
    - 데이터의 일관성 유지되지 않는 문제 발생
- 인터럽트마다 중요도가 다르기 때문에 상대적으로 낮은 중요도를 가진 인터럽트를 처리하는 도중에 중요도가 더 높은 인터럽트가 발생하는 것을 허락할 필요가 있다.

## 6. 시스템 콜

**시스템 콜**

- 자신의 주소 공간을 거스르는 영역에 존재하는 함수를 호출하는 것
- 자신의 프로그램이 아닌, 커널이라는 다른 프로그램의 주소 공간에 존재하는 함수를 호출하는 것
- 주소 공간 자체가 다른 곳에 이동해야 하므로 일반 함수호출과는 상이한 방법을 사용
    - 프로그램 자신이 인터럽트 라인에 인터럽트를 세팅하는 명령을 통해 이루어짐

프로그램이 CPU를 할당받고 명령을 수행하다가 중간에 CPU를 빼앗기는 경우

- 타이머에 의해 인터럽트가 발생하는 경우
- 입출력 요청을 위해 시스템 콜을 하는 경우

## 7. 프로세스의 두 가지 실행 상태

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cc118971-8d1c-4960-93df-191e85b814f5/Untitled.png)

- 사용자 정의함수나 라이브러리 함수를 호출할 때에는 모드의 변경 없이 사용자모드에서의 실행 지속
- 시스템 콜을 하는 경우에는 커널모드로 진입해 커널의 주소 공간에 정의된 함수를 실행
- 시스템 콜의 실행이 끝나면 다시 사용자모드로 복귀해서 시스템 콜 이후의 명령들을 계속 실행
- 프로그램이 실행이 끝날 때에는 커널 모드로 진입
