# 07. 메모리 관리

## 메모리

- 주소를 통해 접근하는 저장장치
- **주소**: 서로 다른 위치를 구분하기 위한 일련의 숫자
- 32 bit 주소체계: $2^{32}$개의 서로 다른 메모리 위치를 구분할 수 있다. ( = $2^{32}$ byte만큼의 메모리 공간에 서로 다른 주소를 할당할 수 있다.)
- 32 bit를 그대로 사용하지 않고, 보통 **4KB(=$2^{12}$byte)** 단위로 묶어 `페이지(page)`를 만든다.
- 메모리를 어떻게 나누어 관리하고, 프로그램이 메모리에 어떻게 올라가서 주소를 할당받는가?

## 주소 바인딩

- 프로세스의 주소 공간 (address space)
    - 프로세스를 위한 독자적인 주소 공간
    - 논리적 주소 (logical address), 가상 주소 (virtual address)
- CPU는 프로세스마다 독립적으로 갖는 논리적 주소에 근거해 명령을 실행한다.
- **논리적 주소**: 프로세스마다 독립적으로 할당됨, 0번지부터 시작
    
    **물리적 주소**: 물리적 메모리에 실제로 올라가는 위치
    
    낮은 주소 영역 - 운영체제, 높은 주소 영역 - 사용자 프로세스들
    
- **주소 바인딩: 논리적 주소를 메모리 주소로 연결시켜주는 작업**

### 컴파일 타임 바인딩

- 물리적 메모리 주소가 프로그램을 컴파일할 때 결정되는 주소 바인딩 방식
- 컴파일을 하는 시점에서 프로그램이 물리적 메모리에 어디 위치할 것인지를 결정함
- 프로그램이 절대주소로 적재된다 = 절대코드를 생성하는 바인딩 방식
- 물리적 메모리 위치 변경을 위해 재컴파일이 요구됨 → 비현실적, 현대에 잘 사용하지 않는 방법

### 로드 타임 바인딩

- 프로그램의 실행이 시작될 때에 물리적 메모리 주소가 결정되는 주소 바인딩 방식
- **로더(loader)**에 의해 물리적 메모리 주소가 부여되고, 프로그램 종료 때까지 물리적 메모리상의 위치가 고정됨
    - 로더: 사용자 프로그램을 메모리에 적재시키는 프로그램
- 컴파일러가 재배치 가능 코드를 생성한 경우에 사용 가능

### 실행 시간 바인딩

- 프로그램이 실행 시작된 이후로도 물리적 메모리상 주소가 변경될 수 있는 주소 바인딩 방식
- CPU가 주소를 참조할 때마다 데이터가 어느 위치에 존재하는지 알기 위해 주소 매핑 테이블을 이용해 바인딩 점검
- 실행시간 바인딩 방식이 가능 → 기준 레지스터, 한계 레지스터를 포함, MMU의 하드웨어적 지원이 필요하다.
    - MMU (Memory Management Unit)

### MMU 기법 (MMU schema) - 주소 변환 기법

- CPU가 특정 프로세스의 논리적 주소를 참조하려고 할 때, **그 주소값에 기준 레지스터의 값을 더해 물리적 주소값을 얻는다.**
- MMU 기법에서 사용자 프로그램, CPU는 논리적 주소만을 다루고, 물리적 주소는 알지 못 하고 알 필요가 없다.
- `기준 레지스터 == 재배치 레지스터 (relocation register)`, 프로세스의 **물리적 메모리 시작 주소**를 갖고 있다.
- 프로세스별로 존재하는 논리적 주소를 물리적 주소로 매핑하려면?
    - 프로세스마다 고유한 주소 공간이 있으므로 논리적 주소값이 같아도 서로 다른 내용이 담긴다.
    - MMU 기법에서는 문맥교환으로 수행 중인 프로세스가 바뀔 때마다, 재배치 레지스터의 값을 해당 프로세스에 맞는 값으로 재설정을 한다.
- 주소 변환을 하여 얻은 물리적 주소가 해당 프로세스의 주소 공간을 벗어나는 경우
    - 메모리 보안이 이루어지지 않아 다른 수행 중인 프로그램 영역을 침범하거나, 운영체제 영역을 변경하게 되면 치명적 결과를 초래할 수 있다.
    - 이를 방지하기 위해 `한계 레지스터 (limit register)`를 사용하여, 현재 수행 중인 프로세스의 논리적 주소의 최댓값(= 프로세스의 크기)를 담고 있다.
    - 현재 수행 중인 프로세스가 자신의 주소 공간을 넘어서는 메모리 참조를 하려고 하는지 체크하는 용도
        

## 메모리 관리와 관련된 용어

### 동적로딩 (dynamic loading)

- 여러 프로그램이 동시에 메모리에 올라가서 수행되는 다중 프로그래밍 환경에서, 메모리 사용의 효율성을 높이기 위해 사용하는 기법
- 프로세스의 주소 공간 전체가 아닌, 불리는 부분만을 메모리에 적재하는 방식
- 프로그램 코드의 대부분은 오류 처리루틴과 같은 방어용 코드이므로, 자주 발생하지 않지만 많은 메모리를 사용해 메모리 낭비가 이루어진다.

### 동적연결 (dynamic linking)

- 연결: 프로그래머가 작성한 소스 코드를 컴파일하여 생긴 `목적 파일` + 이미 컴파일된 `라이브러리 파일`들 **⇒** `**하나의 실행파일**`을 생성하는 과정
- 정적연결: 프로그래머가 작성한 코드와 라이브러리 코드가 모두 합쳐져서 실행파일이 생성됨
    
    → 실행파일의 크기가 크고, 동일한 라이브러리를 프로세스마다 개별적으로 메모리에 올리므로 물리적 메모리가 낭비됨
    
- 동적연결: 목적 파일과 라이브러리 파일 사이의 연결을 프로그램의 실행 시점까지 지연시키는 방법
    
    → 실행 파일에 라이브러리 코드가 포함되지 않는다. 
    
- 실행 파일의 라이브러리 호출 부분에 해당 라이브러리를 찾기 위한 `스텁 (stub)`이라는 코드가 포함
    - 스텁을 통해 해당 라이브러리를 찾아서, 메모리에 있으면 그 주소의 메모리 위치에서 직접 참조하고,
        
        메모리에 없으면 디스크에서 동적 라이브러리 파일을 찾아 메모리에 적재한 후 수행한다.
        

### 중첩 (overlays)

- 프로세스의 주소 공간을 분할해 실제 필요한 부분만을 메모리에 적재하는 기법
- 동적로딩 vs 중첩
    - 중첩: 물리적 메모리의 크기 제약으로, 하나의 프로세스조차도 메모리에 한 번에 올릴 수 없을 때, 주소 공간을 분할해서 필요한 부분 올리고 → 실행 끝나면 나머지 부분 올리고 한다.
        - 단일 프로세스만을 메모리에 올리는 환경에서, 메모리 용량보다 큰 프로세스를 실행하기 위한 방법
    - 동적로딩: 메모리의 이용률을 향상시키기 위해 프로세스의 주소 공간 중 당장 필요한 부분을 그때그때 메모리에 동적으로 올린다.
        - 다중 프로그래밍 환경에서, 메모리에 더 많은 프로세스를 동시에 올려놓고 실행하기 위한 방법

### 스와핑 (swapping)

- 메모리에 올라운 프로세스의 주소 공간 전체를 디스크의 스왑 영역(= 백킹 스토어(backing store)) 에 일시적으로 내려놓는 것
- 스왑 영역
    - 디스크 내에 파일 시스템과는 별도로 존재하는 일정 영역
    - 프로세스가 수행 중인 동안에만 디스크에 일시적으로 저장하는 공간 → 저장 기간이 상대적으로 짧다.
    - 다수의 프로세스를 담을 수 있을 만큼 충분히 크고, 접근 속도가 보장되어야 한다.
    - `스왑 인`: 디스크 → 메모리로 올리는 작업
        
        `스왑 아웃`: 메모리 → 디스크로 내리는 작업  (프로세스 종료 후 디스크로 내쫓는 것이 아님)
        
- 스와핑의 과정
    - `스와퍼(swapper)`라고 불리는 **중기 스케줄러**에 의해, 스왑 아웃시킬 프로세스를 선정
    - 해당 프로세스에 대해, 메모리에 올라가 있는 주소 공간의 내용 통째로 스왑 아웃
    - 스왑 아웃되었던 프로그램이 다시 메모리에 올라감
        - 컴파일 타임 바인딩, 로드 타임 바인딩 → 다시 스왑인 될 때, 기존 위치하던 곳으로 다시 돌아가야 함
        - 실행시간 바인딩 → 스왑인될 때, 빈 메모리 영역 아무 곳에나 프로세스가 올라갈 수 있음
- 스와핑의 역할
    - 메모리에 존재하는 프로세스의 수를 조절하는 것. 즉, 다중 프로그래밍의 정도를 조절

## 물리적 메모리의 할당 방식

### 물리적 메모리 영역

- 운영체제 상주 영역
    - 인터럽트 벡터와 함께 물리적 메모리의 **낮은 주소 영역** 사용
    - 운영체제 커널 역시 위치함
- 사용자 프로세스 영역
    - 물리적 메모리의 **높은 주소 영역** 사용
    - 사용자 프로세스들이 적재되고 실행됨
    - 관리 방법: `연속할당`, `불연속할당`

### **연속할당 (contiguous allocation)**

- 각각의 프로세스를 물리적 메모리의 연속적인 공간에 올리는 방식
- **고정분할 (fixed partition allocation) 방식**
    - 물리적 메모리를 주어진 개수만큼 고정된 크기의 분할(partition)로 미리 나누는 방식
    - 분할의 크기는 모두 동일할 수도, 다를 수도 있으나, **하나의 분할에는 하나의 프로그램만** 적재할 수 있다.
    - 메모리에 올릴 수 있는 프로그램의 수가 고정, 수행 가능한 프로그램의 최대 크기 제한 존재
    - 외부조각, 내부조각 발생 가능 → 메모리 낭비
        - **외부조각 (external fragmentation)**: 프로그램보다 분할이 작아서, 분할이 비어 있는데도 프로그램을 적재할 수 없을 때 발생하는 메모리 공간
        - 내**부조각 (internal fragmentation)**: 프로그램보다 분할이 커서, 해당 분할에 프로그램을 적재하고 남는 메모리 공간
- **가변분할 (variable partition allocation) 방식**
    - 분할을 미리 나누지 않고, 프로그램이 실행되고 종료되는 순서에 따라 분할을 관리하는 방식
        - 분할의 크기, 개수가 동적으로 변한다.
    - 내부조각은 발생하지 않으나, 외부조각은 발생할 가능성이 있다.
        - 이미 존재하는 프로그램이 종료된 후, 이 공간보다 작은 크기의 프로그램이 왔을 때
    - `동적 메모리 할당 문제 (dynamic storage-allocation problem)`
        - 물리적 메모리 내 가용 공간 중 어떤 위치에 프로세스를 올릴 것인지를 결정하는 문제
            - 가용 공간: 사용되지 않은 메모리 공간
        - **최초적합 (first-fit)** 방법
            - 크기가 n 이상인 가용 공간 중 가장 먼저 찾아지는 곳에 프로세스를 할당
            - 시간 측면에서 효율적
        - **최적적합 (best-fit)** 방법
            - 크기가 n 이상인 가용 공간 중 가장 작은 공간에 프로세스를 할당
            - 시간적 오버헤드 발생, 다수의 매우 작은 가용 공간 생성 가능 / 공간 측면에서 효율적
        - **최악적합 (worst-fit)** 방법
            - 가용 공간 중 가장 크기가 큰 곳에 프로세스를 할당
            - 시간적 오버헤드 발생, 가용 공간을 빨리 소진하는 문제
    - 컴팩션 (compaction)
        - 외부조각 문제를 해결하기 위한 방법
        - 사용 중인 메모리 영역을 한쪽으로 몰고, 가용 공간들을 다른 한쪽으로 모아 하나의 큰 가용 공간을 만드는 방법
            - 실행 중인 프로세스의 메모리상 위치를 옮겨야 하므로 비용이 많이 들어 효율적으로 컴팩션하기 어려움

### **불연속할당 (noncontiguous allocation)**

- 하나의 프로세스를 물리적 메모리의 여러 영역에 분산해 적재하는 방식
- **페이징 (paging) 기법**
    - 각 프로세스의 주소 공간을 동일한 크기의 페이지로 잘라, 메모리에 페이지 단위로 적재시키는 방식
- **세그먼테이션 (segmentation) 기법**
    - 데이터, 스택 등 의미 있는 단위(`세그먼트`)로 나누어 세그먼트 단위로 적재하는 방식
- **페이지드 세그먼테이션 (paged segmentation) 기법**
    - 세그먼트 하나를 다수의 페이지로 구성하여 세그먼트 단위로 적재하는 방식

## 페이징 기법

- 프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 물리적 메모리의 서로 다른 위치에 페이지들을 저장하는 방식
- 물리적 메모리를 페이지와 동일한 크기의 `프레임(frame)`으로 나누어둔다.
- 페이지 테이블 (page table)
    - 페이지별 주소 변환 정보 → 특정 프로세스의 특정 페이지가 물리적 메모리의 몇 번째 프레임에 들어 있는지 알기 위함
- 프로세스의 주소 공간과 물리적 메모리가 같은 크기로 나뉘므로, 외부 조각 문제는 발생하지 않으나, 내부조각 발생 가능성은 존재


### 주소 변환 기법

- CPU가 사용하는 논리적 주소 → **페이지 번호(p)**, **페이지 오프셋(d)** 으로 나누어 주소 변환에 사용
- 페이지 번호 → 페이지 테이블 접근 시 **인덱스**로 사용
- 인덱스의 항목에는 물리적 메모 상의 기준 주소 (== 시작 위치) 가 저장된다.
- 오프셋은 하나의 페이지 내에서의 변위 (displacement) 를 알려준다.

### 페이지 테이블의 구현

- 페이징 기법에서 주소 변환을 하기 위한 자료구조, 물리적 메모리에 위치한다.
- **페이지 테이블 기준 레지스터 (PTBR)**: 메모리 내에서의 페이지 테이블의 시작 위치
    
    **페이지 테이블 길이 레지스터 (PTLR)**: 페이지 테이블의 크기
    
- 메모리 접근 연산
    
    (1) 주소 변환을 위해 페이지 테이블에 접근하는 것
    
    (2) 변환된 주소에서 실제 데이터에 접근하는 것
    
    - 메모리 접근을 위해 메모리에 2번 접근해야 하는 오버헤드가 존재
        
        → 오버헤드를 줄이고, 메모리 접근 속도 향상을 위한 **TLB (Translation Look-aside Buffer)**라는 고속의 주소 변환용 하드웨어 캐시가 사용되기도 한다.
        
- TLB에 의한 페이지 기법

    - TLB는 비싸서.. 페이지 테이블의 모든 정보를 담을 수는 없고,
        
        빈번하게 참조되는 페이지에 대한 주소 변환 정보만을 담고 있다.
        
    - 요청된 페이지 번호가 TLB에 있다 → 대응하는 물리적 메모리의 프레임 번호 획득
        
        TLB에 존재하지 않는다 → 메인 메모리에 있는 페이지 테이블로부터 프레임 번호 획득
        
- 페이지 테이블과 TLB
    - 페이지 테이블은 페이지 번호에 따라 주소 변환 정보가 순차적으로 존재
        
        TLB는 페이지 번호-프레임 번호가 쌍으로 저장
        
    - TLB의 모든 항목을 찾아야 하는 오버헤드를 줄이기 위해서
        
        → **병렬 탐색 (parallel search)**이 가능한 **연관 레지스터 (associative resister)**를 사용
        
        - 연관 레지스터를 사용할 때 평균 메모리 접근 시간 (EAT)
            
            $EAT = (1+\epsilon)\alpha+(2+\epsilon)(1-\alpha) = 2+\epsilon-\alpha$
            
            $\epsilon$: 연관 레지스터에 접근하는 시간. <1
            
            $\alpha$: 요청 페이지에 대한 주소 변환 정보가 연관 레지스터에 존재할 확률
            

### 계층적 페이징

- 수행 중인 프로세스의 개수가 증가하면 상당한 메모리가 페이지 테이블에 할애된다. → 메모리 공간 낭비
- 메모리 공간 낭비를 줄이기 위해 `2단계 페이징 기법 (two-level paging)`을 사용
    - 외부 페이지 테이블
    - 내부 페이지 테이블
- 사용되지 않는 주소공간 → 외부 페이지 테이블이 NULL, 대응하는 내부 페이지 테이블 생성 X
- 공간 낭비를 줄일 수 있음 ↔ 시간적 손해 (주소 변환을 위해 접근하는 테이블 수가 증가하므로)
- 주소 변환

    - <p1, p2, d>
        - 외부 페이지 테이블의 인덱스 p1
        - 내부 페이지 테이블의 인덱스 p2
        - 페이지 오프셋 d
- 프로세스의 주소 공간이 커질수록 페이지 테이블의 크기도 커지므로, 메모리 공간 낭비가 심해진다.
    - 다단계 페이지 테이블이 필요
    - 공간적 효율은 증가하나, 시간적 효율에 문제가 생길 수 있다.
    - 결국, 시간적 오버헤드를 줄이기 위해서는 TLB를 함께 사용하는 것이 효과적!

### 역페이지 테이블

- 물리적 메모리의 페이지 프레임 하나당 페이지 테이블에 하나씩의 항목을 두는 방식
    - 논리적 주소에 대한 페이지 테이블이 아닌, 물리적 주소에 대한 페이지 테이블을 만든다.
    - 각 프로세스마다가 아니라, 시스템 전체에 페이지 테이블 하나만 둔다.
    
- 페이지 테이블의 각 항목은 **프로세스 번호(pid)**, 프로세스 내의 **논리적 페이지 번호(p)**를 갖고 있다.
- 주소 변환
    - 주소 변환 요청이 들어오면, 그 주소를 담은 페이지가 물리적 메모리에 존재하는지 여부를 판단하기 위해 페이지 테이블 전체를 다 탐색해야 한다. → 상당한 시간 소모 → 역페이지 테이블을 메모리가 아닌 **연관 레지스터**에 보관함으로써 병렬탐색을 가능하도록 함

### 공유 페이지

- 공유 코드
    - 메모리 공간의 효율적인 사용을 위해 여러 프로세스에 의해 공통으로 사용될 수 있도록 작성된 코드
    - 재진입 가능 코드, 순수 코드 라고도 불림
    - 읽기 전용
- 공유 페이지
    - 공유 코드를 담고 있는 페이지
    - 여러 프로세스에 의해 공유되므로, 물리적 메모리에 하나만 적재되어 효율적 메모리 사용 가능
- ↔ 사유 페이지: 프로세스별로 독자적으로 사용하는 페이지

### 메모리 보호

- 페이지 테이블의 각 항목에는 주소 변환 정보 뿐만 아니라, 메모리 보호를 위한 **보호비트(protection bit)**와 **유효-무효 비트(valid-invalid bit)**를 두고 있다.
- 보호비트: 각 페이지에 대한 접근 권한의 내용
    - 누구에 의한 접근이 아닌, 어떠한 접근을 허용하는지 여부
    - 각 페이지에 대한 읽기쓰기, 읽기전용 등의 접근 권한 설정
- 유효-무효 비트: 해당 페이지의 내용이 유효한지에 대한 내용
    - 유효 → 해당 메모리 프레임에 그 페이지가 존재함 → 접근 허용
        
        무효 → 프로세스가 그 주소를 사용하지 않거나, 해당 페이지가 물리적 메모리가 아닌 백킹스토어에 존재함을 의미
        

## 세그먼테이션

- 하나의 프로세스를 구성하는 주소 공간: `코드`, `데이터`, `스택` 등의 의미 있는 단위들
- 세그먼트: 주소 공간을 기능 단위 또는 의미 단위로 나눈 것
    - 주소 공간 전체가 하나의 세그먼트가 될 수도, 일반적으로는 코드,데이터,스택 등의 기능 단위로 정의
    - 이러한 특징으로, 세그먼트는 크기가 균일하지 않다.
- 논리적 주소가 **<세그먼트 번호, 오프셋>**으로 나뉘어 사용된다.
    - 세그먼트 번호: 해당 논리적 주소가 프로세스 주소 공간에서 몇 번째 세그먼트에 속하는지
    - 오프셋: 그 세그먼트 내에서 얼마만큼 떨어져 있는지
- **세그먼트 테이블**
    - 각 항목은 `기준점(base)`과 `한계점(limit)`을 갖는다.
        - 기준점: 물리적 메모리에서 그 세그먼트의 시작 위치
        - 한계점: 그 세그먼트의 길이
    - **세그먼트 테이블 기준 레지스터(STBR)**
        
        : 현재 CPU에서 실행 중인 프로세스의 세그먼트 테이블의 메모리 상 시작 주소
        
        **세그먼트 테이블 길이 레지스터(STLR)**
        
        : 프로세스의 주소 공간이 갖는 총 세그먼트의 개수
        
- **세그먼테이션 기법**
    - 주소 변환 전 확인하는 사항
        - (1) 요청된 세그먼트 번호가 STLR에 저장된 값보다 작은 값인지
            - 그렇지 않다면, 존재하지 않는 세그먼트에 대한 접근 시도 → 예외 발생
        - (2) 논리적 주소의 오프셋 값이 그 세그먼트의 길이보다 작은 값인지
            - 세그먼트 테이블의 해당 항목에 있는 한계점과, 요청된 논리적 주소의 오프셋값 비교
            - 그렇지 않다면 → 예외 발생
        - 두 가지를 모두 만족하는 경우에 한해 주소 변환 작업을 한다.
    - 세그먼트 테이블 각 항목에 **보호비트, 유효비트**를 둔다. 또한 **공유 세그먼트**를 공유해 사용한다
        - 공유 세그먼트는 모든 프로세스의 주소 공간에서 동일한 논리적 주소에 위치해야 한다.
        
- 장점
    - 의미 단위로 나뉘어져 있기 때문에, 공유와 보안의 측면에서 훨씬 효과적
- 단점
    - 세그먼트의 길이가 일정하지 않다. → 물리적 메모리 관리에서 외부조각이 발생한다.

## 페이지드 세그먼테이션

- 페이징 기법과 세그먼테이션 기법의 장점만을 취하는 주소 변환 기법
- 프로그램을 의미 단위의 세그먼트로 나누되, 세그먼트는 반드시 동일한 크기 페이지들의 집합으로 구성되며,
    
    물리적 메모리에는 페이지 단위로 적재된다.
    
    ⇒ 하나의 세그먼트 크기가 페이지 크기의 배수가 되도록 함 
    
    → 외부 조각의 문제점을 해결하고 (세그먼테이션), 
    
    세그먼트 단위로 프로세스 간의 공유나 접근 권한 보호가 이루어짐 (페이징)
    
- 주소 변환
    - 2단계의 테이블을 이용: 외부의 세그먼트 테이블, 내부의 세그먼트 테이블
    - <세그먼트 번호, 오프셋> 으로 구성된 논리 주소
        
        → 세그먼트 번호를 통해 세그먼트 테이블의 해당 항목에 접근
        
        → 세그먼트 항목 <= 세그먼트 길이, 세그먼트의 페이지 테이블 시작 주소
        
        → 오프셋의 상위비트는 세그먼트 내의 페이지 번호, 하위비트는 페이지 내의 변위로 사용
        
        → 세그먼트 페이지 테이블 시작 위치로부터, 페이지 번호만큼 떨어진 페이지 테이블 항목을 찾음
        
        → 페이지 테이블 항목으로부터 물리적 메모리의 페이지 프레임 위치를 얻음
        
        → 이 위치에서 변위만큼 떨어진 곳이 바로 **물리적 메모리 주소**