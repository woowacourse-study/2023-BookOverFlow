# 1.3 스케줄링

## 1.3.1 스케줄링의 목적

멀티 프로세스 환경에서 모든 프로세스를 공평하게 실행하는 것

- 공평성 - 모든 프로세스가 공평하게 실행되어야함, 특정 프로세스가 실행되지 않는 경우가 없도록 스케줄링 해야함
- 효율성 - 자원을 효율적으로 사용해 자원이 사용되지 않는 시간이 없도록 스케줄링 해야함
- 안정성 - 우선순위를 고려해 높은 우선순위의 프로세스를 먼저 처리하도록 스케줄링 해야함
- 반응 시간 보장 - 프로세스가 오랜 시간 응답이 없으면 사용자는 시스템이 멈춘 것으로 보기 때문에 일정 시간 내에 응답할 수 있도록 스케줄링 해야함
- 무한 연기 방지 - 특정 프로세스에 대한 처리가 무한히 연기되지 않도록 스케줄링 해야함

## 1.3.2 스케줄링의 단계

- 장기 스케줄링(long-term scheduling)
    - 준비 큐에 어떤 프로세스를 넣을지 결정해 메모리에 올라가는 프로세스 수를 조절
    - 잡 스케줄링(job scheduling) or 승인 스케줄링(admission scheduling)이라고 함
    - 현대 운영체제에서는 시분할 시스템을 사용하기 때문에 대부분 사용하지 않음
        - 시분할 시스템(Time Sharing System)은 여러 명의 사용자가 사용하는 시스템에서 컴퓨터가 사용자들의 프로그램을 번갈아가며 처리해줌으로써 각 사용자에게 독립된 컴퓨터를 사용하는 느낌을 주는 것으로, 라운드 로빈(Round Robin)방식이라고도 합니다.
- 중기 스케줄링(mid-term scheduling)
    - 메모리에 로드된 프로세스 수를 동적으로 조절
    - 메모리에 프로세스가 많이 로드되면 스왑 아웃(swap out)해서 일부 프로세스를 통째로 저장
    - 스왑 아웃된 프로세스는 중단(suspended)가 됨
    - 중단 상태는 준비 상태에서 스왑 아웃된 ‘중단된 준비 상태’와 대기 상태에서 스왑 아웃된 ‘중단된 대기 상태’로 구분
- 단기 스케줄링(short-term scheduling)
    - 준비 큐에 있는 대기 상태 프로세스 중 어떤 프로세스를 다음으로 실행할지 스케줄링 알고리즘으로 결정
    - 어떤 프로세스를 디스패치할지 결정 → CPU 스케줄링

  ![IMG_E40829ABDC01-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/04e143e2-dcef-4aea-8408-febce35e0c48)

  ![IMG_DCEC96299392-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/367c0429-518c-4328-a76c-35cffb32a1e8)

  스케줄러 관점에서 스케줄링

    1. 스케줄러가 준비 큐에 있는 프로세스 중 하나를 선택해 CPU에 디스패치 → 스케줄링 알고리즘 이용
    2. CPU에서 프로세스 실행, 이 때 프로세스는 실행 상태
        1. 프로세스 수행이 완료되면 프로세스 종료
        2. 일정 시간을 초과하면 인터럽트가 발생해 프로세스가 준비 큐로 들어가고 준비 상태가 됨
        3. 입출력 요청이 들어오면 인터럽트 발생, 프로세스는 대기 큐로 들어가서 대기상태가 됨, 입출력이 완료되면 프로세스는 준비 큐로 돌아감
    3. fork() 호출되면 자식 프로세스가 생성되고, 자식 프로세스는 준비 큐로 들어감

## 1.3.3 스케줄링 알고리즘

CPU 스케줄러(단기 스케줄러)가 준비 큐에 있는 프로세스 중 어떤 프로세스를 실행시킬지 결정하는 데 사용

스케줄링 목적을 달성하기 위한 평가 기준

- CPU 사용률 - CPU를 놀지 않고 사용하는지 판단, 전체 시간 중에서 CPU가 일을 한 시간 비율 나타냄
- 처리량 - 단위 시간(time unit)당 실행한 프로세스 수, 주어진 시간 동안 준비 큐에서 기다리고 있는 프로세스 중 몇 개를 끝마쳤는지를 나타냄
- 응답 시간 - 프로세스에 요청이 발생했을 때 응답까지 걸리는 시간
- 반환 시간 - 프로세스가 로드된 이후부터 종료될 때까지 걸리는 시간
- 대기 시간 - 프로세스가 대기 큐에서 대기하는 시간의 총합

스케줄링 알고리즘

- 비선점형 스케줄링(non-preemptive scheduling)
    - 실행중인 프로세스가 종료될 때까지 다른 프로세스를 실행할 수 없음을 의미
    - FCFS(First Come First Served) 스케줄링
        - 준비 큐에 먼저 들어온 프로세스가 우선순위를 갖는 알고리즘
        - 준비 큐에 먼저 들어온 프로세스를 먼저 실행
        - 평균 대기시간이 길어짐 - CPU 버스트가 긴 프로세스 하나가 CPU 버스트가 짧은 여러 개의 프로세스보다 먼저 온 경우 → convoy 현상
        - 먼저 도착한 프로세스의 성격에 따라 평균 대기시간이 크게 달라짐
    - SJF(Shortest Job First) 스케줄링
        - 실행 시간이 짧은 프로세스가 우선순위를 갖는 알고리즘
        - SJN(Shortest Job Next) 스케줄링
        - 준비 큐에 있는 프로세스 중 CPU를 점유하는 실행 시간이 가장 짧은 프로세스부터 실행
        - 평균 대기시간이 가장 짧지만, 실행시간이 긴 프로세스는 실행시간이 짧은 프로세스에 밀려 기아 상태가 될 수 있음
            - 기아 상태 - 프로세스마다 우선순위가 있는데, 우선순위가 높은 프로세스만 수행되어 우선순위가 낮은 특정 프로세스는 계속 실행되지 못함
        - 비선점형과 선점형 두 가지 방식으로 구현 가능
            - SJF 선점형 구형 방식 → SRTF(Shortest Remaining Time First) —> 이게 평균 대기시간이 가장 줄일 수 있음
    - HRRN(Highest Response Ration Next) 스케줄링
- 선점형 스케줄링(preemptive scheduling)
    - 스케줄러가 실행 중인 프로세스를 중단시키고 다른 프로세스를 실행할 수 있음을 의미
    - RR(Round Robin) 스케줄링
        - 비선점형 스케줄링과 달리 프로세스 간 우선순위 없음
        - 모든 프로세스를 순서대로 일정 시간 동안 실행하며 일정 시간을 초과하면 다른 프로세스 실행
            - 일정시간 - ‘시간 단위’를 의미, 타임 퀀텀(time quantum) or 타임 슬라이스(time slice)
            - 시간 단위 - 10~100밀리초
            - 일정시간이 길면 FCFS와 같은 결과를 나타냄
            - 일정시간이 만료되어 CPU를 회수하는 방법 → 타이머 인터럽트 사용
        - 컨텍스트 스위칭이 빈번하게 일어나서 오버헤드가 크다는 단점
        - 모든 프로세스가 반복 수행되어 응답 속도가 빠르다는 장점
        - 공정한 스케줄링 방식
        - 대기시간, 반환시간 CPU 쓰고자 하는 양에 비례
    - SRTF(Shortest Remaining Time First) 스케줄링
        - 준비 큐에서 대기 시간이 가장 짧게 남은 프로세스를 우선 수행하는 알고리즘
        - 한 프로세스가 실행 중일 때 실행 시간이 더 짧은 프로세스가 준비 큐에 들어오면 실행시간이 더 짧은 프로세스가 CPU 차지
        - 평균 대기 시간이 짧다는 장점
        - 수행시간이 긴 프로세스는 기아 상태가 되기 쉬움
    - 멀티 레벨 스케줄링
        - 준비 큐를 목적에 따라 여러 개로 분리해 사용하는 알고리즘
        - 분리한 큐는 각각 우선순위가 있고 각자 다른 스케줄링 알고리즘을 적용
        - 여러 개의 큐는 foreground 큐와 background 큐로 나뉨
        - foreground 큐에는 응답속도가 중요한 프로세스가 들어감
        - background 큐에는 응답 속도보다 성능을 중요시하는 프로세스가 들어감

### 스케줄링 예제

![IMG_03A7B6A5E6BB-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/c6211024-5b0b-4b2c-a21d-21b89f0839a5)

평균 대기시간 - 각 프로세스의 대기 시간을 합한 뒤 프로세스의 수로 나눈 것

1) FCFS

![IMG_5550D21B15D0-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/9c8490b3-6a51-452b-aa24-3c382f0b578b)

![IMG_520656DA54D3-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/e93bd19c-b572-4770-a4bc-878d833b0198)

2) SJF

![IMG_A91BD5D21C39-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/73b98bb1-85cf-4f9e-9b73-c572adb446eb)

![IMG_24D7E124B89C-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/ad6cd55b-9e24-4114-bae0-deead6d661a2)

3) RR 스케줄링 - 시간 단위: 50으로 한 경우

![IMG_345C75CAE1AE-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/4bba1a9a-0360-4fc5-9265-e3482fc03186)

어떤 프로세스에서 응답 요청이 들어왔을 때 기다리는 최대 시간

- (전체 프로세스의 수 - 1) x (시간 단위)

위 예제 에서는 (5 - 1) x 50 = 200밀리초

응답속도가 다른 스케줄링보다 빠르지만 컨텍스트 스위칭이 빈번하게 일어나므로 시간 단위를 적절하게 설정해야함

4) SRTF

![IMG_3395BEEA21F0-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/26c9425e-4958-4a60-a217-3de380de6715)

![IMG_3BFDB08DAC09-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/231d1bd8-92b0-4e74-ab9e-7aa7908be913)

평균 대기 시간이 짧음, 실행 시간이 긴 프로세는 기아 상태가 되기 시움

5) 멀티 레벨 스케줄링
