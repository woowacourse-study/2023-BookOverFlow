# 운영체제 1.3

# 스케줄링의 목적

멀티 프로세스 환경에서 모든 프로세스를 공평하게 실행하기

- **공평성** : 모든 프로세스가 공평하게, 특정 프로세스가 실행되지 않는 경우가 없도록 스케줄링해야 한다.
- **효율성** : 자원을 효율적으로 사용해 자원이 사용되지 않는 시간이 없도록 스케줄링해야 한다.
- **안전성** : 우선순위를 고려해 높은 우선순위의 프로세스를 먼저 처리하도록 스케줄링해야 한다.
- **반응 시간 보장** : 프로세스가 오랜 시간 응답이 없으면 사용자는 시스템이 멈춘 것으로 보기 때문에 일정 시간 내에 응답할 수 있도록 스케줄링해야 한다.
- **무한 연기 방지** : 특정 프로세스에 대한 처리가 무한히 연기되지 않도록 스케줄링해야 한다.

# 스케줄링 단계

### 장기 스케줄링(long-term scheduling)

- 준비 큐에 어떤 프로세스를 넣을지 결정하여 메모리에 올라가는 프로세스 수 조절
- 잡 스케줄링(job scheduling) / 승인 스케줄링(admission scheduling)
- 현대 운영체제에서는 시분할 시스템을 사용해서 대부분 안 씀
    - 시분할 시스템 : 시간 나눠서 시스템을 사용하는 것, 프로그램을 번갈아가며 처리

### 중기 스케줄링(mid-term scheduling)

- 메모리에 로드된 프로세스 수를 동적으로 조절
- 메모리에 프로세스가 많이 로드 되면 swap out해서 일부 프로세스를 통째로 저장
    - 이 때, swap out된 프로세스 → 중단 상태(suspended)가 됨
    - 중단 상태
        - 준비 상태 → swap out `중단된 준비 상태`
        - 대기 상태 → swap out `중단된 대기 상태`

### 단기 스케줄링(short-term scheduling)

- 준비 큐에 있는 대기 상태 프로세스 중 어떤 프로세스를 다음으로 실행할지 스케줄링 알고리즘으로 결정
- CPU 스케줄링

![IMG_6119](https://github.com/woowacourse-study/2023-cs-study/assets/15646373/61195977-4f7a-4c96-9b36-6ec7a2997c1f)

1. 스케줄러가 준비 큐에 있는 프로세스 중 하나를 선택해 CPU에 디스패치 (스케줄링 알고리즘 사용)
2. CPU에서 프로세스 실행 (프로세스 : 실행 상태)
    
    A. 프로세스 수행이 완료되면 프로세스 종료
    
    B. 일정 시간을 초과하면 인터럽트가 발생해 프로세스가 준비 큐로 들어가고 준비 상태
    
    C. 입출력 요청이 들어오면 인터럽트 발생, 프로세스는 대기 큐로 들어가서 대기 상태가 됨. 입출력이 완료되면 프로세스는 준비 큐로 들어감
    
3. `fork()`가 호출되면 자식 프로세스가 생성되고, 자식 프로세스는 준비 큐로 들어감

### 용어 정리

- **스왑 아웃(swap out)**
    - 프로세스가 실행되려면 메모리에 로드되어야 하는데, 메모리 공간 보다 많은 프로세스가 로드되는 경우!
    - 중기 스케줄러가 이벤트 발생을 기다리고 있는 프로세스를 통째로 저장공간(SSD와 같은 영역)으로 옮겨 저장
- **스왑 인(swap in)**
    - 스왑 아웃한 프로세스에서 이벤트 요청이 오면 해당 프로세스를 통째로 다시 메모리에 로드
- **스와핑(swapping)**
    - 프로세스를 통째로 메모리 영역과 저장 공간으로 옮기는 것
    - 메모리 공간보다 많은 프로세스를 실행할 수 있다는 장점

# 스케줄링 알고리즘

CPU 스케줄러(단기 스케줄러)가 준비 큐에 있는 프로세스 중 어떤 프로세스를 실행시킬지 결정하는데 사용

### 평가 기준

- CPU 사용률 : CPU를 놀리지 않고 사용하는가?
- 처리량 : 단위 시간(time unit)당 실행한 프로세스 수
- 응답 시간 : 프로세스에 요청이 발생했을 때 응답까지 걸리는 시간
- 반환 시간 : 프로세스가 로드된 이후부터 종료될 때까지 걸리는 시간
- 대기 시간 : 프로세스가 대기 큐에서 대기하는 시간의 총합

## 비선점형 스케줄링 (non-preemptive scheduling)

실행 중인 프로세스가 종료될 때까지 다른 프로세스를 실행할 수 없음을 의미

### FCFS(First Come First Served) 스케줄링

- 준비 큐에 들어온 프로세스가 우선순위를 갖는 알고리즘
- 준비 큐에 먼저 들어온 프로세스(first come)을 먼저 실행(first served)함

### SJF(Shortest Job First) 스케줄링

- 실행 시간이 짧은 프로세스가 우선순위를 갖는 알고리즘
- == SJN(Shortest Job Next) 스케줄링
- 준비 큐에 있는 프로세스 중 CPU를 점유하는 실행 시간이 가장 짧은 프로세스(shortest job)부터 실행
- 평균 대기 시간이 가장 짧지만, 실행 시간이 긴 프로세스는 실행 시간이 짧은 프로세스에 밀려 기아 상태가 될 수 있음
    - 기아 상태(starvation) : 우선순위가 높은 프로세스만 수행되어 우선 순위가 낮은 특정 프로세스는 계속 실행되지 못하는 것
- 이전 결과를 바탕으로 예상 실행 시간을 예측함

### HRRN(Highest Response Ratio Next) 스케줄링

- 각 작업의 우선순위로 서비스 해주는 스케줄링
- 오랫동안 대기하는 프로세스의 우선순위를 증가 시킴
- 기아 상태 해결 가능

## 선점형 스케줄링 (preemptive scheduling)

스케줄러가 실행 중인 프로세스를 중단시키고 다른 프로세스를 실행할 수 있음을 의미

다른 프로세스를 실행시킨다는 트리거 → 다른 프로세스가 준비큐에 들어올 때!

### RR(Round Robin) 스케줄링

- 프로세스 간 우선순위 X
- 모든 프로세스를 순서대로 일정 시간 동안 실행, 초과 시 다른 프로세스를 실행
    - 일정 시간 == 시간 단위 == 타임 퀀텀(time quantum) == 타임 슬라이스(time slice)
    - 일반적으로 시간 단위는 10~100밀리초
    - 시간 단위가 커질 수록 FCFS와 같아짐
- Context Switching이 빈번하게 일어나서 오버헤드가 크다는 단점 → 그래서 타임 퀀텀을 잘 정하는 것이 중요함
- 모든 프로세스가 반복 수행되어 응답 속도가 빠르다는 장점

### SRTF(Shortest Remaining Time First) 스케줄링

- 준비 큐에서 대기 시간이 가장 짧게 남은 프로세스(shortest remaining time)을 우선 수행(first)하는 알고리즘
- 한 프로세스가 실행중일 때 실행시간이 더 짧은 프로세스가 준비 큐에 들어오면 실행 시간이 더 짧은 프로세스가 CPU를 차지
- 평균 대기 시간이 짧다는 장점
- 수행 시간이 긴 프로세스는 기아 상태가 되기 쉬움

### 멀티 레벨 스케줄링

- 준비 큐를 목적에 따라 여러 개로 분리해 사용하는 알고리즘
- 분리한 큐는 각각 우선순위가 있고 각자 다른 스케줄링 알고리즘을 적용할 수 있음
- foreground 큐 - 응답 속도가 중요한 프로세스
- background 큐 - 응답 속도보다 성능을 중요시하는 프로세스
      
    ![IMG_6122](https://github.com/woowacourse-study/2023-cs-study/assets/15646373/8823bd3b-6947-4194-901a-4d1433553b27)


## 예제

책 p.46

평균 대기 시간 : 각 프로세스 대기 시간을 합한 뒤 프로세스 수로 나눈 것

RR 스케줄링에서 어떤 프로세스에서 응답 요청이 들어왔을 때 기다리는 최대 시간 = (전체 프로세스 수) - 1
