# 운영체제 1.4

Created: December 4, 2023 9:51 PM

# 논리 메모리&물리 메모리

![ch09 - Memrory Management - dark-10.jpg](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%201%204%20a69db92073344b57b913eaff6669cb44/ch09_-_Memrory_Management_-_dark-10.jpg)

- **논리 메모리 영역(logical memory address space) == 가상 메모리 영역(virtual memory address space)**
    - 프로세스가 보는 메모리 영역
- **물리 메모리 영역(physical memory address space)**
    - 실제로 사용되는 메모리 영역(RAM)
- **논리 주소(logical address) == 가상 주소(virtual address)**
    - CPU가 프로세스를 실행하며 보는 주소 값
    - 컴파일러가 정해줌
- **물리 주소(physical address)**
    - 실제 메모리에서 사용되는 주소 값
    - OS가 정해줌

### 메모리 관리 장치 (MMU, Memory Management Unit)

- 논리 주소 → 물리 주소 변환
    - CPU가 프로세스를 실행할 때 사용하는 주소 값과 실제 주소 값이 다르므로
- CPU에 위치
- CPU에서 메모리에 접근하기 전에 MMU를 거쳐 논리 주소에 해당하는 물리 주소를 얻음
- 보호해야 하는 메모리 영역에 대한 접근을 제한하여 메모리를 보호하는 역할

# 연속 메모리 할당(contiguous allocation)

멀티 프로세스 환경에서 여러 프로세스를 메모리에 연속적으로 로드하는 방법

프로세스를 통째로 로드하는 것

현재 OS에서 잘 안씀 → External Fragmentation이 낭비라, Compaction이 cost가 높아서

## 고정 분할 방식

- 메모리 영역을 분할한 뒤 각 영역에 프로세스를 할당하는 방식
- 분할된 영역의 크기는 서로 다를 수 있고, 분할된 크기는 고정
- 메모리에 올릴 수 있는 프로세스 수와 각 프로세스 크기가 제한된다는 단점
- 단편화(fragmentation) 문제가 발생할 수 있음
    - 외부 단편화(external fragmentation) : 분할된 크기들이 프로세스의 크기보다 작아서 할당되지 못하는 경우
    - 내부 단편화(internal fragmentation) : 분할된 크기보다 작은 프로세스가 할당되어 메모리 공간이 남는 경우
        
        ![IMG_6124.jpg](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%201%204%20a69db92073344b57b913eaff6669cb44/IMG_6124.jpg)
        

## 가변 분할 방식

할당할 프로세스의 크기에 따라 메모리 공간을 분할하는 방식

## 메모리 할당 알고리즘

가용 메모리 공간에서 프로세스가 로드될 수 있는 메모리 공간을 찾음

### 최초 적합(first-fit)

- 가용 메모리 공간에서 프로세스 크기만큼 비어 있는 메모리 공간을 찾아 차례대로 프로세스를 로드하는 방식
- 제일 먼저 눈에 띄는 자리

### 최적 적합(best-fit)

- 할당하려는 프로세스 크기 이상인 가용 메모리 공간 중에서 가장 작은 공간에 프로세스를 할당하는 방식
- 가용 메모리 공간을 모두 탐색해야 함
- 크기에 가장 가깝고 딱 맞는 자리
- 내부 조각이 많이 생겨서 Compaction Overhead가 많이 생김

### 최악 적합(worst-fit)

- 할당하려는 프로세스 크기보다 큰 가용 메모리 공간 중에서 가장 큰 공간에 프로세스를 할당하는 방식
- 가용 메모리 공간을 모두 탐색해야 함
- 제일 큰 자리
- Compaction Overhead를 줄이기 위함
메모리 압축하는건 OS가 하는거라, 최악 적합을 하면 메모리 압축하는 오버헤드를 줄일 수 있음

## 메모리 압축(memory compaction)

- 외부 단편화 문제 해결 방법
- 프로세스가 사용 중인 메모리 공간을 재배치해서 흩어져 있는 가용 메모리 공간을 하나로 합치는 것
- == 메모리 집약

# 비연속 메모리 할당

프로세스의 메모리 영역을 나눠서 메모리 공간에 저장하는 방법

## 페이징(paging)

- 각각 일정한 크기로, 프로세스의 논리 메모리 영역을 페이지(page), 물리 메모리 영역을 프레임(frame)으로 나눔
- 페이지와 프레임 크기는 동일
- 페이지와 프레임에는 각각 번호를 할당해 프로세스의 페이지와 메모리의 프레임을 매핑함
- 페이지 테이블(page table)
    - 매핑하는데 사용
    - 프로세스의 페이지 정보와 페이지에 매핑하는 프레임의 주소 값 저장
    - 각 프로세스의 PCB에 저장됨
        
        ![IMG_42F4E25FAD06-1.jpeg](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%201%204%20a69db92073344b57b913eaff6669cb44/IMG_42F4E25FAD06-1.jpeg)
        
    - OS가 만듦
- 페이지를 물리 메모리에 연속으로 할당할 필요가 없어 외부 단편화 문제 해결 가능
- 프로세스 크기가 페이지 수로 나누어 떨어지는지 보장하지 않아서, 프로세스의 마지막 페이지가 페이지 크기보다 작을 수 있으므로 내부 단편화 문제 발생 가능
- 페이지 테이블을 저장하기 위한 메모리 공간 별도로 필요

![IMG_6125.jpg](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%201%204%20a69db92073344b57b913eaff6669cb44/IMG_6125.jpg)

### 페이징 기법

- 계층적 페이징(hierarchical paging) : 페이지 테이블을 다시 페이지로 나눠 페이지 테이블 자체를 페이징하는 방식, == 멀티 레벨 페이징(multi-level paging)
- 해시 페이지 테이블(hashed page table) : 해시 테이블의 각 항목에 저장된 연결 리스트에 페이지 번호를 해싱(hashing)한 뒤에 첫 번째 요소와 가상 페이지 번호를 비교하는 방식
    
    ![Untitled](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%201%204%20a69db92073344b57b913eaff6669cb44/Untitled.png)
    
- 역 페이지 테이블(inverted page table) : 프레임을 이용해 페이지를 찾는 방식, 페이지로 프레임을 찾는 기존 방식과 반대

## 세그먼테이션(segmentation)

- 프로세스의 메모리 영역을 논리적 단위인 세그먼트로 분할해 메모리를 할당
    - 논리적 단위 : 파일 내 함수 단위나 프로세스의 스택, 힙과 같은 영역을 의미하기도 함
- 세그먼테이션 테이블(segment table)
    - 세그먼트의 논리 주소를 물리 주소로 매핑
    - 세그먼트 번호를 인덱스로 사용
    - 세그먼트별 시작 주소인 base, 세그먼트 길이인 limit 저장
        
        ![IMG_6126.jpg](%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%201%204%20a69db92073344b57b913eaff6669cb44/IMG_6126.jpg)
        
- 프로세스의 메모리 영역을 논리적 단위로 나눠 저장 → 단위별로 데이터 보호하기 쉽다는 장점
- 세그먼트의 크기가 균등하지 않음 → 프로세스의 할당/해제를 반복하는 과정에서 외부 단편화 문제 발생 가능
- 메모리에 로드된 스택 세그먼트 영역에서 오버플로 발생하면, 다른 프로세스와 메모리 영역 겹칠 수 있음
→ 다른 프로세스의 세그먼트가 스택 오버플로가 발생한 세그먼트를 디스크로 스왑 아웃해야 하는 단점
- vs 페이징 → 페이징은 동일한 크기, 세그먼테이션은 가변