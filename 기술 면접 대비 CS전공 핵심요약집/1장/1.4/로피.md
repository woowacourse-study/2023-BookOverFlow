# 1.4 메모리 관리 전략

## 1.4.1 논리 메모리와 물리 메모리

CPU가 프로세스를 처리할 때 주소 값과 실제 메모리의 주소 값과 다름

**논리 메모리 영역(logical memory address space) or 가상 메모리 영역(virtual memory address space)**

- 프로세스가 보는 메모리 영역

**물리 메모리 영역(physical memory address space)**

- 실제로 사용되는 메모리 영역(RAM)

**논리 주소(logical adderss) or 가상 주소(virtual address)**

- CPU가 프로세스를 실행하며 보는 주소 값
- 프로그램이 실행을 위해 메모리에 적재되면 그 프로세스를 위한 독자적인 주소공간이 생성

**물리 주소(physical address)**

- 실제 메모리에서 사용되는 주소

**메모리 관리 장치(MMU, Memory Management Unit)**

- CPU가 프로세스를 실행할 때 사용하는 주소 값과 실제 주소 값이 다르므로 논리 주소를 물리 주소로 변환(주소 바인딩)해주는 하드웨어 장치
- CPU에 위치
- CPU에서 메모리에 접근하기 위해 거치며 논리 주소에 해당하는 물리 주소 얻음
- 보호해야 하는 메모리 영역에 대한 접근을 제한해 메모리를 보호하는 역할을 함

![IMG_DA34FDE8B2BC-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/20f72d7d-237d-491c-b56d-d6b1b19d1fe5)

- MMU 기법
    - CPU가 특정 프로세스의 논리적 주소를 참조하려고 할 때 그 주소값에 기준 레지스터의 값을 더해 물리적 주소값 얻어냄
        - 기준 레지스터
            - 재배치 레지스터
            - 그 프로세스의 물리적 메모리 시작 주소 가지고 있음

## 1.4.2 연속 메모리 할당

멀티 프로세스 환경에서 여러 프로세스를 메모리에 연속적으로 로드하는 방법

### 고정 분할 방식

**메모리 영역을 분할한 뒤 각 영역에 프로세스 할당**하는 방식

- 분할된 영역 크기는 서로 다를 수 있으며, 분할된 크기는 고정됨
- 하나의 분할에는 하나의 프로그램만 적재
- 메모리에 올릴 수 있는 프로세스의 수와 각 프로세스의 크기가 제한됨
- 단편화(fragmentation) 문제 발생
    - 외부 조각, 내부 조각
        - 외부조각 → 프로그램의 크기보다 분할의 크기가 작은 경우 해당 분할이 비어 있는데도 불구하고 프로그램을 적재하지 못하기 때문에 발생하는 메모리 공간
        - 내부조각 → 프로그램의 크기보다 분할의 크기가 큰 경우 해당 분할에 프로그램을 적재하고 남은 메모리 공간

  ![IMG_BDA768636486-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/3616c5e1-f31a-4156-b5ba-bdcfafcffcaa)


### 가변 분할 방식

**할당할 프로세스의 크기에 따라 메모리 공간을 분할**하는 방식

- 분할의 크기를 프로그램의 크기보다 일부러 크게 할당하지 않기 때문에 내부조각 발생하지 않음
- 이미 메모리에 존재하는 프로그램이 종료될 경우 중간에 빈 공간이 발생하게 되며, 이 공간이 새롭게 시작되는 프로그램의 크기보다 작을 경우 외부 조각 발생 가능
- 메모리 할당 알고리즘을 이용해 가용 메모리 공간에서 프로세스가 로드될 수 있는 메모리 공간 찾음
    - 최초 적합(fisrt-fit)
        - 가용 메모리 공간에서 프로세스의 크기만큼 비어 있는 메모리 공간을 찾아 차례대로 프로세스를 로드하는 방식

          ![IMG_63EF015F907F-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/1a7dd255-0af1-4ba7-9159-9ad7f686afcf)

    - 최적 적합(best-fit)
        - 할당하려는 프로세스 크기 이상인 가용 메모리 공간 중에서 가장 작은 공간에 프로세스 할당하는 방식
        - 가용 메모리 공간을 모두 탐색해야함 → 리스트가 크기 순으로 정렬되지 않는 경우
        - 메모리 압축 빈도수가 높아짐 - 내부 조각이 많이 생겨서

          ![IMG_B3C2C7EDEC00-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/6d799131-46fc-4ab9-942e-a50e88a0a78e)

    - 최악 적합(worst-fit)
        - 할당하려는 프로세스 크기보다 큰 가용 메모리 공간 중에서 가장 큰 공간에 프로세스를 할당하는 방식
        - 가용 메모리 공간을 모두 탐색해야함 → 내림차순으로 정렬되지 않은 경우(크기가)

          ![IMG_6C26B415C13E-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/98cfcabf-88d4-4ba5-9aae-9f561b7912ee)


        —> 메모리 compaction


**메모리 압축(memory compaction)**

- 가변 분할 방식에서 발생하는 외부 단편화 문제 해결 방법
- 프로세스가 사용 중인 메모리 공간을 재배치해서 흩어져 있는 가용 메모리 공간을 하나로 합치는 것
- 메모리 집약

  ![IMG_F952219DD912-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/2a5824a5-1aa7-4b60-9c37-3148e95b1375)


## 1.4.3 비연속 메모리 할당

### 페이징(paging)

- **프로세스의 논리 메모리 영역과 물리 메모리 영역을 각각 일정한 크기의 페이지(page)와 프레임(frame)으로 나눔**
- 페이지와 프레임의 크기 동일
- 페이지와 프레임에는 각각 번호를 할당해 프로세스의 페이지와 메모리의 프레임을 매핑
- **페이지 테이블(page table)** 사용 - OS가 만들고 관리
    - 페이지와 프레임을 매핑
    - 프로세스의 페이지 정보와 페이지에 매핑하는 프레임의 주소 값 저장
    - 각 프로세스의 PCB에 저장
- 페이지를 물리 메모리에 연속적으로 할당할 필요 없음 → 외부 단편화 문제 해결
- 프로세스의 크기가 페이지 수로 나누어 떨어지는지는 보장하지 않음
    - 프로세스의 마지막 페이지가 페이지 크기보다 작을 수 있음 → 내부 단편화 문제 발생
- 페이지 테이블을 저장하기 위한 메모리 공간이 추가로 필요

![IMG_5D886CDF3305-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/f83f1e1a-f0ad-4a11-8341-674ffa0f35a3)

### 페이징 기법

- 계층적 페이징(hierarchical paging)
    - 페이지 테이블을 다시 페이지로 나눠 페이지 테이블 자체를 페이징하는 방식
    - 멀티 레벨 페이징
- 해시 페이지 테이블(hashed page table)
    - 해시 테이블의 각 항목에 저장된 연결 리스트에 페이지 번호를 해싱한 뒤에 첫 번째 요소와 가상 페이지 번호를 비교하는 방식
- 역 페이지 테이블(inverted page table)
    - 프레임을 이용해 페이지를 찾는 방식
    - 페이지로 프레임을 찾는 기존 방식과 반대

### 세그먼테이션(segmentation)

- **프로세스의 메모리 영역을 논리적 단위인 세그먼트로 분할해 메모리를 할당**
    - 논리적 단위 - 파일 내 함수 단위나 프로세스의 스택, 힙과 같은 영역을 의미
- **세그먼테이션 테이블(segmentation table)**을 사용해 세그먼트의 논리 주소를 물리 주소로 매핑
    - 세그먼트 번호를 인덱스로 사용
    - 세그먼트별 시작 주소인 base와 세그먼트 길이인 limit 저장
- 프로세스의 메모리 영역을 논리적 단위로 나눠 저장하므로 단위별로 데이터를 보호하기 쉬움
- 세그먼트의 크기가 균등하지 않아서 프로세스의 할당/해제를 반복하는 과정 → 외부 단편화 문제 발생
- 메모리에 로드된 스택 세그먼트 영역에서 오버플로가 발생하면 다른 프로세스와 메모리 영역이 겹칠 수 있음
- 다른 프로세스의 세그먼트나 스택 오버플로가 발생한 세그먼트를 디스크로 스왑 아웃해야하는 단점
