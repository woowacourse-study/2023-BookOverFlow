## 1.4 메모리 관리 전략

### 1.4.1 논리 메모리와 물리 메모리
- CPU가 프로세스를 처리할 때 보는 주소 값과 실제 메모리 주소 값은 다르다.
- 프로세스가 보는 메모리 영역을 논리 메모리 영역 또는 가상 메모리 영역이라고 하고, 실제로 사용되는 메모리 영역을 물리 메모리 영역이라고 한다.
- CPU가 프로세스를 실행하며 보는 주소 값을 논리 주소 또는 가상 주소라고 하며, 실제 메모리에서 사용되는 주소는 물리 주소라고 한다.

<br>

- **MMU(Memory Management Unit)가 논리 주소를 물리 주소로 변환해주는 역할을 한다.**
- MMU는 CPU에 위치하며 CPU에서 메모리에 접근하기 전 MMU를 거쳐 논리 주소에 해당하는 물리 주소를 얻는다. 
- MMU는 보호해야 하는 메모리 영역에 대한 접근을 제한해 메모리를 보호한다.
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/91262a99-2d84-4a2e-9142-c44222bdc7d1" width=500></center>

<br><br>

### 1.4.2 연속 메모리 할당
- 멀티 프로세스 환경에서 여러 프로세스를 메모리에 연속적으로 로드하는 방법이다.

<br>

**고정 분할 방식**
- 메모리 영역을 분할한 뒤 각 영역에 프로세스를 할당하는 방식이다.
- 분할된 영역의 크기는 서로 다를 수 있으며, 분할된 크기는 고정된다.
- 메모리에 올릴 수 있는 프로세스 수와 각 프로세스 크기가 제한된다는 단점이 있다.
- 단편화 문제가 발생할 수 있다.

<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/ce91b315-5ccd-4a9e-b7b1-b4acbde6f4ef" width=500></center>

- (b)에서 8MB의 메모리 공간과 2MB의 공간을 합치면 프로세스 7을 할당할 수 있지만 고정 분할이기에 할당할 수 없다. 이를 **외부 단편화**(external fragmentation)라고 한다.
- 프로세스 3, 4처럼 분할된 크기보다 작은 프로세스가 할당되어 메모리 공간이 남는 경우를 **내부 단편화**(internal fragmentation)라고 한다.

<br>

> 비균등 고정분할 방식
- 균등 고정분할 방식보다 메모리 활용도를 높였다.
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/0086d29f-5b94-4f81-a9e6-6d6dd285e21a" width=500></center>

<br>

> 파티션에 프로세스를 할당하는 방법
- 각 파티션에 큐를 할당하는 방법 : 가장 fit한 위치의 큐에서 대기하도록 함으로써 내부 단편화를 최소화할 수 있다.
- 하나의 큐를 사용하는 방법 : 가용한 파티션 중 가장 작은 것에 할당함으로써 유연성을 증대시킬 수 있다.
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/f9921a68-0706-4f67-9a01-418e1d5bfb14" width=500></center>


<br><br>

**가변 분할 방식**
- 할당할 프로세스의 크기에 따라 메모리 공간을 분할하는 방식이다.
- 메모리 할당 알고리즘을 이용해 프로세스가 로드될 수 있는 메모리 공간을 찾는다.
- 메모리 할당 알고리즘은 최초 적합, 최적 적합, 최악 적합이 있다.
- 최초 적합(first-fit)
    - 가용 메모리 공간에서 프로세스 크기만큼 비어 있는 메모리 공간을 찾아 차례대로 프로세스를 로드하는 방식이다.
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/8badad42-7eb1-4f6d-b6ad-d01d64c209d2" width=500></center>

- 최적 적합(best-fit)
    - 할당하려는 프로세스 크기 이상인 가용 메모리 공간 중 가장 작은 공간에 프로세스를 할당하는 방식이다.
    - 가용 메모리 공간을 모두 탐색해야 한다.
    - Compaction Overhead를 증가시킨다.
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/445665a1-72e9-4879-b811-b1df736b721b" width=500></center>

- 최악 적합(worst-fit)
    - 할당하려는 프로세스 크기보다 큰 가용 메모리 공간 중 가장 큰 메모리 공간에 프로세스를 할당하는 방식이다.
    - 가용 메모리 공간을 모두 탐색해야 한다.
    - Compaction Overhead의 주기를 늘리는 효과를 가져온다.
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/261af9c5-9388-4c1d-bbce-1b8fb1c3f096" width=500></center>

<br>

> 메모리 압축(Memory Compaction)
- 외부 단편화를 해결하는 방법이다.
- CPU가 아무런 일도 하지 못하는 상태가 된다. (운영체제가 메모리 압축을 진행하기 때문에)
- 프로세스가 사용중인 메모리 공간을 재배치하여 흩어져 있는 가용 메모리 공간을 하나로 합치는 것이다.
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/cd80fda5-3da8-412f-b8b9-ff9c69e121c9" width=500></center>

<br><br>

### 1.4.3 비연속 메모리 할당
- 프로세스의 메모리 영역을 나눠 메모리 공간에 저장하는 방법으로, 페이징과 세그멘테이션 방식이 있다.

<br>

**페이징**
- 프로세스의 논리 메모리 영역과 물리 메모리 영역을 각각 일정한 크기의 페이지와 프레임으로 나눈다.
- 페이지와 프레임의 크기는 동일하다.
- 페이지와 프레임에는 각각 번호를 할당해 프로세스의 페이지와 메모리의 프레임을 매핑한다. (페이지 테이블)
- 페이지 테이블은 프로세스의 페이지 정보와 페이지에 매핑하는 프레임의 주소 값을 저장한다.
- 페이지 테이블은 OS에 의해 관리되며 각 프로세스의 PCB에 저장된다.
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/febc4f75-6d3f-429a-a084-cca57a9857c6" width=500></center>

<br>

- 페이지를 물리 메모리에 연속으로 할당할 필요가 없어 **외부 단편화 문제가 발생하지 않는다.**
- 프로세스 크기가 페이지 수로 나누어 떨어지는지는 보장하지 않는다.
- 마지막 페이지가 페이지 크기보다 작을 수 있기 때문에 내부 단편화 문제가 발생할 수 있다.
- 내부 단편화의 평균적 크기는 페이징 사이즈의 1/2 정도다.
- 페이지 테이블을 저장하기 위한 메모리 공간이 추가로 필요하다.

<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/56e7c846-ba9e-4bf9-95c2-1cec33ad3095" width=600></center>

<br>

> 페이징 기법
- 계층적 페이징 : 페이지 테이블을 다시 페이지로 나눠 페이지 테이블 자체를 페이징하는 방식으로, 멀티 레벨 페이징이라고도 한다.
- 해시 페이지 테이블 : 해시 테이블의 각 항목에 저장된 연결 리스트에 페이지 번호를 해싱한 뒤에 첫 번째 요소와 가상 페이지 번호를 비교하는 방식이다.
- 역 페이지 테이블 : 프레임을 이용해 페이지를 찾는 방식이다. 페이지로 프레임을 찾는 기존 방식과 반대다.

<br><br>

**세그멘테이션**
- 프로세스의 메모리 영역을 논리적 단위인 세그멘트로 분할해 메모리를 할당한다.
- 논리적 단위는 함수 단위나 프로세스의 스택, 힙과 같은 영역을 의미하기도 한다.
- 세그멘테이션 테이블을 사용해 세그멘트의 논리 주소를 물리 주소로 매핑한다.
- 세그멘트 테이블은 세그멘트 번호를 인덱스로 사용하여 세그멘트별 시작 주소인 base와 세그멘트의 길이인 limit을 저장한다.
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/841dd880-bdb8-41d1-9626-58f2f583d631" width=500></center>

<br>

- 내부 단편화가 발생하지 않는다.
- 프로세스의 메모리 영역을 논리적 단위로 나눠 저장하므로 단위별로 데이터를 보호하기 쉽다.
- 세그멘트의 크기가 균등하지 않아 프로세스의 할당/해제를 반복하는 과정에서 외부 단편화 문제가 발생할 수 있다.
- 메모리에 로드된 스택 세그멘트 영역에서 오버플로우가 발생하면 다른 프로세스와 메모리 영역이 겹칠 수 있다. 
- 이 경우 스택 오버플로우가 발생한 세그멘트를 디스크로 스왑 아웃해야 하는 단점이 있다.

<br><br>

### 궁금한점?
1. 페이징과 세그멘테이션의 차이가 무엇인가?
- 나눠진 조각이 고정 크기면 페이징, 가변 크기면 세그멘테이션이다.

2. 페이지 테이블은 PCB에 저장이 되지만 누가 만드나요?
- OS가 만들고 관리합니다.