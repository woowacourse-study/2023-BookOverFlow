# 1.4(메모리 관리 전략)

## 1.4.1 논리 메모리와 물리 메모리(⭐)

**논리 메모리 영역(logical memory address space), 가상 메모리 영역(virtual memory address space)**

- 프로세스가 보는 메모리 영역이다.

**물리 메모리 영역(physical memory address space)**

- 실제로 사용되는 메모리 영역이다.

**논리 주소(logical address), 가상주소(virtual address)**

- CPU가 프로세스를 실행하며 보는 주소 값

**물리 주소(physical address)**

- 실제 메모리에서 사용되는 주소

**메모리 관리 장치(MMU, Memory Management Unit)**

- CPU가 프로세스를 실행할 때 사용하는 주소 값과 실제 주소 값이 다르므로 논리 주소를 물리 주소로 변환해줘야 하는데, 이러한 동작을 하는 하드웨어 장치를 **메모리 관리 장치(MMU, Memory Management Unit)라고 한다.**
- MMU는 CPU에 위치하며 변환 뿐만 아니라 보호해야 하는 메모리 영역에 대한 접근을 제한해 메모리를 보호하는 역할도 한다.

![Untitled](1%204(%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%85%E1%85%A3%E1%86%A8)%20095ab673f1b34705a248771e1e6507b9/Untitled.png)

## 1.4.2 연속 메모리 할당(contiguous allocation)(⭐)

- **연속 메모리 할당은 멀티 프로세스 환경에서 여러 프로세스를 메모리에 연속적으로 로드하는 방법이다.**

### 고정 분할 방식

- **고정 분할은 메모리 영역을 분할한 뒤 각 영역에 프로세스를 할당하는 방식이다.**
- 분할된 크기는 고정된다.
- 메모리에 올릴 수 있는 프로세스 수와 각 프로세스 크기가 제한된다는 단점이 있다.
- **내부 단편화(fragmentation, 내부조각)**를 야기한다.
    - 

### 가변 분할 방식

- **가변 분할은 할당할 프로세스의 크기에 따라 메모리 공간을 분할하는 방식이다.**
- 메모리 할당 알고리즘을 이용해 가용 메모리 공간에서 프로세스가 로드될 수 있는 메모리 공간을 찾는다.
- **외부 단편화(외부조각)**를 야기한다.
    - 외부 단편화란 가변 분할 방식으로 인해 프로세스를 할당할 가용 메모리 공간은 충분하지만, 합쳐질 수 없는 메모리 공간들을 의미한다.
    - 외부 단편화 문제를 해결하는 방법으로 **메모리 압축(memory compaction)**이 있다.
    - 메모리 압축은 프로세스가 사용 중인 메모리 공간을 재배치해서 흩어져 있는 가용 메모리 공간을 하나로 합치는 것이다.

![Untitled](1%204(%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%85%E1%85%A3%E1%86%A8)%20095ab673f1b34705a248771e1e6507b9/Untitled%201.png)

1. 최초 적합(first-fit)
- 가용 메모리 공간에서 **프로세스 크기만큼 비어 있는 메모리 공간**을 찾아 차례대로 프로세스를 로드하는 방식이다.

![Untitled](1%204(%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%85%E1%85%A3%E1%86%A8)%20095ab673f1b34705a248771e1e6507b9/Untitled%202.png)

1. 최적 적합(best-fit)
- 할당하려는 프로세스 크기 이상인 가용 메모리 공간 중에서 **가장 작은 공간**에 프로세스를 할당하는 방식이다.
- 이 방식은 가용 메모리 공간을 모두 탐색해야 한다.
- 내부 조각 많이 생김
    - 메모리 압축 빈도수가 높아진다.

![Untitled](1%204(%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%85%E1%85%A3%E1%86%A8)%20095ab673f1b34705a248771e1e6507b9/Untitled%203.png)

1. 최악 적합(worst-fit)
- 할당하려는 프로세스 크기보다 큰 가용 메모리 공간 중에서 가장 큰 공간에 프로세스를 할당하는 방식이다.
- 최적 적합과 마찬가지로 가용 메모리 공간을 모두 탐색해야 한다.
- 내부 조각 적을 확률 높음
    - 메모리 압축의 빈도수를 줄인다

![Untitled](1%204(%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%85%E1%85%A3%E1%86%A8)%20095ab673f1b34705a248771e1e6507b9/Untitled%204.png)

## 1.4.3 비연속 메모리 할당(discontiguous allocation)(⭐⭐⭐)

- **비연속 메모리 할당은 프로세스의 메모리 영역을 나눠서 메모리 공간에 저장하는 방법으로, 페이징과 세그먼테이션이라는 2가지 방식이 있다.**

### 페이징(paging)

- **페이징은 프로세스의 논리 메모리 영역과 물리 메모리 영역을 각각 일정한 크기의 페이지(page)와 프레임(frame)으로 나눈다.**
    - 이때 페이지와 프레임 크기는 동일하다.
    - 페이지와 프레임에는 각각 번호를 할당해 프로세스의 페이지와 메모리의 프레임을 매핑한다.
- 페이지와 프레임을 매핑하는 데는 **페이지 테이블(page table)**을 사용한다.
    - 페이지 테이블은 프로세스의 페이지 정보와 페이지에 매핑하는 프레임의 주소 값을 저장한다.
    - 페이지 테이블은 각 프로세스의 PCB에 저장된다.
    
    ![Untitled](1%204(%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%85%E1%85%A3%E1%86%A8)%20095ab673f1b34705a248771e1e6507b9/Untitled%205.png)
    
- 페이지 테이블은 운영체제의 자료 구조 중 하나로, 논리 메모리와 물리 메모리에 대한 매핑 정보를 갖고 페이지 테이블을 만든다.
    - 페이지 테이블은 항상 메모리에 로드되어 있으며, 페이지 테이블의 크기 또한 중요하다.
- 페이지 기법을 사용하면 외부 파편화 문제를 해결할 수 있다.
- 프로세스 크기가 페이지 수로 나누어 떨어지는지는 보장하지 않으며 프로세스의 마지막 페이지가 페이지 크기보다 작을 수 있으므로 내부 단편화 문제를 야기한다.
- 페이지 테이블을 저장하기 위한 메모리 공간이 추가로 필요하다.

**계층적 페이징(hierarchical paging)**

- 페이지 테이블을 다시 페이지로 나눠 페이지 테이블 자체를 페이징하는 방식으로, 멀티 레벨 페이징(multi-level paging)이라고도 한다.

**해시 페이지 테이블(hashed page table)**

- 해시 테이블의 각 항목에 저장된 연결 리스트에 페이지 번호를 해싱(hashing)한 뒤에 첫 번째 요소와 가상 페이지 번호를 비교하는 방식이다.

![Untitled](1%204(%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%85%E1%85%A3%E1%86%A8)%20095ab673f1b34705a248771e1e6507b9/Untitled%206.png)

- [https://charles098.tistory.com/108](https://charles098.tistory.com/108)

**역 페이지 테이블(inverted page table)**

- 프레임을 이용해 페이지를 찾는 방식이다.
    - 페이지로 프레임을 찾는 기존 방식과 반대다.

### 세그먼테이션(segmentation)

- **프로세스의 메모리 영역을 논리적 단위인 ‘세그먼트’로 분할해 메모리를 할당한다.**
    - 여기서 논리적 단위는 파일 내 함수 단위나 프로세스의 스택, 힙과 같은 영역을 의미하기도 한다.
- 이 기법은 **세그먼테이션 테이블(segmentation table)**을 사용해 세그먼트의 논리 주소를 물리 주소로 매핑한다.
    - 세그먼트 테이블은 세그먼트 번호를 인덱스로 사용하며, 세그먼트별 시작 주소인 base와 세그먼트 길이인 limit를 저장한다.
    
    ![Untitled](1%204(%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%85%E1%85%A3%E1%86%A8)%20095ab673f1b34705a248771e1e6507b9/Untitled%207.png)
    

- 프로세스의 메모리 영역을 논리적 단위로 나눠 저장하므로 단위별로 데이터를 보호하기 쉽다는 장점이 있다.
- 세그먼트의 크기가 균등하지 않아서 프로세스의 할당/해제를 반복하는 과정에서 외부 단편화 문제를 야기한다.
- 메모리에 로드된 스택 세그먼트 영역에서 오버플로가 발생하면 다른 프로세스와 메모리 영역이 겹칠 수 있다.
    - 다른 프로세스의 세그먼트나 문제의 세그먼트를 스왑 아웃해야 하는 단점이 있다.