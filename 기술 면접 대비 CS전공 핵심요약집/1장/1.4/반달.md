# 1.4 메모리 관리 전략

## 1.4.1 논리 메모리와 물리 메모리
- **논리 메모리 영역**(logical memory address space) 또는 **가상 메모리 영역**(virtual memory address space)
    - 프로세스가 보는 메모리 영역
- **물리 메모리 영역**(physical memory address space)
    - 실제로 사용되는 메모리 영역(RAM)
- **논리 주소**(logical address) 또는 **가상 주소**(virtual address)
    - CPU가 프로세스를 실행하며 보는 주소 값
- **물리 주소**(logical address)
    - 실제 메모리에서 사용되는 주소
- **메모리 관리 장치**(MMU, Memory Management Unit)
    - MMU는 CPU에 위치하며, CPU에서 메모리에 접근하기 전에 MMU를 거쳐 논리 주소에 해당하는 물리 주소를 얻는다.
    - MMU는 보호해야 하는 메모리 영역에 대한 접근을 제한해 메모리를 보호하는 역할을 한다.

## 1.4.2 연속 메모리 할당
> 연속 메모리 할당은 멀티 프로세스 환경에서 여러 프로세스를 메모리에 연속적으로 로드하는 방법이다.
> 고정 분할 방식과 가변 분할 방식이 있다.

### 고정 분할 방식
> 메모리 영역을 분할한 뒤 각 영역에 프로세스를 할당하는 방식
> 이때 분할된 크기는 고정된다. 그런데 이 방식은 메모리에 올릴 수 있는 프로세스 수와 각 프로세스 크기가 제한된다는 단점이 있고, 단편화(fragmentation 조각) 문제가 발생할 수 있다.

![image](https://github.com/woowacourse-study/2023-cs-study/assets/22425650/d85fa90a-f8a1-4df7-b564-d4ff6ca049be)

- (b)에서 8MB의 공간과 2MB의 메모리 공간을 합치면 프로세스 7에 공간을 할당 할 수 있지만, 고정 분할 때문에 그러지 못한다. -> 이런 경우를 **외부 단편화(외부 조각, external fragmentation)** 이라고 한다.
- 프로세스 3과 프로세스 4처럼 분할된 크기보다 작은 프로세스가 할당되어 메모리 공간이 남는 경우를 **내부 단편화(내부조각, internal fragmentation)** 이라고 한다.

> 헷갈릴 수 있는데, 간단하게 생각하여 미리 분할해둔 크기보다 커서 못들어가는 거면 외부 조각,
> 들어가긴 하는데 공간이 남아 낭비되는 것을 내부 조각이라고 한다.

>[!question]
>외부 단편화 문제를 해결하는 방법이 있나요?

>[!answer]
>메모리 압축(memory compaction)이 있다.
>메모리 압축은 프로세스가 사용 중인 메모리 공간을 재배치해서 흩어져 있는 가용 메모리 공간을 하나로 합치는 것으로, 메모리 집약이라고도 한다.

### 가변 분할 방식
> 할당할 프로세스의 크기에 따라 메모리 공간을 분할하는 방식이다.
> 이 방식은 메모리 할당 알고리즘을 이용해 가용 메모리 공간에서 프로세스가 로드될 수 있는 메모리 공간을 찾는다.
> 메모리 할당 알고리즘으로는 최초 적합, 최적 적합, 최악 적합 등이 있다.

#### 최초 적합(first-fit)
> 가용 메모리 공간에서 프로세스 크기만큼 비어 있는 메모리 공간을 찾아 차례대로 프로세스를 로드하는 방식

![image](https://github.com/woowacourse-study/2023-cs-study/assets/22425650/3d9696bb-6c34-4620-9c3e-62ef17dff5c4)

1. 20MB의 프로세스 1이 56MB의 가용 메모리 공간에 할당된다.
2. 18MB의 프로세스 2가 36MB의 가용 메모리 공간에 할당된다.
3. 12MB의 프로세스 3이 18MB의 가용 메모리 공간에 할당된다.
4. 메모리 영역에서 프로세스 2의 할당이 해제 된다.
5. 6MB의 프로세스 4를 할당할 수 있는 가용 메모리 공간을 찾으면 가장 먼저 18MB의 메모리 공간이 탐색된다.
    - 더 이상 탐색하지 않고 프로세스 4를 해당 메모리 공간에 할당한다.
    - 심지어 프로세스 3 밑에 알맞는 크기의 메모리 공간이 있는데도 불구하고 말이다.

#### 최초 적합(best-fit)
> 할당하려는 프로세스 크기 이상인 가용 메모리 공간 중에서 가장 작은 공간에 프로세스를 할당하는 방식이다.
> 이 방식은 가용 메모리 공간을 모두 탐색해야 한다.

![image](https://github.com/woowacourse-study/2023-cs-study/assets/22425650/6c9b3e5c-f53e-4cc1-b891-56ede345896a)

1. 20MB의 프로세스 1이 56MB의 가용 메모리 공간에 할당된다.
2. 18MB의 프로세스 2가 36MB의 가용 메모리 공간에 할당된다.
3. 12MB의 프로세스 3이 18MB의 가용 메모리 공간에 할당된다.
4. 메모리 영역에서 프로세스 2의 할당이 해제 된다.
5. 6MB의 프로세스 4를 할당할 수 있는 가용 메모리 공간을 찾으면 18MB와 6MB의 공간이 탐색된다.
    - 이 중에서 가장 작은 6MB의 메모리 공간에 프로세스 4가 할당된다.

#### 최악 적합(worst-fit)
> 할당하려는 프로세스 크기보다 큰 가용 메모리 공간 중에서 가장 큰 공간에 프로세스를 할당하는 방식이다.
> 최적 적합 방식과 마찬가지로 가용 메모리 공간을 모두 탐색해야 한다.

![image](https://github.com/woowacourse-study/2023-cs-study/assets/22425650/09d74465-f579-4021-bdd0-385f1e4bcf2c)

1. 20MB의 프로세스 1이 56MB의 가용 메모리 공간에 할당된다.
2. 18MB의 프로세스 2가 36MB의 가용 메모리 공간에 할당된다.
3. 12MB의 프로세스 3이 18MB의 가용 메모리 공간에 할당된다.
4. 메모리 영역에서 프로세스 2의 할당이 해제 된다.
5. 6MB의 프로세스 4를 할당할 수 있는 가용 메모리 공간을 찾으면 18MB와 6MB의 공간이 탐색된다. 이 중에서 가장 큰 18MB의 메모리 공간에 프로세스 4가 할당된다.

## 1.4.3 비연속 메모리 할당
> 비연속 메모리 할당은 프로세스의 메모리 영역을 나눠서 메모리 공간에 저장하는 방법으로, **페이징**과 **세그먼테이션**이라는 2가지 방식이 있다.

### 페이징

![image](https://github.com/woowacourse-study/2023-cs-study/assets/22425650/a7759a0a-e4fb-4b19-a380-ea47a58001c7)

- 프로세스의 논리 메모리 영역 -> 일정 크기의 페이지(page)
- 프로세스의 물리 메모리 영역 -> 일정한 크기의 프레임(frame)
- 이때 페이지와 프레임 크기는 동일하다. 페이지와 프레임에는 각각 번호를 할당해 프로세스의 페이지와 메모리의 프레임을 매핑한다.
- 페이지와 프레임을 매핑하는 데는 페이지 테이블(page table)을 사용한다. 페이지 테이블은 프로세스의 페이지 정보와 페이지에 매핑하는 프레임의 주소 값을 저장한다.
- 페이지 테이블은 각 프로세스의 PCB에 저장된다.
- 페이징 기법을 사용하면 페이지를 물리 메모리에 연속으로 할당할 필요가 없ㅅ어서 외부 단편화 문제를 해결할 수 있다.
- 하지만 프로세스 크기가 페이지 수로 나누어 떨어지는지는 보장하지 않는다.
- 따라서 프로세스의 마지막 페이지가 페이지 크기보다 작을 수 있으므로 내부 단편화 문제가 발생할 숭 ㅣㅆ다.
- 또한, 페이지 테이블을 저장하기 위한 메모리 공간이 추가로 필요하다.

### 페이징 기법 3가지
- 계층적 페이징(hierarchical paging)
    - 페이지 테이블을 다시 페이지로 나눠 페이지 테이블 자체를 페이징하는 방식으로, 멀티 레벨 페이징(multi-level paging)이라고 한다.
- 해시 페이지 테이블(hashed page table)
    - 해시 테이블의 각 항목에 저장된 연결 리스트에 페이지 번호를 해싱(hasing)한 뒤에 첫 번째 요소와 가상 페이지 번호를 비교하는 방식이다.
- 역 페이지 테이블(inverted page table)
    - 프레임을 이용해 페이지를 찾는 방식이다.
    - 페이지로 프레임을 찾는 기존 방식과 반대다.

### 세그먼테이션

![image](https://github.com/woowacourse-study/2023-cs-study/assets/22425650/7cb95ef6-8316-4fac-b8b0-7bdd66074801)

> 세그먼테이션(segmentation) 기법은 프로세스의 메모리 영역을 논리적 단위인 세그먼트로 분할해 메모리를 할당한다.
> 여기서 논리적 단위는 파일 내 함수 단위나 프로세스의 스택, 힙과 같은영역을 의미하기도 한다.
> 이 기법은 세그먼테이션 테이블(segment table)을 사용해 세그먼트의 논리 주소를 물리 주소로 매핑한다.
> 세그먼트 테이블은 세그먼트 번호를 인덱스로 사용하며, 세그먼트별 시작 주소인 base와 세그먼트 길이인 limit를 저장한다.
### 세그먼테이션의 장단점

#### 장점
- 프로세스의 메모리 영역을 논리적 단위로 나눠 저장하므로 단위별로 데이터를 보호하기 쉽다.

#### 단점
- 세그먼트의 크기가 균등하지 않아서 프로세스의 할당/해제를 반복하는 과정에서 외부 단편화(외부 조각) 문제가 발생할 수 있다.
- 메모리에 로드된 스택 세그먼트 영역에서 오버플로가 발생하면 다른 프로세스와 메모리 영역이 겹칠 수 있다. 그러면 다른 프로세스의 세그먼트나 스택 오버플로가 발생한 세그먼트를 디스크로 스왑 아웃해야한다.
