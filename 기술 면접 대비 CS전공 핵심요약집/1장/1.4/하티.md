# 1.4 메모리 관리 전략

## 논리 메모리와 물리 메모리

**논리 (가상) 메모리 영역** (logical memory address space) / **논리 (가상) 주소** (logical (virtual) address)

- 프로세스가 보는 메모리 영역
- CPU가 프로세스를 실행하며 보는 주소 값

**물리 메모리 영역** (physical memory address space) / **물리 주소** (physical address)

- 실제로 사용되는 메모리 영역 (RAM)
- 실제 메모리에서 사용되는 주소

### 메모리 관리 장치 (MMU, Memory Management Unit)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/d4809f18-a915-4e30-8b11-8f015eacff00/0f91e04c-826e-4856-a4af-587974621b97/Untitled.png)

- CPU가 프로세스를 실행할 때, 논리 주소 ⇒ 물리 주소 변환이 필요함 - 이를 도와주는 장치
- 메모리 영역에 대한 접근을 제한해 메모리를 보호
- 이것도 관심사 분리라고 볼 수 있지 않을까

## 연속 메모리 할당 (contiguous allocation)

- 여러 프로세스를 메모리에 연속적으로 로드하는 방법

### 고정 분할 방식

- 메모리 영역을 분할한 뒤 각 영역에 프로세스를 할당하는 방식
    - 분할된 영역의 크기는 서로 다를 수 있으나, 분할된 크기는 고정됨
- 메모리에 올릴 수 있는 프로세스의 수와 각 프로세스의 크기가 제한되는 단점
- `단편화 (fragementation)` 문제 발생 가능
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/d4809f18-a915-4e30-8b11-8f015eacff00/554eb27e-2d59-4390-9209-bddc962d9cb3/Untitled.png)
    
    - **외부 단편화 (external fragmentation)**
        
        : 남는 메모리 공간을 합치면 할당이 가능하지만, 고정 분할이어서 할당하지 못하는 경우
        
    - **내부 단편화 (internal fragmentation)**
        
        : 분할된 크기보다 작은 프로세스가 할당되어 메모리 공간이 남는 경우
        

### 가변 분할 방식

- 할당할 프로세스의 크기에 따라 메모리 공간을 분할하는 방식

**최초 적합 (first-fit)**

- 프로세스 크기만큼 비어있는 메모리 공간을 찾아 차례대로 프로세스 로드
- 남는 공간 찾음 → 바로 그곳에 할당

**최적 적합 (best-fit)**

- 할당하려는 프로세스 크기 이상인 가용 메모리 공간 중 가장 작은 공간에 프로세스 할당
- 남는 가용 메모리 공간 모두 탐색 → 가장 작은 공간에 할당

**최악 적합 (worst-fit)**

- 할당하려는 프로세스 크기 이상인 가용 메모리 공간 중 가장 큰 공간에 프로세스 할당
- 남는 가용 메모리 공간 모두 탐색 → 가장 큰 공간에 할당
- 메모리 압축 빈도수를 줄임으로써 오버헤드가 줄어든다

**메모리 압축 (memory ncompaction)**

- 외부 단편화 문제를 해결하는 방법
- 프로세스가 사용 중인 메모리 공간을 재배치 → 흩어져 있는 가용 메모리 공간을 하나로 합치는 것

## 비연속 메모리 할당

- 프로세스의 메모리 영역을 나눠서 메모리 공간에 저장하는 방법

### 페이징 (Paging)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/d4809f18-a915-4e30-8b11-8f015eacff00/975fff59-a74c-4ea1-8e7f-b6ffa9589bb1/Untitled.png)

- 프로세스의 논리 메모리 영역과 물리 메모리 영역을 각각 **일정한 크기**의 `page`와 `frame`으로 나눔
    - 페이지 크기 == 프레임 크기
- 각 페이지, 프레임에 번호를 할당하고, 페이지—프레임 매핑 → `Page Table` 사용 (PCB에 저장됨)
- 외부 단편화 문제 해결
- 내부 단편화 문제는 해결 X, 메모리 공간이 추가로 필요

**페이징 기법**

- 계층적 페이징 (hierarchical paging)
    - 페이지 테이블을 다시 페이지로 나눠 페이지 테이블 자체를 페이징하는 방식
- 해시 페이지 테이블 (hashed page table)
    - 해시 테이블의 각 항목에 저장된 연결 리스트에 페이지 번호를 해싱한 뒤, 첫 번째 요소와 가상 페이지 번호를 비교하는 방식
    - 페이지 넘버 → 해시값, 해시 테이블 - 연결리스트 (해시가 충돌날 경우 연결 리스트에 추가)
- 역 페이지 테이블 (inverted page table)
    - 프레임을 이용해 페이지를 찾는 방식

### 세그먼테이션 (segmentation)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/d4809f18-a915-4e30-8b11-8f015eacff00/695b5d2e-9eaa-43f5-87eb-9f303ec57cd6/Untitled.png)

- 프로세스의 메모리 영역을 논리적 단위인 세그먼트로 분할해 메모리를 할당
    - 논리적 단위: 파일 내 함수, 프로세스의 스택 또는 힙 등등
- `세그먼테이션 테이블` (segment table) 사용해 세그먼트 논리 주소 — 물리 주소 매핑
    - index: 세그먼트 번호
    - 시작 주소 base, 세그먼트 길이 limit을 저장
- 단위별로 데이터를 보호하기 쉬움
- 세그먼트 크기가 균등하지 않아 프로세스 할당/해제 과정에서 외부 단편화 문제 발생 가능
- 오버플로가 발생하면 다른 프로세스와 메모리 영역이 겹칠 수 있음 → 디스크로 스왑 아웃 해야 함