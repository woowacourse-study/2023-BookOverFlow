# 1.2(프로세스)

## 1.2.1 프로세스와 스레드(⭐⭐⭐)

### **프로세스**

- 프로세스는 컴퓨터에서 실행 중인 하나의 프로그램을 의미한다.
- 메모리에 로드 된 프로그램이 프로세스이다.
- 프로그램은 특정 작업을 수행하기 위한 명령어의 집합이다.
- OS는 프로그램을 실행하면서 디스크에 저장된 데이터를 메모리에 로드한다.
- 프로세스는 OS로부터 독립된 메모리 영역(코드, 데이터, 스택, 힙)을 할당받으며, 다른 프로세스의 메모리 영역에 접근할 수 없다.

![Untitled](1%202(%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3)%201a60c791bb1b4c77b072ad5f0fe726fb/Untitled.png)

![Untitled](1%202(%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3)%201a60c791bb1b4c77b072ad5f0fe726fb/Untitled%201.png)

**스택(stack)**

- 지역 변수, 함수의 매개변수, 반환되는 주소 값 등이 저장되는 영역이다.
- 높은 주소 값에서 낮은 주소 값으로 메모리가 할당되며, 영역 크기는 컴파일 때 결정된다.
- 원시 타입

**힙(heap)**

- 사용자에 의해 동적 메모리 할당이 일어나는 영역이다.
- C언어에서 malloc()으로 할당되는 영역이다.
- 낮은 주소값에서 높은 주소 값으로 메모리가 할당되며, 영역 크기는 런타임 때 결정된다.
- 오브젝트 타입
    - 오브젝트의 주소값은 스택

**데이터(data)**

- 전역 변수, 정적 변수, 배열, 구조체 등이 저장되는 영역이다.
- 데이터 영역은 세부적으로 BSS(Block Stated Symbol) 영역과 데이터 영역으로 다시 나눌 수 있다.
- BSS 영역은 초기화하지 않은 변수를 저장한다.
- 데이터 영역은 초기화한 변수를 저장한다.

**코드(code)**

- 실행할 코드가 기계어로 컴파일되어 저장되는 영역으로, 텍스트 영역이라고도 한다.

**오버플로**

- 스택 영역과 힙 영역은 동적으로 메모리 할당이 가능해 두 영역 사이에 빈 메모리 공간이 존재한다.
- 스택 영역은 LIFO(Last In First Out, 후입선출) 방식으로, 높은 주소 값에서 낮은 주소 값 순서로 사용한다.
- 힙 영역은 FIFO(First In First Out, 선입선출) 방식으로, 낮은 주소 값에서 높은 주소 값 순서로 사용한다.
- 하지만 메모리 영역을 공유하기 때문에 서로의 영역을 침범할 수 있다.
- 스택 영역이 힙 영역을 침범하는 경우를 스택 오버플로(Stack Overflow), 힙 영역이 스택 영역을 침범하는 경우를 힙 오버플로(Heap Overflow)라고 한다.
    - 오버플로: 메모리 공간에서 할당할 수 있는 최대범위를 넘어가는 것을 의미한다.
    - 언더플로: 메모리 공간에서 할당할 수 있는 최소범위보다 작은 것을 의미한다.

### 스레드

- 프로세스는 한 개 이상의 스레드를 갖는다.
- **스레드(thread)는 프로세스에서 실제로 실행되는 흐름의 단위**를 의미한다.
    - ㅇㅈ맞긴하네 메인스레드 - 워커스레드 123 - 메인스레드
- 스레드는 프로세스 안에 존재하므로 프로세스의 메모리 공간을 이용하고, 지역 변수를 저장하는 스택 영역을 할당받는다. 그리고 전역 변수를 저장하는 힙 영역은 다른 스레드와 공유한다.
- 스레드도 스레드를 관리하는 주체에 따라 구분한다.

**사용자 레벨 스레드(user-level thread)**

- 사용자가 라이브러리를 이용해 생성 및 관리한다.

**커널 레벨 스레드(kernel-level thread)**

- 커널이 스레드를 생성 및 관리한다.

**다대일 모델(many-to-one model)**

![Untitled](1%202(%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3)%201a60c791bb1b4c77b072ad5f0fe726fb/Untitled%202.png)

- 사용자 레벨 스레드 n개에 커널 레벨 스레드 1개가 매핑된다.
- 하나의 사용자 레벨 스레드에서 시스템 콜을 호출하면 나머지 사용자 레벨 스레드는 커널 레벨 스레드에 접근할 수 없어 멀티 코어의 병렬성을 이용할 수 없다.

**일대일 모델(one-to-one model)**

![Untitled](1%202(%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3)%201a60c791bb1b4c77b072ad5f0fe726fb/Untitled%203.png)

- 사용자 레벨 스레드 1개에 커널 레벨 스레드 1개가 매핑된다.
- 다대일 모델의 단점은 보완할 수 있지만, 사용자 레벨 스레드 수만큼 커널 레벨 스레드가 생성되므로 성능 저하가 발생한다.

**다대다 모델(many-to-many model)**

![Untitled](1%202(%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3)%201a60c791bb1b4c77b072ad5f0fe726fb/Untitled%204.png)

- 사용자 레벨 스레드 n개에 커널 레벨 스레드 n개가 매핑된다.
    - 커널 레벨 스레드의 수는 사용자 레벨 스레드의 수 이하이다.
- 다대일, 일대일 모델의 장점을 포함하지만 구현이 어렵다.

## 1.2.2 PCB(Process Control Block, 프로세스 제어 블록)(⭐⭐)

- OS는 **프로세스를 제어하기 위해 프로세스 정보를 저장**하는데, 이를 PCB라고 한다.
    - 프로세스의 현재 상태
    - 프로세스를 나타내는 고유의 프로세스 ID(PID)
        - 부모 프로세스의 PID
        - 자식 프로세스의 PID
    - 다음 실행할 명령어의 주소인 PC(Program Counter)
    - 프로세스의 우선순위
    - 메모리 제한 등
        
        ![Untitled](1%202(%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3)%201a60c791bb1b4c77b072ad5f0fe726fb/Untitled%205.png)
        

## 1.2.3 프로세스의 생성(⭐⭐⭐)

- 새로운 프로세스는 기존 프로세스에서 fork() 함수를 호출해 생성한다.
    - fork() 함수에는 함수를 호출한 프로세스를 복사하는 기능이 있다.
    - 이때 기존 프로세스를 부모 프로세스, 복사된 프로세스를 자식 프로세스라고 한다.
- 부모 프로세스에서 fork() 함수를 호출하면, **부모 프로세스는 자식 프로세스의 PID 값을, 자식 프로세스는 0을 반환한다.**
- 코

![Untitled](1%202(%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3)%201a60c791bb1b4c77b072ad5f0fe726fb/Untitled%206.png)

**운영체제가 프로세스를 종료하는 경우**

- 프로세스가 운영체제의 종료 서비스 exit()를 호출해 정상 종료하는 경우
- 프로세스의 실행 시간 또는 특정 이벤트 발생을 기다리는 시간이 제한된 시간을 초과한 경우
    - 응 답없음
- 프로세스가 파일 검색 또는 입출력에 실패하는 경우
- 오류가 발생하거나 메모리 부족 등이 발생하는 경우
    - 비정상 종료

**부모 프로세스가 자식 프로세스를 종료시키는 경우**

- 자식 프로세스가 할당된 자원을 초과해 사용할 때
- 자식 프로세스에 할당된 작업이 없을 때

## 1.2.4 프로세스 상태도(⭐⭐⭐)

- 모든 프로세스는 CPU에 의해 생성되고 소멸되는 과정을 거친다.
- **생성(new) - 준비(ready) - 대기(waiting) - 실행(running) - 종료(terminated)의 5가지 상태로 존재한다.**

![Untitled](1%202(%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3)%201a60c791bb1b4c77b072ad5f0fe726fb/Untitled%207.png)

- 생성(new): 프로세스가 PCB를 가지고 있지만 OS로부터 승인 받기 전
- 준비(ready): OS로부터 승인받은 후 준비 큐에서 CPU 할당을 기다림.
- 실행(running): 프로세스가 CPU를 할당받아 실행함.
- 대기(waiting): 프로세스가 입출력이나 이벤트 발생을 기다려야 해서 CPU 사용을 멈추고 기다림.
- 종료(terminated): 프로세스 실행을 종료함.

프로세스는 한 상태에서 다른 상태로 다음과 같이 변화한다.

- 생성 → 준비: 생성 상태의 프로세스가 OS로부터 승인을 받아, 준비 상태의 프로세스가 모여 있는 자료구조인 준비 큐(ready queue)에 추가됨.
- 준비 → 실행: 준비 큐에 있는 프로세스 중 우선순위가 높은 프로세스가 디스패치되어 실행됨.
    - 디스패치: 프로세스가 CPU 자원을 할당해 해당 프로세스가 준비 상태에서 실행 상태가 되는 것을 의미한다.
- 실행 → 준비: CPU 독점을 방지하기 위해 타임아웃되어 준비 상태로 변경됨.
- 실행 → 대기: 입출력 또는 이벤트 때문에 대기 상태로 변경됨.
- 대기 → 준비: 입출력 또는 이벤트가 완료되어 준비 상태로 변경됨.
- 실행 → 종료: 실행중인 프로세스가 정상적으로 끝나서 종료 상태로 변경됨.

## 1.2.5 멀티 프로세스와 멀티 스레드(⭐⭐⭐)

**동시성(Concurrency)**

- **하나의 코어(싱글 코어)에서 여러 작업을 번갈아 가면서 처리하는 방식이다.**
- 이렇게 하나의 CPU에서 여러 작업을 번갈아 가면서 처리하기 위해 처리 중인 작업을 교체하는 것을 컨텍스트 스위칭(Context swtiching)이라고 한다.

**병렬성(parallelism)**

- CPU가 여러 개(멀티 코어) 있어서 각 CPU에서 각 작업을 동시에 처리하는 방식이다.
- 물리적인 시간 관점에서 동시에 여러 작업이 처리된다.

![Untitled](1%202(%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3)%201a60c791bb1b4c77b072ad5f0fe726fb/Untitled%208.png)

### 멀티 프로세스(multi process)

- 멀티 프로세스는 응용 프로그램 하나를 여러 프로세스로 구성하는 것을 의미한다.
- 멀티 프로세스 환경에서는 한 프로세스가 죽어도 다른 프로세스에 영향을 주지 않는다.
    - **그래서 응용 프로그램을 프로세스 하나로 구성하는 것보다 여러 개로 구성하는 것이 안정적이다.**
- 시간과 메모리 공간을 많이 사용한다는 단점이 있다.
- CPU는 하나의 프로세스만 처리할 수 있다.
- 여러 프로세스를 처리하려면 CPU에서 처리중인 프로세스를 교체하는 컨텍스트 스위칭 작업이 이루어진다.
    - CPU에서 기존에 처리하던 프로세스가 할당받은 메모리 영역을 다른 프로세스에서 사용할 수 있게 교체해주면서 시간과 메모리가 필요한데, 이를 **오버헤드(overhead)**라고 한다.
- 프로세스는 독립적인 메모리를 할당받는다.
    - 따라서, 프로세스 간에 공유할 자원이 있다면 **IPC(Inter Process Communication)**를 통해 프로세스 간에 자원을 공유해야 한다.
        - 그래서 공유할 메모리를 직접 참조하는 것보다 비효율적이다.

![Untitled](1%202(%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3)%201a60c791bb1b4c77b072ad5f0fe726fb/Untitled%209.png)

### 멀티 스레드(multi thread)

- 멀티 스레드는 스레드를 여러 개 생성해 스레드들이 각자 다른 작업을 처리하는 것을 의미한다.
- 멀티 스레드는 스레드 간에 힙, 데이터, 코드 영역을 공유한다.
- 컨텍스트 스위칭을 할 때 오버헤드가 적고 IPC를 사용하지 않아도 되어 멀티 프로세스의 단점을 보완할 수 있다.
    - 따라서, 독립적인 메모리 공간을 갖는 프로세스를 여러 개 생성하는 것보다 멀티 스레드가 자원을 효율적으로 사용할 수 있다.
    - 스레드 간 자원 공유가 프로세스 간 자원 공유보다 시스템 처리 비용이 적고 프로그램 응답 시간도 단축된다.
- 공유 자원에 대한 동기화가 필수다.
    - [https://inkyu-yoon.github.io/docs/Language/Java/Volatile](https://inkyu-yoon.github.io/docs/Language/Java/Volatile)
- 스레드 문제가 생기면 프로세스 내 다른 스레드에 영향을 미칠 수 있다.
    
    ![Untitled](1%202(%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3)%201a60c791bb1b4c77b072ad5f0fe726fb/Untitled%2010.png)
    

## 1.2.6 컨텍스트 스위칭(⭐⭐⭐)

**인터럽트(interrupt)**

- **입출력 관련 이벤트가 발생하거나 예외 상황이 발생할 때 이에 대응할 수 있게 CPU에 처리를 요청하는 것**
- 입출력 발생할 때, CPU 사용 시간이 만료되었을 때, 자식 프로세스를 생성할 때 발생한다.
- CPU의 들어가는 커널모드에 들어가는 진입점(시스템콜, 트랩)이고 CPU의 효율성을 높이기 위해 존재

**컨텍스트(context)**

- CPU가 처리하는 프로세스의 정보를 의미한다.

- CPU는 하나의 프로세스만 처리할 수 있으므로, 멀티 프로세스를 처리하려면 CPU 스케줄러에 의해 인터럽트가 발생하며 컨텍스트 스위칭이 이뤄진다.
- **멀티 프로세스 환경에서 CPU가 처리중인 프로세스의 정보를 바꾸는 것이 컨텍스트 스위칭이다.**
    
    ![Untitled](1%202(%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3)%201a60c791bb1b4c77b072ad5f0fe726fb/Untitled%2011.png)
    
    - 그림처럼 P1의 PCB에 저장하고, P2의 PCB에 저장된 정보를 레지스터에 로드하는 동안 CPU는 아무 일도 하지 못한다.
    - 어떤 처리를 하는 데 간접적인 처리 시간과 메모리가 소요될 경우에 ‘오버헤드가 발생한다’고 한다.
- 멀티 스레드 환경에서도 스레드를 교체하며 컨텍스트 스위칭이 이루어진다.
    - 비교적 자원을 적게 사용한다.
- CPU에서 처리중인 프로세스가 중간에 변경되어도 이전 코드를 재개할 수 있는 이유는 PCB에 프로그램 카운터와 스택 포인터 값이 저장되어 있기 때문이다.

**프로그램 카운터(Program Counter, PC)**

- 프로세스가 이어서 처리해야 하는 명령어의 주소 값이다.

**스택 포인터(Stack Pointer)**

- 스택 영역에서 데이터가 채워진 가장 높은 주소 값을 가리킨다.

## 1.2.7 프로세스 동기화(⭐⭐⭐)

### 경쟁 상태

- 여러 프로세스 또는 스레드에서 하나의 공유 자원에 접근하는 경우가 있다.
- **공유 자원에 동시에 접근해 경쟁하는 상태를 경쟁 상태(race condition)라고 한다.**

![Untitled](1%202(%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3)%201a60c791bb1b4c77b072ad5f0fe726fb/Untitled%2012.png)

- 이러한 문제를 해결하기 위해 프로세스 동기화가 이뤄져야 한다.

### 임계 영역

- **공유 자원에 접근할 수 있고 접근 순서에 따라 결과가 달라지는 코드 영역을 임계 영역(critical section)이라고 한다.**
- 위의 예시에서 우유 유무를 판단하고 우유를 추가하는 부분이 임계 영역에 해당한다.
- 임계영역에서의 경쟁 상태를 방지하기 위해 데이터의 일관성이 유지되도록 프로세스 동기화(Process synchronization)를 해야 한다.
- 임계 영역에 여러 접근이 동시에 발생하는 것을 방지하기 위해 필요한 3가지 조건이 있다.
1. 상호배제 기법(mutual exclusive): 어떤 프로세스가 임계 영역을 실행 중일 때 다른 프로세스가 임계 영역에 접근할 수 없다. 상호배제 기법으로는 뮤텍스와 세마포어가 있다.
2. 진행(progress): 임계 영역을 실행 중인 프로세스가 없을 때 다른 프로세스가 임계 영역을 실행한다.
3. 한정된 대기(bouded waiting): 임계 영역에 접근을 요청했을 때 무한한 시간을 기다리지 않는다.

### 뮤텍스(mutex)

- [https://www.youtube.com/watch?v=NL9JQh5bbZ8&t=319s](https://www.youtube.com/watch?v=NL9JQh5bbZ8&t=319s)
- **Mutual Exclusion의 약어로, 락(lock)을 가진 프로세스만이 공유 자원에 접근할 수 있게 하는 방법이다.**
    - Boolean 타입의 lock 변수를 활용한다.
    - 한개의 프로세스/스레드만 뮤텍스를 소유(acquire()) 및 해제(release())한다.
    - non-busy-wait: 대기중인 프로세스/스레드는 대기큐에서 대기한다.
        - 바쁜대기(busy-wait): 프로세스가 공유 자원에 접근할 수 있는 권한을 얻을 때까지 확인하는 과정을 일컫는다.
- 임계 영역에 접근한 프로세스가 임계 영역에 락을 건다고 해서 락킹 매커니즘(locking machanism)이라고도 한다.
- 대기큐의 프로세스는 락이 풀렸는지 반복문을 돌면서 확인한다.
    - 이를 바쁜 대기(busy-wain)의 한 종류인 스핀락이라고도 한다.
    - 스핀락은 락을 얻기 위해 프로세스가 반복문을 돌면서 기다리는 것을 의미한다.
    - 프로세스가 빠르게 교체될 수 있다.

### 세마포어(Semaphore)

- **세마포어는 공유 자원에 접근할 수 있는 프로세스의 수를 정해 접근을 제어하는 방법이다.**
    - 정수 타입의 세마포어 정수를 활용한다.
    - 한 개 이상의 프로세스/스레드가 접근할 수 있다.
    - Wait(p연산)을 통해 정수를 감소, Signal(v연산)을 통해 정수를 증가
    - non-busy-wait 방식이다.
- 공유 자원에 접근한 프로세스가 접근을 해제하면 다른 프로세스가 접근할 수 있도록 신호를 보낸다고 해서 시그널링 매커니즘(Signaling mechanism)이라고도 한다.
- 세마포어 정수가 최대1이면 이진 세마포어, n이면 카운팅 세마포어라고도 한다.
    - 세마포어 음수값의 절대값은 대기큐의 프로세스/스레드의 갯수다.
- 대기큐에서 나오는 방식에 따라 강성 세마포어(FIFO), 약성 세마포어(명시x)가 있다.

**동기(Synchronization)**

- 여러 작업을 처리할 때 작업 순서를 보장함

**비동기(Asynchronization)**

- 여러 작업을 처리할 때 작업 순서를 보장하지 않음

**블로킹(blocking)**

- 작업을 수행할 때 대기할 수 있다는 것을 의미하며 작업 순서를 보장하지 않음

**넌블로킹(non-blocking)**

- 작업을 시작하면 대기 없이 수행한다는 것을 의미함

## 1.2.8 교착 상태(Deadlock)(⭐⭐⭐)

- **상호배제 기법 때문에 2개 이상의 프로세스가 각각 자원을 가지고 있으면서 서로의 자원을 요구하며 기다리는 상태를 교착상태라고 한다.**
    - 식사하는 철학자
- 교착상태를 일으키는 4가지 필요충분 조건이 있다.
1. 상호배제(mutual exclusion): 하나의 공유 자원에 하나의 프로세스만 접근할 수 있다.
2. 점유와 대기(hold and wait): 프로세스가 최소 하나의 자원을 점유하고 있는 상태에서 추가로 다른 프로세스에서 사용 중인 자원을 점유하기 위해 대기한다.
3. 비선점(non-preemption): 다른 프로세스에 할당된 자원을 뺏을 수 없다.
4. 환형 대기(circular wait): 프로세스가 자신의 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구한다.

- 교착상태를 막으려면 앞의 4가지 필요 충분 조건 중에서 한 가지를 제거하면 된다.
1. 상호배제 부정: 여러 프로세스가 동시에 하나의 공유 자원을 사용할 수 있게 한다.
2. 점유와 대기 부정: 프로세스가 실행되기 전에 필요한 모든 자원을 할당함으로써 프로세스 대기를 없앤다.
    - 또는 프로세스가 자원을 점유하지 않은 상태에서만 자원을 요구하게 한다.
3. 비선점 부정: 자원을 점유한 프로세스가 다른 자원을 요구할 때 점유한 자원을 반납하게 한다.
4. 환형 대기 부정: 자원을 선형 순서로 정렬해 고유 번호를 할당한다. 그리고 각 프로세스에서 요구할 수 있는 번호의 방향을 정해서 한쪽 방향으로만 자원을 요구하게 한다.

## 1.2.9 스레드 안전(thread safe)(⭐⭐)

- 스레드 안전이란, **멀티 스레드 환경에서 하나의 변수, 함수, 객체에 스레드 여러개가 동시에 접근해도 문제가 없음을 의미한다.**
    
    ![Untitled](1%202(%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3)%201a60c791bb1b4c77b072ad5f0fe726fb/Untitled%2013.png)
    
- 스레드 안전이 이뤄지지 않는 경우이다.
- 프로세스 동기화 문제 또한 스레드 안전하다고 할 수 없다.
- 스레드 안전을 위한 조건은 다음과 같다.
    - 상호 배제: 뮤텍스 혹은 세마포어와 같은 상호배제 기법을 사용해 접근을 통제한다.
    - 원자 연산: 공유 자원에 접근할 때 원자 연산을 이용하거나 원자적으로 정의된 연산을 이용해 연산 도중에 다른 스레드가 접근할 수 없게 한다.
        - 여기서 원자 연산이란, ‘연산했다’, ’연산 안 했다’ 두 가지만 존재하는 연산이다.
    - 재진입성: 특정 함수를 하나의 스레드에서 실행 중일 때 다른 스레드가 해당 함수를 실행해도 각 스레드에 올바른 결과가 나올 수 있게 해야 한다.
    - 스레드 지역 저장소: 각 스레드에서만 접근할 수 있는 저장소를 사용해서 공유 자원을 줄인다.

## 1.2.10 IPC(Inter Process Communication)(⭐⭐)

- 프로세스는 고유한 메모리 영역을 갖기 때문에 프로세스 간 자원을 공유해야 할 때 IPC해야 한다.
    - 프로세스 간에 자원을 공유하는 방식을 나타낸다.
- 다음과 같다.
    1. 공유 메모리(shared memory): 프로세스 간에 공유 가능한 메모리를 구성해 자원을 공유하는 방식이다.
        - 여러 프로세스에서 접근할 수 있으므로 동기화 문제가 발생할 수 있다.
        
        ![Untitled](1%202(%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3)%201a60c791bb1b4c77b072ad5f0fe726fb/Untitled%2014.png)
        
    2. 소켓(socket): 네트워크 소켓을 이용하는 프로세스 간 통신으로, 외부 시스템과도 이용할 수 있다.
        - 클라이언트 - 서버 구조로 자원을 주고받는다.
            
            ![Untitled](1%202(%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3)%201a60c791bb1b4c77b072ad5f0fe726fb/Untitled%2015.png)
            
    3. 세마포어(semaphore): 접근하는 프로세스를 제어해 공유 자원을 관리한다.
    4. 파이프(pipe): FIFO 형태의 메모리인 파이프를 이용해 프로세스 간 자원을 공유하는 방식이다.
        - 파이프는 단방향 통신만 지원하므로 읽기 또는 쓰기 중 하나만 할 수 있다.
        - 양방향 통신을 하려면 읽기 파이프와 쓰기 파이프를 각각 생성해야 한다.
            
            ![Untitled](1%202(%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3)%201a60c791bb1b4c77b072ad5f0fe726fb/Untitled%2016.png)
            
    5. 메시지 큐(message queue): FIFO 형태의 큐 자료구조를 사용해 프로세스 간 메시지를 주고받는 방식이다.
        
        ![Untitled](1%202(%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3)%201a60c791bb1b4c77b072ad5f0fe726fb/Untitled%2017.png)
        
    

## 1.2.11 좀비 프로세스와 고아 프로세스(zombie/orphan process)(⭐⭐)

- **자식 프로세스가 종료되었지만 부모 프로세스가 자식 프로세스의 종료 상태를 회수하지 않았을 경우에 남겨진 자식 프로세스를 좀비 프로세스라고 한다.**
    - 자식 프로세스가 종료될 때 부모 프로세스에 `SIGHLD`라는  시그널을 보내면 부모 프로세스에서 `wait()`함수(시스템콜)를 호출해 자식 프로세스의 상태 정보를 받고 자원을 회수한다.
    - 이때 자원회수에 실패하면 좀비 프로세스가 생성된다.
- **부모 프로세스가 자식 프로세스보다 먼저 종료되는 경우에 자식 프로세스를 고아 프로세스라고 한다.**
    - 자식 프로세스의 부모 PID를 init 프로세스의 PID인 1로 바꿔준다.
    - 이렇게하면 고아 프로세스의 부모 프로세스는 init 프로세스가 된다.
    - 이러면 init프로세스가 고아 프로세스의 자원을 회수할 수 있다.