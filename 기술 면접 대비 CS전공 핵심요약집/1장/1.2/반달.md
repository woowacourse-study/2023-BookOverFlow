## 1.2.1 프로세스와 스레드

> 프로세스는 컴퓨터에서 실행 중인 하나의 프로그램을 의미한다.
> 프로그램은 특정 잡업을 수행하기 위한 명령어의 집합이다.
> OS는 프로그램을 실행하면서 디스크에 저장된 데이터를 메모리로 로드한다.
> 프로세스는 OS로부터 독립된 메모리 영역(코드, 데이터, 스탭, 힙)을 할당받으며, 다른 프로세스의 메모리 영역에 접근할 수 없다.

![Pasted image 20231205174610](https://github.com/woowacourse-study/2023-cs-study/assets/22425650/ed56dd00-444b-4be8-a3b8-4e9841fcf038)

### 프로세스의 메모리 영역 구조
![Pasted image 20231205174930](https://github.com/woowacourse-study/2023-cs-study/assets/22425650/56ef7c3c-1e10-4ef0-9171-0df315a86113)

- 스택(stack): 지역변수, 함수의 매개변수(parameter), 반환되는 주소 값 등이 저장되는 영역이다.
  높은 주소 값에서 낮은 주소 값으로 메모리가 할당되며, 영역 크기는 컴파일 때 결정된다.

- 힙(heap): 사용자에 의해 동적 메모리 할당이 일어나는 영역이다. C 언어에서 malloc()으로 할당되는 형역이라고 보면 된다. 낮은 주소 값에서 높은 주소 값으로 메모리가 할당되며, 영역 크기는 런타임 때 결정된다.

-  데이터(data): 전역 변수, 정적 변수, 배열, 구조체 등이 저장되는 영역이다. 데이터 영역은 세부적으로 BSS(Block Stated Symbol) 영역과 데이터 영역으로 다시 나눌 수 있다. BSS 영역은 초기화 하지 않은 변수를, 데이터 영역을 초기화한 변수를 저장한다.

- 코드(code) 실행할 코드가 기계어로 컴파일 되어 저장되는 영역으로, 텍스트(text) 영역이라고도 한다.

>[!info]
>스택 영역과 힙영역은 동적으로 메모리 할당잉 가능해 두 영역 사이에 빈 메모리 공간이 존재한다.
>스택은 LIFO 방식으로, 높은 주소값에서 낮은 주소 값 순서로 사용하고,
>힙영역은 FIFO 방식으로, 낮은 주소값에서 높은 주소 값 순서로 사용한다.
>하지만 메모리 영역을 공유하기에 서로의 영역을 침범하기도 한다.
>스택 영역이 힙영역을 침범하는 경우를 스택오버플로, 힙 영역이 스택 영역을 침범하는 경우를 힙 오퍼블로 힙 오버 플로라고한다.
>(침범하는 것 + 오버플로)

### 스레드(Thread)

> 프로세스는 한 개 이상의 스레드를 갖는데, 스레드는 프로세스에서 실제로 실행되는 흐름의 단위를 의미한다.
> 스레드는 프로세스 안에 존재하므로 프로세스의 메모리 공간을 이용하고, 지역 변수를 저장하는 스택 영역을 할당받는다. 그리고 전역 변수를 저장하는 힙 영역은 다른 스레드와 공유한다.
> **스레드는 각각의 스택을 가지고 나머지 영역은 다른 스레드와 공유한다.**

### 사용자 레벨 스레드와 커널 레벨 스레드

> 스레드를 관리하는 주체에 따라 구분한다.
> 사용자 레벨 스레드는 사용자가 라이브러리를 이용해 생성 및 관리한다.
> 커널 레벨 스레드는 커널이 스레드를 생성 및 관리한다.
> 멀티 스레드 환경에서 사용자 레벨 스레드와 커널 레벨 스레드는 다음과 같이 3가지 관계를 맺을 수 있다.

1. 다대일 모델(many to one model)
    - 사용자 레벨 스레드 n개에 커널 스레드 1개가 매핑 되어 사용자 레벨에서 스레드를 관리한다.
    - 하나의 사용자 레벨 스레드에서 시스템 콜을 호출하면 나머지 사용자 레벨 스레드는 커널 레벨 스레드에 접근할 수 없으므로 멀티 코어의 병렬성을 이용할 수 없다.
2. 일대일 모델(one to one model)
    - 사용자 레벨 스레드 1개에 커널 스레드 1개가 매핑된다.
    - 하나의 사용자 레벨 스레드에서 시스템 콜을 호출하면 다른 사용자 레벨 스레드가 모두 실행되지 않는 다대일 모드의 단점을 해결한다.
    - 하지만 크만큼 커널 레벨 스레드를 많이 생성하므로 성능 저하가 일어날 수 있다.
3. 다대다 모델(many to many model)
    - 사용자 레벨 스레드 n 개에 커널 레벨 스레드 m개가 매핑된다. 이때 커널 레벨 스레드의 수(m)는 사용자 레벨 스레드의 수(n)이하다.  (n과 m이 같더라도 일대일 모델과는 다르다.)
    - 다대일 모델과 일대일 모델의 장점을 포함하지만, 구현이 어렵다는 단점이 있다.

---
## 1.2.2 PCB

> OS는 프로세스를 제어하기 위해 프로세스 정보를 저장하는데, 이를 PCB(Process Control Block, 프로세스 제어 블록)라고 한다.
> 프로세스의 현재 상태, 프로세스를 나타내는 고유의 PID(Process ID), 부모 프로세스의 PID, 다음 실행할 명령어의 주소인 PC(Program Counter, 프로그램 카운터), 프로세스의 우선순위, 메모리 제한 등을 저장한다.

- 프로세스 식별자(Process ID)
- 프로세스 상태(Process State): 생성(create), 준비(ready), 실행(running), 대기(waiting), 완료(terminated) 상태가 있다. - 유예준비상태suspended ready, 유예대기상태suspended wait는 스택이 아닌 disk에 저장된다.
- 프로그램 계수기(Program Counter): 프로그램 계수기는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.
- CPU 레지스터 및 일반 레지스터
- CPU 스케줄링 정보: 우선 순위, 최종 실행시각, CPU 점유시간 등
- 메모리 관리 정보: 해당 프로세스의 주소 공간 등
- 프로세스 계정 정보: 페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모 등
- 입출력 상태 정보: 프로세스에 할당된 입출력장치 목록, 열린 파일 목록 등

---
## 1.2.3 프로세스의 생성

> 새로운 프로세스는 기존 프로세스에서 fork() 함수를 호출해 생성한다.
> fork() 함수에는 함수를 호출한 프로세스를 복사하는 기능이 있다.
> 이때 기존 프로세스를 부모(parent) 프로세스, 복사된 프로세스를 자식(child) 프로세스라고 한다.
> 부모 프로세스에서 fork() 함수를 호출하면 부모 프로세스는 자식 프로세스의 PID 값을, 자식 프로세스는 0을 반환한다.

### 운영체제가 프로세스를 종료하는 경우
- 프로세스가 운영체제의 종료 서비스(exit())를 호출해 정상 종료하는 경우
- 프로세스의 실행 시간 또는 특정 이벤트 발생을 기다리는 시간이 제한되 시간을 초과한 경우
- 프로세스가 파일 검색 또는 입출력에 실패하는 경우
- 오류가 발생하거나 메모리 부족 등이 발생하는 경우

### 부모 프로세스가 자식 프로세스를 종료시키는 경우
- 자식 프로세스가 할당된 자원을 초과해 사용할 때
- 자식 프로세스에 할당된 작업이 없을 때

---
## 1.2.4 프로세스 상태도

> 모든 프로세스는 CPU에 의해 생성되고 소멸하는 과정을 거친다.

![Pasted image 20231205190524](https://github.com/woowacourse-study/2023-cs-study/assets/22425650/6f861b2c-6a1e-4256-b126-cad1229d3d8f)


- 생성(new): 프로세스가 PCB를 가지고 있지만 OS로부터 승인(adimit)받기 전
- 준비(ready): OS로부터 승인받은 후 준비 큐에서 CPU 할당을 기다림
- 실행(running): 프로세스가 CPU를 할당받아 실행함
- 대기(waiting): 프로세스가 입출력이나 이벤트 발생을 기다려야 해서 CPU 사용을 멈추고 기다림
- 종료(terminated): 프로세스 실행을 종료함

1. 생성 -> 준비: 생성 상태의 프로세스가 OS로부터 승인을 받아, 준비 상태의 프로세스가 모여있는 자료구조인 준비 큐(ready queue)에 추가됨
2. 준비 -> 실행: 준비 큐에 있는 프로세스 중 우선순위가 높은 프로세스가 디스패치되어 실행됨
3. 실행 -> 준비: CPU 독점을 방지하기 위해 타임아웃(time out)되어 준비 상태로 변경됨
4. 실행 -> 대기: 입출력 또는 이벤트 때문에 대기 상태로 변경됨
5. 대기 -> 준비: 입출력 또는 이벤트가 완료되어 준비 상태로 변경됨
6. 실행 -> 종료: 실행 중인 프로세스가 정상적으로 끝나서 종료 상태로 변경됨

- 승인(admit): CPU를 제외한 다른 자원이 준비되어 해당 프로세스가 준비 상태가 될 수 있도록 OS가 허락하는 것
- 디스패치(dispatch): 프로세스에 CPU 자원을 할당해 프로세스가 준비 상태에서 실행 상태가 되는 것을 의미

---
## 1.2.5 멀티 프로세스와 멀티 스레드

### 동시성(concurrency)
> 하나의 코어에서 여러 작업을 번갈아 가면서 처리하는 방식
> CPU는 한 번에 하나의 작업만 처리할 수 있어서 여러 작업을 조금씩 돌아가면서 처리한다.
> 이렇게 하나의 CPU에서 여러 작업을 번갈아 가면서 처리하기 위해 처리 중인 작업을 교체하는 것을 콘텍스트 스위칭(context switching)이라고 한다.

### 병렬성(parallelism)
> CPU가 여러 개(멀티 코어) 있어서 각 CPU에서 각 작업을 동시에 처리하는 방식이다.
> 즉 물리적인 시간 관점에서 동시에 여러 작업이 처리된다.

### 멀티 프로세스
> 멀티 프로세스는 응용 프로그램 하나를 여러 프로세스로 구성하는 것을 의미한다.

장점: 한 프로세스가 죽어도 다른 프로세스에 영향을 주지 않는다.
그래서 응용 프로그램을 프로세스 하나로 구성하는 것보다 여러개로 구성하는 것이 안정적이다.
단점: 시간과 메모리를 많이 사용한다.
CPU는 하나의 작업만 처리할 수 있기 때문에 여러 프로세스를 처리하려면 CPU에서 처리 중인 프로세스를 교체하는 콘텍스트 스위칭 작업이 이루어져야 한다.
이떄 CPU에서 기존에 처리하던 프로세스가 할당받은 메모리 영역을 다른 프로세스에서 사용할 수 있게 교체하면서 시간과 메모리가 필요한데, 이를 오버헤드 라고한다.
프로세스는 독립적인 메모리를 할당받는다. 따라서 프로세스 간에 공유할 자원이 있다면 IPC(Inter Process Conmmunication)를 통해 프로세스 간에 자원을 공유해야한다. 그래서 공유할 메모리를 직접 참조하는 것보다 비효율적이다.

<img width="312" alt="Pasted image 20231205192234" src="https://github.com/woowacourse-study/2023-cs-study/assets/22425650/4c2cc85a-89a3-4c5a-b6ea-ce64d7ce2e79">

### 멀티스레드

> 스레드를 여러 개 생성해 스레드들이 각자 다른 작업을 처리하는 것을 의미한다.
> 멀티 스레드는 스레드 간에 힙, 데이터, 코드 영역을 공유한다.
> 그래서 컨텍스트 스위칭할 때 오버헤드가 적게 발생하고 IPC를 사용하지 않아도 되어 멀티 프로세스의 단점을 보완할 수 있다.
> 때문에 멀티 프로세스의 단점을 보완할 수 있다.
> 스레드 간 자원 공유가 프로세스간 자원 공유보다 시스템 처리 비용이 적고 프로그램 응답 시간도 단축된다.

>[!warning]
> 다른 스레드와 함께 사용하는 공유자원에 대한 동기화가 필수다. 또한, 스레드에 문제가 생기면 프로세스 내 다른 스레드에 영향을 미칠 수 있다.

---
## 1.2.6 콘텍스트 스위칭

### 인터럽트(Interrupt)
> CPU에서 프로세스를 처리하다가 입출력 관련 이벤트가 발생하거나 예외 상황이 발생할 때 이에 대응할 수 있게 CPU에 처리를 요청하는 것

### 콘텍스트(Context)
> CPU가 처리하는 프로세스의 정보

### 콘텍스트 스위칭(Context Switching)
> 멀티 프로세스 환경에서 CPU가 처리 중인 프로세스의 정보를 바꾸는 것

>[!question]
> 멀티스레드를 사용하면 콘텍스트 스위칭이 없나요?

>[!answer]
> 콘텍스트 스위칭이 이뤄지지만 멀티프로세스의 콘텍스트 스위칭보다 시간과 메모리 자원을 적게 사용한다.
> 이유는 멀티스레드는 스택 영역제외한 힙, 데이터, 코드 영역을 공유하므로 레지스터에 저장하고 로드해야 하는 데이터가 상대적으로 적기 때문이다.

>[!question]
> CPU에서 처리중인 프로세스가 중간에 변경되어도 이전에 실행하던 코드를 이어서 실행할 수 있는 이유가 뭔가요?

>[!answer]
>PCB에 프로그램 카운터와 스택 포인터 값이 저장되어 있기 때문이다.
>
>프로그램 카운터(PC, Program Counter): 프로세스가 이어서 처리해야 하는 명령어의 주소값
>스택포인터(Stack Pointer): 스택 영역에서 데이터가 채워진 가장 높은 주소 값을 가리킨다.
>
>이처럼 이어서 실행할 명령어의 주소 값이 무엇인지, 데이터가 스택에 어디까지 채워져 있는지 알고 있으므로 콘텍스트 스위칭이 원활히 이뤄질 수 있다.

---
## 1.2.7 프로세스 동기화

### 경쟁 상태
> 여러 프로세스 또는 스레드에서 하나의 공유 자원에 접근하는 경우가 있는데, 이때 자원에 접근하는 순서에 따라 결과 값이 달라질 수 있다. 이러한 현상을 공유 자원에 동시에 접근해 경쟁하는 상태라고 해서 경쟁 상태(race condition)라고 한다.
> 이러한 문제를 해결하려면 프로세스 동기화가 이뤄져야 한다.

#### 너무 많은 우유 문제(too much milk problem)
- 냉장고: 공유자원
- 엄마, 아빠: 프로세스
- 냉장고에 우유 유무를 판단하고 우유를 추가하는 부분: 임게 영역
### 임계 영역
> 공유 자원에 접근할 수 있고 접근 순서에 따라 결과가 달라지는 코드 영역을 임계 영역(critical section)이라고 한다.

임계 영역에 여러 접근이 동시에 발생하는 것을 방지하려면 다음 3가지의 조건을 충족해야 한다.
- 상호배제 기법(mutual exclusive): 어떤 프로세스가 임계 영역을 실행중일 때 다른 프로세스가 임계 영역에 접근할 수 없다. 상호배제 기법으로는 **뮤텍스**와 **세마포어**가 있다.
- 진행(progress): 임계 영역을 실행중인 프로세스가 없을 때 다른 프로세스가 임계 영역을 실행한다.
- 한정된 대기(bounded waiting): 임계 영역에 접근을 요청했을 떄 무한한 시간을 기다리지 않는다.

### 뮤텍스(Mutex)
> 뮤텍스는 락을 가진 프로세스만이 공유 자원에 접근할 수 있게 하는 방법

### 화장실 예
- 화장실: 공유 자원을 포함한 임계 여역
- 열쇠: 락
- 사람A, 사람B: 공유자원에 접근하려는 프로세스들

> 임계 영역에 먼저 접근한 프로세스가 임계 영역에 락을 걸면 다른 프로세스들은 해당 프로세스가 락을 해제하기 전까지 대기해야 한다. 이처럼 임계 영역에 접근한 프로세스가 임계 영역에 락을 건다고해서 **락킹 매커니즘**(locking mechanism)이라고도 한다.

>[!question]
>락을 기다리는 프로세스는 뭐하고 있나요?

>[!answer]
>불행히도 락을 얻기 위해 반복문을 돌면서 확인하는데 이를 바쁜 대기(busy waiting)의 한 종류인 **스핀락**이라고 한다.  
>이렇게 하면 프로세스가 대기 상태가 되지 않고 반복문을 돌면서 자원의 사용 가능 여부를 확인하므로 프로세스가 빠르게 교체될 수 있다.
>인간으로 치면 화장실 예에서 이미 먼저 들어간 사람이 있는 화장실 문을 계속해서 두드리는 것과 같다.
>(상당히 예의없으나 빠르게 사용은 가능할 것 같다.)

### 세마포어(Semaphore)
> 세마포어는 공유 자원에 접근할 수 있는 프로세스의 수를 정해 접근을 제어하는 방법
> 공유 자원에 접근한 프로세스가 접근을 해제하면 다른 프로세스가 접근할 수 있도록 신호를 보낸다고 해서 시그널링 매커니즘(Signaling Mechanism)이라고도 한다.

### 틈새 용어 정리
- 동기(Synchronization): 여러 작업을 처리할 때 작업 순서를 보장함
- 비동기(Asynchronization): 여러 작업을 처리할 때 작업 순서를 보장하지 않음
- 블로킹(Blocking): 작업을 수행할 때 대기할 수 있다는 것을 의미하며 작업 순서를 보장하지 않음
- 논블로킹(Non-blocking): 작업을 시작하면 대기 없이 수행한다는 것을 의미함

---
## 1.2.8 교착 상태
> 상호배제 기법 때문에 2개 이상의 프로세스가 각각 자원을 가지고 있으면서 서로의 자원을 요구하며 기다리는 상태를 교착상태(DeadLock)라고 한다.

### 교착상태가 발생하는 필요충분 조건 4가지
- 상호배제(mutual exclusion): 하나의 공유 자원에 하나의 프로세스만 접근할 수 있다.
- 점유와 대기(hold and wait): 프로세스가 최소 하나의 자원을 점유하고 있는 상태에서 추가로 다른 프로세스에서 사용 중인 자원을 점유하기 위해 대기한다.
- 비선점(non-preemptioon): 다른 프로세스에 할당된 자원을 뺐을수 없다.
- 환형 대기(circular wait): 프로세스가 자신의 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구한다.

>[!info]
>교착 상태를 막으려면 앞의 4가지 필요 충분 조건 중에서 한 가지를 제거하면 된다.

- 상호배제 부정: 여러 프로세스가 동시에 하나의 공유자원을 사용할 수 있게 한다.
- 점유와 대기 부정: 프로세스가 실행되기 전에 필요한 모든 자원을 할당함으로써 프로세스 대기를 없앤다. 또는 프로세스가 자원을 점유하지 않은 상태에서만 자원을 요구하게 한다.
- 비선점 부정: 자원을 점유한 프로세스가 다른 자원을 요구할 때 점유한 자원을 반납하게 한다.
- 환형 대기 부정: 자원을 선형 순서로 정렬해 고유 번호를 할당한다. 그리고 각 프로세스에서 요구할 수 있는 번호의 방향을 정해서 한쪽 방향으로만 자원을 요구하게 한다.

---
## 1.2.9 스레드 안전

> 스레드 안전(thread safe)는 멀티 스레드 환경에서 하나의 변수, 함수, 객체에 스레드 여러개가 동시에 접근해도 문제가 없음을 의미한다.

스레드가 안전하기 위해서는 다음과 같은 조건을 지켜야한다.
- **상호 배제(mutual exclusive)**: 공유 자원에 접근해야 할 때 뮤텍스 또는 세마포어와 같은 상호배제 기법을 사용해 접근을 통제해야 한다.
- **원자 연산(atomic operation)**: 공유 자원에 접근할 때 원자 연산을 이용하거나 원자적으로 정의된 연산을 이용해 연산 도중에 다른 스레드가 접근할 수 없게 한다.  여기서 원자 연산이란 연산했다와 연산 안 했다. 두가지만 존재하는 연산이다.
- **재진입성(reentrancy)**: 특정 함수를 하나의 스레드에서 실행 중일 때 다른 스레드가 해당 함수를 실행해도 각 스레드에 올바른 결과가 나올 수 있게 해야 한다.
- **스레드 지역 저장소(thread local storage)**: 각 스레드에서만 접근할 수 있는 저장소를 사용해서 공유되는 자원을 줄여야 한다.
---
## 1.2.10 IPC
> 프로세스는 고유한 메모리 영역을 갖기 때문에 프로세스 간 자원을 공유해야 할 때 IPC해야 한다.
> IPC는 Inter Process Communication의 약자로, 프로세스 간에 자원을 공유하는 방식을 나타낸다.

### IPC의 대표적인 종류
1. 공유 메모리(shared memory)
    - 프로세스 간에 공유 가능한 메모리를 구성해 자원을 공유하는 방식이다. 여러 프로세스에서 접근할 수 있으므로 동기화 문제가 발생할 수 있다.
2. 소켓(socket)
    - 네트워크 소켓을 이용하는 프로세스 간 통신으로, 외부 시스템과도 이용할 수 있다. 클라이언트-서버 구조로 자원을 주고받는다.
3. 세마포어(semaphore)
    - 접근하는 프로세스를 제어해 공유 자원을 관리한다.
4. 파이프(pipe)
    - FIFO 형태의 메모리인 파이프를 이용해 프로세스 간 자원을 공유하는 방식이다.
    - 파이프는 단방향 통신만 지원하므로 읽기 또는 쓰기 중 하나만 할 수 있다.
    - 따라서 양방향 통신을 하려면 읽기 파이프(read pipe)와 쓰기 파이프(write pipe)를 각각 생성해야 한다.
5. 메시지 큐(message queue)
    - FIFO 형태의 큐 자료구조를 사용해 프로세스 간 메시지를 주고받는 방식이다.

## 1.2.11 좀비 프로세스와 고아 프로세스

> 자식 프로세스가 종료되었지만 부모 프로세스가 자식 프로세스의 종료 상태를 회수하지 않았을 경우에 남겨진 자식 프로세스를 좀비 프로세스(Zombie Process)라고 한다.

### 좀비 프로세스 생성 과정
1. 자식 프로세스가 종료될 때 부모 프로세스에 SIGCHILD라는 시그널을 보낸다.
2. 부모 프로세스에서 wait() 함수(시스템콜)를 호출해 자식 프로세스의 상태 정보를 받고 자원을 회수한다.
3. 이때 자원회수에 실패하면 좀비 프로세스가 생기게 된다.
4. 좀비 프로세스가 쌓이면 자원이 낭비될 수 있다.

### 고아프로세스 대처방법
> 부모 프로세스가 자식 프로세스보다 먼저 종료되는 경우에 자식 프로세스를 고아 프로세스(orphan process)라고한다.
> 이럴 땐 자식 프로세스의 부모 PID를 init 프로세스(부팅 시 가장 먼저 실행되는 프로세스)의 PID인 1로 바꿔준다.
> 이렇게 하면 고아프로세스의 부모 프로세스는 init 프로세스가 된다.
> 이후에 고아 프로세스가 작업을 종료하면 init 프로세스가 고아 프로세스의 자원을 회수해 좀비 프로세스가 되는 것을 방지할 수 있다.
> init 프로세스가 고아 프로세스를 입양한다고 생각하면 된다.
