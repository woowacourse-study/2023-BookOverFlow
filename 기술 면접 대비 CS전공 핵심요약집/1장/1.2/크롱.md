## 1.2 프로세스

### 1.2.1 프로세스와 스레드
- **프로세스**
    - 컴퓨터에서 실행 중인 하나의 프로그램을 의미한다.
    - 프로그램은 특정 작업을 수행하기 위한 명령어의 집합이다.
    - 프로세스는 OS에게 독립된 메모리 영역(코드, 데이터, 스택, 힙)을 할당받고, 다른 프로세스의 메모리 영역에 접근할 수 없다.

<br>

<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/de1b6c98-d217-4c4d-a74a-8d9f532f7f5c" width=400></center>

- 프로세스의 메모리 구조를 간단히 표현하면 다음과 같다.
    - 스택
        - 지역 변수, 함수의 매개변수, 반환되는 주소 값 등이 저장되는 영역이다.
        - 높은 주소 값에서 낮은 주소 값으로 메모리가 할당되며, 영역 크기는 컴파일 때 결정된다.
    - 힙 
        - 동적 메모리 할당이 일어나는 영역이다.
        - 낮은 주소 값에서 높은 주소 값으로 메모리가 할당되며, 영역 크기는 런타임에 결정된다.
    - 데이터
        - 전역 변수, 정적 변수, 배열, 구조체 등이 저장되는 영역이다.
        - 데이터 영역은 BSS(Block Stated Symbol) 영역과 데이터 영역으로 다시 나눌 수 있다.
        - BSS 영역은 초기화하지 않은 변수를, 데이터 영역은 초기화 한 변수를 저장한다.
    - 코드
        - 실행할 코드가 기계어로 컴파일되어 저장되는 영역으로 텍스트 영역이라고도 한다.    

    - 스택 영역과 힙 영역은 동적으로 메모리 할당이 가능해 두 영역 사이에 빈 공간이 존재한다.
    - 스택은 LIFO 방식, 힙 영역은 FIFO 방식을 사용한다.
    - 스택 오버플로우(스택 -> 힙 침범) or 힙 오버플로우(힙 -> 스택 침범)가 발생할 수 있다.

- **스레드**
    - 프로세스에서 실제로 실행되는 흐름의 단위를 의미한다.
    - 스레드는 프로세스 안에 존재하므로 프로세스의 메모리 공간을 이용하고, 지역 변수를 저장하는 스택 영역을 할당 받는다.
    - 전역 변수를 저장하는 힙 영역은 다른 스레드와 공유한다.
    - CPU 개수와 스레드 수가 일치할 때 병렬성이 극대화된다.
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/68640ccf-4860-4f5e-beef-2aed54b7a1a2" width=400></center>


### 사용자 레벨 스레드와 커널 레벨 스레드
- 커널에서 관리하는 자원을 보호하기 위해 내부적으로 사용자 모드와 커널 모드를 구분한다.
- 이와 마찬가지로 스레드도 스레드를 관리하는 주체에 따라 구분된다.
- 사용자 레벨 스레드는 사용자가 라이브러리를 이용해 생성 및 관리한다.
- 커널 레벨 스레드는 커널이 스레드를 생성 및 관리한다.

<br>

- 다대일 모델(many-to-one)
    - 사용자 레벨 스레드 n개에 커널 레벨 스레드 1개가 매핑되어 사용자 레벨 스레드를 관리한다.
    - 하나의 사용자 레벨 스레드에서 시스템 콜을 호출하면 나머지 사용자 레벨 스레드는 커널 레벨에 접근할 수 없기 때문에 멀티 코어의 병렬성을 이용할 수 없다.
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/e5e86f80-54ea-4294-b826-d209fd63eaf5" width=300></center>


<br>

- 일대일 모델(one-to-one)
    - 사용자 레벨 스레드 1개에 커널 레벨 스레드 1개가 매핑된다.
    - 다대일 모델의 단점을 보완할 수 있다.
    - 사용자 레벨 스레드 수만큼 커널 레벨 스레드가 생성되기 때문에 성능 저하가 일어날 수 있다.
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/f2e355ea-4324-4ca1-9537-a1f3c19cf1b4" width=300></center>

<br>

- 다대다 모델(many-to-many)
    - 사용자 레벨 스레드 n개에 커널 레벨 스레드 m개가 매핑된다.
    - 커널 레벨 스레드의 수는 사용자 레벨 스레드의 수 이하다.
    - 다대일 모델과 일대일 모델의 장점을 포함하지만, 구현이 어렵다는 단점이 있다.
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/1afef146-2edf-4268-860a-1a2fe3cb8312" width=300></center>


<br><br>

### 1.2.2 PCB
- 프로세스를 제어하기 위해 프로세스의 정보를 저장하는 공간이다.
- 프로세스와 관련된 모든 정보를 가지고 있다.
- 프로세스의 현재 상태, 프로세스 고유 PID, 부모 프로세스의 PID, 자식 프로세스의 PID, 다음에 실행할 명령어의 주소인 PC, 프로세스의 우선순위, 메모리 제한 등을 저장한다.
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/5f059eba-4cd3-47fb-98f4-2aa43d666cfe" width=200></center>


<br><br>

### 1.2.3 프로세스의 생성
- Directed
    - 할당할 메모리를 확보한다.
    - 코드를 복사해온다. + 콜 스택을 생성
    - PCB를 생성한다.
    - CPU를 할당 받으면 실행할 수 있는 상태가 되는 경우 준비 상태로 바꾸고 준비큐에 넣는다.
    - PID가 1인 프로세스는 이와 같은 방법으로 만든다.

- Cloning(복제)
    - 기존 프로세스에서 `fork()` 함수를 호출해 생성한다.
    - `fork()` 함수는 텍스트, 데이터, 스택, PCB, 커널스택 등 모두 Copy하며 PID와 같이 반드시 필요한 것들만 수정한다.
    - 기존 프로세스를 부모 프로세스, 복사된 프로세스를 자식 프로세스라고 한다.
    - 부모 프로세스에서 `fork()` 함수를 호출하면 부모 프로세스는 자식의 PID를, 자식 프로세스는 0을 반환한다.
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/5ac4da26-9eba-4bc6-a7ad-ad8bc35b3bc9" width=300></center>

<br>

<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/d0b10243-7365-425d-b26d-7f4cd862de84" width=600></center>

<br>

> 운영 체제가 프로세스를 종료하는 경우
- 프로세스가 exit()을 호출해 정상 종료 하는 경우
- 프로세스의 실행 시간 또는 특정 이벤트 발생을 기다리는 시간이 제한된 시간을 초과한 경우
- 프로세스가 파일 검색 또는 입출력에 실패하는 경우
- 오류가 발생하거나 메모리 부족 등이 발생하는 경우

<br>

> 부모 프로세스가 자식 프로세스를 종료 시킬 수 있는 경우
- 자식 프로세스가 할당된 자원을 초과해 사용할 때
- 자식 프로세스에 할당된 작업이 없을 때

<br><br>

### 1.2.4 프로세스 상태도
- 프로세스는 CPU에 의해 생성되고 소멸하는 과정을 거친다.
- 프로세스는 생성, 준비, 대기, 실행, 종료 5가지 상태로 존재한다.
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/94b14a3b-ef76-425a-9746-5a98b0854a2e" width=500></center>

- 생성 : 프로세스가 PCB를 가지고 있지만 OS로부터 승인 받기 전
- 준비 : OS로부터 승인받은 후 준비 큐에서 CPU 할당을 기다림
- 실행 : 프로세스가 CPU를 할당받아 실행함
- 대기 : 프로세스가 입출력이나 이벤트 발생을 기다려야 해서 CPU 사용을 멈추고 기다림
- 종료 : 프로세스 실행을 종료함

<br>

- 프로세스는 한 상태에서 다른 상태로 다음과 같이 변화한다.
- 생성 -> 준비 : 생성 상태의 프로세스가 OS로부터 승인을 받아, 준비 상태의 프로세스가 모여 있는 준비 큐에 추가됨
- 준비 -> 실행 : 준비 큐에 있는 프로세스 중 우선순위가 높은 프로세스가 디스패치되어 실행됨
- 실행 -> 준비 : CPU 독점을 방지하기 위해 타임아웃 되어 준비 상태로 변경됨
- 실행 -> 대기 : 입출력 또는 이벤트 떄문에 대기 상태로 변경됨
- 대기 -> 준비 : 입출력 또는 이벤트가 완료되어 준비 상태로 변경됨
- 실행 -> 종료 : 실행중인 프로세스가 정상적으로 끝나 종료 상태로 변경됨

<br><br>

### 1.2.5 멀티 프로세스와 멀티 스레드
- **동시성**(Concurrency)
    - 하나의 코어에서 여러 작업을 번갈아 가며 처리하는 방식이다.
    - CPU는 한 번에 하나의 프로세스만 처리할 수 있기 때문에 여러 작업을 번갈아가며 처리한다.
    - **CPU에서 여러 작업을 번갈아 가면서 처리하기 위해 처리 중인 작업을 교체하는 것을 컨텍스트 스위칭**이라고 한다.
    - 여러 작업이 동시에 처리되는 것처럼 보이는 것이다.
- **병렬성**(Parallelism)
    - CPU가 여러 개 있어 각 CPU에서 각 작업을 동시에 처리하는 방식이다.
    - 물리적인 시간 관점에서 동시에 여러 작업이 처리된다.

<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/784e84cf-a7b1-4cda-aff7-9d4ae7d7db9d" width=500></center>

<br><br>

- 멀티 프로세스
    - 응용 프로그램 하나를 여러 프로세스로 구성하는 것을 말한다.
    - 멀티 프로세스 환경에서는 하나의 프로세스가 죽어도 다른 프로세스에 영향을 주지 않는다. 때문에 더 안정적이다.
    - 시간과 메모리 공간을 많이 사용한다는 단점이 있다.
    - CPU는 한 번에 하나의 작업만 처리할 수 있기 때문에 여러 프로세스를 처리하기 위해서는 컨텍스트 스위칭이 발생한다. (오버헤드)
    - 프로세스 간 고융해야 하는 자원이 있는 경우 IPC(Inter Process Communication)를 통해야 한다. 이는 공유 메모리를 직접 참조하는 것보다 비효율적이다.
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/da312fe6-a3e2-4dff-ad36-7f79d1b27a08" width=500></center>

<br>

- 멀티 스레드
    - 스레드를 여러 개 생성해 스레드들이 각자 다른 작업을 처리하는 것을 의미한다.
    - 스레드는 힙, 데이터, 코드 영역을 공유하기 때문에 컨텍스트 스위칭시 오버헤드가 적고 IPC를 사용하지 않아도 된다.
    - 프로세스를 여러 개 생성하는 것보다 자원을 효율적으로 사용할 수 있다.
    - 프로세스 자원 공유보다 시스템 처리 비용이 적고 프로그램 응답 시간도 단축된다.
    - 메모리 영역을 다른 스레드와 공유하기 때문에 **공유 자원에 대한 동기화**가 필수다.
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/eb0c63db-1411-4539-b055-7f5add5c9b17" width=300></center>

<br><br>

### 1.2.6 컨텍스트 스위칭
- 인터럽트
    - CPU에서 프로세스를 처리하다 입출력 관련 이벤트가 발생하거나 예외 상황이 발생할 때 이에 대응할 수 있게 CPU에 처리를 요청하는 것을 말한다.
    - 입출력이 발생할 때, CPU 사용 시간이 만료되었을 때, 자식 프로세스를 생성했을 때 발생한다.
    - I/O 디바이스는 CPU보다 느리고 CPU는 디바이스를 기다려야 한다. 이는 곧 CPU 자원의 낭비를 의미한다.
    - CPU의 utilization을 높이기 위해 필요하며, 커널로 들어가기 위한 진입점이다.
- 멀티 프로세스를 처리하려면 CPU 스케쥴러에 의해 인터럽트가 발생하며 컨텍스트 스위칭이 발생한다.
- 컨텍스트 스위칭의 오버헤드는 PCB 업데이트, 스케쥴링 오버헤드, 캐시 오염이 있다.
- 여기서 **컨텍스트는 CPU가 처리하는 프로세스의 정보를 의미**한다.
- **멀티 프로세스 환경에서 CPU가 처리 중인 프로세스의 정보를 바꾸는 것이 컨텍스트 스위칭이다.**

<br><br>

<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/1d7b02e4-745e-4f73-a83a-8a8bbd3706d2" width=500></center>

- 처리중인 프로세스를 P1, 다음에 처리해야 할 프로세스를 P2라고 하자.
1. CPU가 P1을 처리하던 도중 인터럽트가 발생한다. 
2. P1은 idle해지고 스케쥴러는 레지스터에 있는 처리중인 프로세스의 정보를 P1의 PCB에 저장한다.
3. P2의 PCB에 있는 정보를 가져와 레지스터에 로드하고 CPU는 P2를 처리한다.
4. P1을 PCB에 저장하고 P2를 레지스터에 로드하는 동안 CPU 역시 idle해지는데 이를 오버헤드라고 한다.

<br><br>

- 멀티 스레드를 처리할 때도 컨텍스트 스위칭이 일어나지만 스레드는 힙, 데이터, 코드 영역을 공유하기 때문에 오버헤드가 적다.
- CPU에서 처리중인 프로세스가 중간에 변경되어도 이전에 실행하던 코드를 이어서 실행할 수 있는 이유는 PCB에 프로그램 카운터와 스택 포인터 값이 저장되어 있기 때문이다.
- 프로그램 카운터는 다음에 수행할 명령어의 주소가 저장되어 있다.
- 스택 포인터는 스택 영역에서 데이터가 채워진 가장 높은 주소를 가리킨다.

<br><br>

> Call Stack : execution sequence를 잡기 위해 사용한다.
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/5c4d547c-fbb4-4dd0-ac51-5c144ade2929" width=700></center>

- (b) : 4100라인에서 Proc1이 call되었기 때문에 스택에는 4100 다음의 주소인 4101이 저장된다.(돌아와야 하는 주소)
- (c) : 4600라인에서 Proc2가 call되었기 때문에 스택에 4600 다음 주소인 4601이 저장된다.
- (d) : Proc2가 끝나면 4601라인으로 돌아간다.
- (e) : 4650라인에서 Proc2가 call되었기 때문에 스택에 4650 다음 주소인 4651이 저장된다.
- (f) : Proc2가 끝나면 4651라인으로 돌아간다.
- (g) : Proc1이 끝나면 4101라인으로 돌아간다.

<br><br>

### 1.2.7 프로세스 동기화
- 경쟁 상태
    - 여러 프로세스 또는 스레드에서 하나의 공유 자원에 접근하는 경우 접근하는 순서에 따라 결과가 달라질 수 있다. 
    - 공유 자원에 동시에 접근해 경쟁하는 상태라고 해서 경쟁 상태(race condition)이라고 한다.

- 임계 영역
    - 공유 자원에 접근할 수 있고 접근 순서에 따라 결과가 달라지는 코드 영역을 임계 영역(critical section)이라고 한다.
    - 임계 영역에서 경쟁 상태가 발생하는 것을 방지하기 위해서는 **여러 프로세스가 공유 자원에 접근해도 데이터의 일관성이 유지되도록 프로세스 동기화**를 해야한다.
    - 임계 영역에서 여러 접근이 동시에 발생하는 것을 방지하려면 다음 3가지 조건을 충족해야 한다.
        - 상호배제 기법(mutual exclusive) : 어떤 프로세스가 임계 영역을 실행 중일 때 다른 프로세스가 임계 영역에 접근할 수 없다. 상호배제 기법으로는 뮤텍스와 세마포어가 있다.
        - 진행(progress) : 임계 영역을 실행 중인 프로세스가 없을 때 다른 프로세스가 임계 영역을 실행한다.
        - 한정된 대기(bounded waiting) : 임계 영역에 접근을 요청했을 때 무한한 시간을 기다리지 않는다.
- 뮤텍스
    - 락을 가진 프로세스만이 공유 자원에 접근할 수 있게 하는 방법이다.
    - 임계 영역에 먼저 접근한 프로세스가 임계 영역에 락을 걸면 다른 프로세스들은 해당 프로세스가 락을 해제하기 전까지 대기해야 한다.
    - 기본적으로 뮤텍스는 non busy wait 방식이며 HW적 지원을 통해 busy wait 방식을 이용할 수 있다.
    - 임계 영역에 접근하지 못한 프로세스는 락을 얻기 위해 기다리는 동안 락이 풀렸는지 반복문을 돌면서 확인한다. 이를 바쁜 대기(busy waiting)의 한 종류인 스핀락이라고 한다.
    - 스핀락은 락을 얻기 위해 프로세스가 반복문을 돌면서 기다리는 것을 의미한다.
    - 프로세스가 대기 상태가 되지 않고 반복문을 돌면서 자원의 사용 가능 여부를 확인하므로 프로세스가 빠르게 교체될 수 있다.
- 세마포어
    - 공유 자원에 접근할 수 있는 프로세스의 수를 정해 접근을 제어하는 방법이다.
    - 임계 영역에 접근할 수 있는 키 n개를 지정하고 이 중 하나를 가진 프로세스만이 임계 영역에 접근하게 하는 방식이다.
    - 이 방식은 공유 자원에 접근한 프로세스가 접근을 해제하면 다른 프로세스가 접근할 수 있도록 신호를 보낸다.(시그널링 매커니즘)

<br><br>

> 동기, 비동기, 블로킹, 넌블로킹
- 동기와 비동기는 작업 순서에 대한 개념이고, 블로킹과 넌블로킹은 작업을 위한 대기를 구분하는 개념이다.
- 동기 : 여러 작업을 처리할 때 작업 순서를 보장한다.
- 비동기 : 여러 작업을 처리할 때 작업 순서를 보장하지 않는다.
- 블로킹 : 작업을 수행할 때 대기할 수 있다는 것을 의미하며 작업 순서를 보장하지 않는다. (작업 순서가 항상 보장되지 않음을 의미한다.)
- 넌블로킹 : 작업을 시작하면 대기 없이 수행하는 것을 의미한다.

<br><br>

### 1.2.8 교착 상태
- **2개 이상의 프로세스가 각각 자원을 가지고 있으면서 서로의 자원을 요구하며 기다리는 상태를 교착 상태(deadlock)**라고 한다.
- 4가지 필요 충분 조건이 있다.
    - 상호배제(mutual exclusion) : 하나의 공유 자원에 하나의 프로세스만 접근할 수 있다.
    - 점유대기(hold and wait) : 프로세스가 최소 하나의 자원을 점유하고 있는 상태에서 추가로 다른 프로세스에서 사용 중인 자원을 점유하기 위해 대기한다.
    - 비선점(non-preemption) : 다른 프로세스에 할당된 자원을 뺏을 수 없다.
    - 환형대기(circular wait) : 프로세스가 자신의 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구한다.
- 교착 상태를 막으려면 4가지의 필요 충분 조건 중 한 가지를 제거하면 된다.
    - 상호배제 부정 : 여러 프로세스가 동시에 하나의 공유 자원을 사용할 수 있게 한다.
    - 점유대기 부정 : 프로세스가 실행되기 전 필요한 모든 자원을 할당함으로써 프로세스 대기를 없앤다. 또는 프로세스가 자원을 점유하지 않은 상태에서만 자원을 요구하게 한다.
    - 비선점 부정 : 자원을 점유한 프로세스가 다른 자원을 요구할 때 점유한 자원을 반납하게 한다.
    - 환형 대기 부정 : 자원을 선형 순서로 정렬해 고유 번호를 할당한다. 그리고 각 프로세스에서 요구할 수 있는 방향을 정해 한쪽 방향으로만 자원을 요구하게 한다.

<br><br>

<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/7affc7e2-00ee-486b-bea8-dca92dd78d6f" width=300></center>

- 식사하는 철학자 문제
    - 5명의 철학자와 5개의 포크가 있다.
    - 철학자는 식사를 하기 위해 2개의 포크를 사용해야 한다.
    - 철학자는 다른 철학자에게 말을 할 수 없으며, 번갈아가며 각자 식사하거나 생각하는 것만 가능하다.
    - 식사를 하기 위해서는 왼쪽과 오른쪽의 인접한 철학자가 모두 식사를 하지 않고 생각하고 있어야만 한다.
    - 식사를 마치고 나면, 왼손과 오른손에 든 포크를 다른 철학자가 쓸 수 있도록 내려놓아야 한다.
- 다음과 같은 이유 때문에 문제가 생긴다.
    - 일정 시간 생각을 한다.
    - 왼쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.
    - 오른쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.
    - 양쪽의 포크를 잡으면 일정 시간만큼 식사를 한다.
    - 오른쪽 포크를 내려놓는다.
    - 왼쪽 포크를 내려놓는다.
    - 다시 1번으로 돌아간다.

<br><br>

### 1.2.9 스레드 안전
- 멀티 스레드 환경에서 하나의 변수, 함수, 객체에 스레드 여러 개가 동시에 접근해도 문제가 없음을 의미한다.
- 스레드 안전을 위해 다음과 같은 조건을 지켜야 한다.
    - 상호배제 : 공유 자원에 접근해야 할 때 뮤텍스 또는 세마포어와 같은 상호 배제 기법을 사용해 접근을 통제해야 한다.
    - 원자연산 : 공유 자원에 접근할 때 원자 연산을 이용하거나 원자적으로 정의된 연산을 이용해 연산 도중 다른 스레드가 접근할 수 없게 한다. 여기서 원자 연산이란 연산했다와 안했다 만 존재하는 연산을 말한다.
    - 재진입성 : 특정 함수를 하나의 스레드에서 실행 중일 때 다른 스레드가 해당 함수를 실행해도 각 스레드에 올바른 결과가 나올 수 있게 해야 한다.
    - 스레드 지역 저장소 : 각 스레드에서만 접근할 수 있는 저장소를 사용해서 공유되는 자원을 줄여야 한다.

<br><br>

### 1.2.10 IPC
- 프로세스는 독립적인 메모리 영역을 갖기 때문에 프로세스간 자원을 공유하기 위해서는 IPC를 사용해야 한다.
- IPC는 Inter Process Communication의 약자로, 프로세스 간에 자원을 공유하는 방식을 나타낸다.
- 공유 메모리(shared memory)
    - 프로세스 간 공유 가능한 메모리를 구성해 자원을 공유하는 방식이다.
    - 여러 프로세스에서 접근할 수 있기 때문에 동기화 문제가 발생할 수 있다.
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/ea71b458-3ba3-4260-83b7-bfb3621fefa1" width=500></center>

- 소켓(socket)
    - 네트워크 소켓을 이용하는 프로세스 간 통신으로 외부 시스템과도 이용할 수 이다.
    - 클라이언트와 서버 구조로 자원을 주고 받는다.
- 세마포어(semaphore)
    - 프로세스를 제어해 공유 자원을 관리한다.
- 파이프(pipe)
    - FIFO 형태의 메모리인 파이프를 이용해 프로세스 간 자원을 공유하는 방식이다.
    - 파이프는 단방향 통신만 지원하기 때문에 읽기 또는 쓰기 중 하나만 할 수 있다.
    - 양방향 통신을 위해서는 읽기, 쓰기 파이프가 각각 필요하다.
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/b6befbb8-5dc1-4c1a-98e8-cc32a701e8a4" width=500></center>

- 메시지 큐(message queue)
    - FIFO 형태의 큐 자료구조를 사용해 프로세스 간 메시지를 주고받는 형식이다.
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/84a3c5d2-cb84-423b-8275-9167792678c7" width=400></center>

<br><br>

### 1.2.11 좀비 프로세스와 고아 프로세스
- 좀비 프로세스
    - 프로세스가 종료되었음에도 OS에 PCB가 남아있는 경우를 말한다.
    - 자식 프로세스가 종료되었지만 부모 프로세스가 자식 프로세스의 종료 상태를 회수하지 않은 경우 남겨진 자식 프로세스를 좀비 프로세스라고 한다.
    - 자식 프로세스가 종료될 때 부모 프로세스에 SIGCHLD라는 시그널을 보내면 부모 프로세스에서 `wait()` 함수를 호출해 자식 프로세스의 상태 정보를 받고 자원을 회수한다.
    - 자원 회수에 실패하면 좀비 프로세스가 된다.
    - 좀비 프로세스가 많아지면 자원이 낭비될 수 있다.
    - Reaper Process가 좀비 프로세스를 수거해준다.
- 고아 프로세스
    - 부모 프로세스가 자식 프로세스보다 먼저 종료되는 경우 남겨진 자식 프로세스를 고아 프로세스라고 한다.
    - init 프로세스로 입양된다.
    - 자식 프로세스의 부모 PID를 init 프로세스의 PID인 1로 바꿔주어 고아 프로세스의 부모 프로세스를 init 프로세스로 바꾼다.
    - 이후 고아 프로세스가 작업을 종료하면 init 프로세스가 고아 프로세스의 자원을 회수하여 좀비 프로세스가 되는 것을 방지할 수 있다.

<br><br>

### Trace of Process
<center><img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/2c3462b1-6382-4396-82ef-cfa712c54538" width=800></center>

1. 현재 PC가 5000번째를 가리키고 있어 ++하면서 instruction을 수행한다.
2. 5005번째를 수행함과 동시에 할당된 time slice를 모두 사용하여 time out이 된다. (커널의 schedule 함수 호출 : 100번째에 있는 Dispatcher를 의미)
3. 커널의 Dispatcher 코드가 실행된다. 리턴 값은 다른 프로세스다. (B or C, B로 가정)
4. Process B를 수행해야 해서 8000번부터 ++하면서 insturction을 수행한다.
5. 중간에 I/O Request가 발생한다. 이는 system call을 의미한다. (커널의 schedule 함수가 호출된다.)
6. 커널의 Dispatcher 코드가 실행된다. 리턴 값은 다른 프로세스다. (C)
7. Process C를 수행해야 해서 12000번부터 ++하면서 insturction을 수행한다.
8. 12005번째를 수행함과 동시에 할당된 time slice를 모두 사용하여 time out이 된다. (커널의 schedule 함수 호출)
9. 5005번째에서 끝난 Process A는 5006번째부터 다시 ++하면서 instruction을 수행한다.
10. 5011번째를 수행함과 동시에 할당된 time slice를 모두 사용하여 time out이 된다. 
11. Process B는 아직 I/O Request가 끝나지 않아 C가 다시 실행된다.
12. 12005번째에서 끝난 Process C는 12006번째부터 다시 ++하면서 instruction을 수행한다.
