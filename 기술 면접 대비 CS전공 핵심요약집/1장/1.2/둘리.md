# 운영체제 1.2

# 프로세스 (process) vs 스레드 (thread)

## 프로세스

하나의 프로그램

OS로부터 독립된 메모리 영역을 할당 받으며, 다른 프로세스의 메모리 영역에 접근 불가

### 메모리 영역 구조

![메모리 영역 구조](https://github.com/woowacourse-study/2023-cs-study/assets/15646373/549f20c8-b537-4b76-b054-fb025188c3d1)

1. **스택(stack) : 지역 변수, 함수 매개변수**
    - 높은 주소 값 → 낮은 주소 값으로 메모리 할당 (LIFO)
    - 컴파일 때 영역 크기 결정
    - 스택 오버 플로 : 스택이 힙 영역 침범
2. **힙(heap) : 사용자 동적 할당**
    - malloc()으로 할당되는 영역
    - 낮은 주소 값 → 높은 주소 값으로 메모리 할당 (FIFO)
    - 런타임 때 영역 크기 결정
    - 힙 오버플로 : 힙이 스택 영역 침범
3. **데이터(data) : 전역 변수, 정적 변수, 배열, 구조체**
    - BSS(Block Stated Symbol) 영역 :  초기화하지 않은 변수
    - 데이터 영역 : 초기화한 변수
4. **코드(code) : 실행 코드 (기계어)**
    - == 텍스트(text) 영역
    - 실행할 코드가 기계어로 컴파일되어 저장되는 영역

## 스레드

프로세스는 한 개 이상의 스레드를 갖는다

프로세스에서 실제로 실행되는 흐름의 단위

프로세스의 메모리 공간을 이용, 지역 변수를 저장하는 스택 영역만을 할당 받음

힙은 다른 스레드와 공유

### 사용자 레벨 스레드 vs 커널 레벨 스레드

사용자 레벨 스레드(user-level thread) : 사용자가 라이브러리를 이용해 생성 및 관리

커널 레벨 스레드(kernel-level thread) : 커널이 스레드를 생성 및 관리

1. 다대일 모델 (many-to-one model)
    - 사용자 레벨 스레드 n : 커널 레벨 스레드 1
    - 사용자 레벨에서 스레드 관리
    - 하나의 사용자 레벨 스레드에서 시스템 콜을 호출하면 나머지 사용자 레벨 스레드는 커널 레벨에 접근 불가 → 멀티 코어의 병렬성 이용 불가
2. 일대일 모델 (one-to-one model)
    - 사용자 레벨 스레드 1 : 커널 레벨 스레드 1
        - 다대일 모델 단점 해결
        - 사용자 레벨 스레드 수만큼 커널 레벨 스레드가 생성 → 성능 저하 일어날 수도
3. 다대다 모델 (many-to-many model)
    - 사용자 레벨 스레드 n : 커널 레벨 스레드 m (m ≤ n)
    - 다대일, 일대일 모델 장점 포함
    - 구현이 어려움

# PCB (Process Control Block)?

![PCB 구조](https://github.com/woowacourse-study/2023-cs-study/assets/15646373/4022cd88-4e1d-410a-b864-3710d599f4c0)

프로세스를 제어하기 위해 프로세스 정보를 저장

프로세스의 현재 상태, PID, 부모 프로세스의 PID, 자식 프로세스의 PID, PC, 프로세스의 우선순위, 메모리 제한 등 저장

# 프로세스의 생성

기존 프로세스에서 `fork()` —(복사)—> 새로운 프로세스 생성

기존 프로세스 : 부모 프로세스

새로운 프로세스 : 자식 프로세스

**fork() 함수 리턴 값의 차이**

- 부모 프로세스 : 자식 프로세스의 PID
- 자식 프로세스 : 0

### 운영체제가 프로세스를 종료하는 경우

- 프로세스가 운영체제의 종료 서비스(exit())를 호출해 정상 종료하는 경우
- 프로세스의 실행 시간 또는 특정 이벤트 발생을 기다리는 시간이 제한된 시간을 초과한 경우
- 프로세스가 파일 검색 또는 입출력에 실패하는 경우
- 오류가 발생하거나 메모리 부족 등이 발새앟는 경우

### 부모 프로세스가 자식 프로세스를 종료시킬 수 있는 경우

- 자식 프로세스가 할당된 자원을 초과하여 사용할 때
- 자식 프로세스에 할당된 작업이 없을 때

# 프로세스 상태도

![프로세스 상태도](https://github.com/woowacourse-study/2023-cs-study/assets/15646373/588d9628-0219-4c2a-96c0-ed48c3e42651)

- **생성(new)** : 프로세스가 PCB를 가지고 있지만 OS로부터 승인(admit)받기 전
    - admit? : CPU를 제외한 다른 자원이 준비되어 해당 프로세스가 준비 상태가 될 수 있도록 OS가 허락하는 것
- **준비(ready)** : 승인받은 후 준비 큐에서 CPU 할당을 기다림
- **실행(running)** : 프로세스가 CPU를 할당받아 실행
- **대기(waiting)** : 프로세스가 입출력이나 이벤트 발생을 기다려야해서 CPU 사용을 멈추고 기다림
- **종료(terminated)** : 프로세스 실행 종료

### 상태 변화

- 생성 → 준비 : 생성 상태의 프로세스가 OS로부터 승인을 받아, 준비 큐(ready queue)에 추가
- 준비 → 실행 : 준비 큐에 있는 프로세스 중 우선순위가 높은 프로세스가 dispatch되어 실행됨
    - dispatch? : 프로세스에 CPU 자원을 할당해 해당 프로세스가 준비 상태에서 실행 상태가 되는 것
- 실행 → 준비 : CPU 독점을 방지하기 위해 timeout되어 준비 상태로 변경
- 실행 → 대기 : 입출력 or 이벤트 때문에 대기 상태로 변경
- 대기 → 준비 : 입출력 or 이벤트가 완료되어 준비 상태로 변경
- 실행 → 종료 : 실행 중인 프로세스가 정상적으로 끝나서 종료 상태로 변경

# 멀티 프로세스와 멀티 스레드

- **동시성** : 싱글 코어에서 여러 작업을 번갈아가며 처리하는 방식
    - Context Switching : 처리 중 작업 교체하는 것
- **병렬성** : 멀티 코어에서 각 CPU에서 각 작업을 동시에 처리하는 방식

## 멀티 프로세스

응용 프로그램 하나를 여러 프로세스로 구성하는 것 → 한 프로세스가 죽어도 다른 프로세스에 영향을 주지 않음

응용 프로그램을 프로세스 하나로 구성하는 것보다 여러 개로 구성하는 것이 안정적

CPU는 하나의 작업만 처리할 수 있어서 여러 프로세스를 처리하려면 Context Switching을 해야하는데, 기존 프로세스가 할당 받은 메모리 영역을 다른 프로세스에서 사용할 수 있게 교체하면서 발생하는 시간과 메모리 → 오버헤드(overhead)

프로세스 간에 공유할 자원이 있다면? → IPC(Inter Process Communication)을 통해

공유할 메모리를 직접 참조하는 것보다 비효율적

## 멀티 스레드

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/15646373/812abf1c-46ba-43ff-8e59-f5214690d6de" width="500" >

스레드를 여러 개 생성하여 스레드들이 각자 다른 작업을 처리하는 것

**스레드 간에 힙, 데이터, 코드 영역 공유**

- 멀티 프로세스의 단점 보완
    - Context Switching 때 오버헤드가 적게 발생
    - IPC 사용 안해도 됨
- 코드, 데이터, 힙 영역을 다른 스레드와 함께 사용 → 공유 자원에 대한 동기화 필수
- 스레드에 문제 생기면 프로세스 내 다른 스레드에 영향을 미칠 수 있음

# Context Switching

**Interrupt** : 입출력 관련 이벤트가 발생하거나 예외 상황이 발생할 때 대응할 수 있게 CPU에 처리를 요청하는 것

ex) 입출력 발생, CPU 사용 시간 만료, 자식 프로세스 생성

CPU는 하나의 프로세스만 처리 가능하므로 멀티 프로세스 처리를 위해서는 CPU 스케쥴러에 의해 Interrupt가 발생하며 Context Switching

Context : CPU가 처리하는 프로세스 정보

멀티 프로세스 환경에서 프로세스 정보를 바꾸는 것 → Context Switching

![Context Switching 과정](https://github.com/woowacourse-study/2023-cs-study/assets/15646373/5551e62c-3b29-4be7-8f50-3125ec12026a)

기존 Process 정보를 PCB에 저장, PCB에 저장되어있던 정보를 로드하는 동안 CPU는 아무 일도 못함

어떤 처리를 하는데 간접적인 처리 시간, 메모리가 소요되는 경우 → `오버헤드가 발생한다`

멀티 스레드를 처리할 때도 Context Switching이 이루어지지만, 프로세스와 달리 힙, 데이터, 코드 영역을 공유하기 때문에 레지스터에 저장하고 로드할 데이터가 상대적으로 적음
→ 프로세스 Context Switching보다 시간과 메모리 자원을 적게 사용

**CPU에서 처리 중인 프로세스가 중간에 변경되어도 이전에 실행하던 코드를 이어서 실행할 수 있는 이유**

- PCB에 Program Counter와 Stack Pointer 값이 저장되어 있기 때문에!
    - PC : 프로세스가 이어서 처리해야하는 명령어의 주소값
    - SP : 스택 영역에서 데이터가 채워진 가장 높은 주소 값

# 프로세스 동기화

## 경쟁 상태 (race condition)

자원에 접근하는 순서에 따라 결과 값이 달라질 수 있음 → 공유 자원에 동시에 접근해 경쟁하는 상태

해결하려면 프로세스 동기화

## 임계 영역 (critical section)

공유 자원에 접근할 수 있고 접근 순서에 따라 결과가 달라지는 코드 영역

임계 영역에서 경쟁 상태가 발생하는 것을 방지하기 위해, 여러 프로세스가 공유 자원에 접근해도 데이터의 일관성이 유지되도록 프로세스 동기화!

### **임계 영역에 여러 접근이 동시에 발생하는 것을 방지하는 3가지 조건**

1. **상호배제 기법(mutual exclusive)** : 어떤 프로세스가 임계 영역을 실행 중일 때 다른 프로세스가 임계 영역에 접근 불가
    - **뮤텍스** : lock을 가진 프로세스만이 공유 자원에 접근할 수 있게 하는 방법
        - 락킹 매커니즘(locking mechanism) : 임계 영역에 접근한 프로세스가 임계 영역에 락을 걸어서
        - 임계 영역에 접근하지 못한 프로세스는 반복문 돌면서 락이 풀렸는지 계속 확인 → 바쁜 대기(busy waiting)의 한 종류인 spinlock
        - 바쁜 대기 : 프로세스가 공유 자원에 접근할 수 있는 권한을 얻을 때까지 확인하는 과정
    - **세마포어** :  공유 자원에 접근할 수 있는 프로세스의 수를 정해 접근을 제어하는 방법
        - 시그널링 매커니즘(signaling mechanism) : 공유 자원에 접근한 프로세스가 접근을 해제하면 다른 프로세스가 접근할 수 있도록 신호를 보낸다고 해서
2. **진행(progress)** : 임계 영역을 실행 중인 프로세스가 없을 때 다른 프로세스가 임계 영역 실행
3. **한정된 대기(bounded waiting)** : 임계 영역에 접근을 요청했을 때 무한한 시간을 기다리지 않음

### 동기 vs 비동기, 블로킹 vs 넌블로킹

[[그림 출처]](https://inpa.tistory.com/entry/👩%E2%80%8D💻-동기비동기-블로킹논블로킹-개념-정리)

![동기,비동기/블로킹,넌블로킹](https://github.com/woowacourse-study/2023-cs-study/assets/15646373/153b20cf-6fda-4baa-ab5b-8352d4a0324d)

- **동기(synchronization)** : 여러 작업을 처리할 때 작업 순서 보장
- **비동기(asynchronization)** : 여러 작업을 처리할 때 작업 순서를 보장하지 않음
- **블로킹(blocking)** : 작업을 수행할 때 대기할 수 있다는 것을 의미하며 *작업 순서를 보장하지 않음* <<< 맞음?
- **넌블로킹(non-blocking)** : 작업을 시작하면 대기 없이 수행한다는 것을 의미

# 교착 상태 (deadlock)

2개 이상의 프로세스가 각각 자원을 가지고 있으면서 서로의 자원을 요구하며 기다리는 상태

### **교착 상태가 발생하는 4가지 필요 충분 조건**

1. **상호배제(mutual exclusion)** : 하나의 공유 자원에 하나의 프로세스만 접근 가능
    - ↔ 여러 프로세스가 동시에 하나의 공유 자원을 사용할 수 있게 함
2. **점유와 대기(hold and wait)** : 프로세스가 최소 하나의 자원을 점유하고 있는 상태에서 추가로 다른 프로세스에서 사용 중인 자원을 점유하기 위해 대기
    - ↔ 프로세스가 실행되기 전에 필요한 모든 자원을 할당함으로써 프로세스 대기를 없앰
    - ↔ 프로세스가 자원을 점유하지 않은 상태에서만 자원을 요구하게 함
3. **비선점(non-preemption)** : 다른 프로세스에 할당된 자원을 뺏을 수 없음
    - ↔ 자원을 점유한 프로세스가 다른 자원을 요구할 때 점유한 자원을 반납하게 함
4. **환형 대기(circular wait)** : 프로세스가 자신의 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원 요구
    - ↔ 자원을 선형 순서로 정렬하여 고유 번호 할당, 각 프로세스에서 요구할 수 있는 번호의 방향을 정해 한쪽 방향으로만 자원을 요구하게 함

교착 상태를 막으려면 이 4가지 필요 충분 조건 중 하나를 제거하면 됨

# 스레드 안전 (thread safe)

멀티 스레드 환경에서 하나의 변수, 함수, 객체에 스레드 여러 개가 동시에 접근해도 문제가 없음

### 스레드 안전을 위한 조건

1. **상호배제(mutual exclusive)** : 공유 자원에 접근해야할 때 뮤텍스 or 세마포어와 같은 상호배제 기법을 통해 접근 통제
2. **원자 연산(atomic operation)** : 공유 자원에 접근할 때 원자 연산 이용 or 원자적으로 정의된 연산을 이용해 연산 도중에 다른 스레드가 접근할 수 없게 함
    - 원자 연산 : ‘연산 했다’, ‘연산 안했다’ 두 가지만 존재하는 연산
3. **재진입성(reentrancy)** : 특정 함수를 하나의 스레드에서 실행 중일 때 다른 스레드가 해당 함수를 실행해도 각 스레드에 올바른 결과가 나올 수 있게 해야함
4. **스레드 지역 저장소(thread local storage)** : 각 스레드에서만 접근할 수 있는 저장소를 사용해서 공유되는 자원을 줄여야함

# IPC (Inter Process Communication)

프로세스 간에 자원을 공유하는 방식

### 공유 메모리(shared memory)

프로세스 간에 공유 가능한 메모리를 구성해 자원 공유

여러 프로세스에서 접근할 수 있으므로 동기화 문제 발생 가능

### 소켓(socket)

네트워크 소켓을 이용하는 프로세스 간 통신, 외부 시스템과도 이용 가능

클라이언트, 서버 구조로 자원 주고받음

### 세마포어(semaphore)

접근하는 프로세스를 제어해 공유 자원을 관리

Q. 뮤텍스는 왜 IPC가 아닌가?

### 파이프(pipe)

FIFO 형태의 메모리인 파이프를 이용해 프로세스 간 자원 공유

파이프는 단방향 통신만 지원 → 양방향 통신을 하려면 read pipe, write pipe를 각각 생성해야 함

### 메시지 큐(message queue)

FIFO 형태 큐 사용해 프로세스 간 메시지를 주고받는 방식

# 좀비 프로세스와 고아 프로세스

**좀비 프로세스** : 자식 프로세스가 종료되었지만 부모 프로세스가 자식 프로세스의 종료 상태를 회수하지 않았을 경우 남겨진 자식 프로세스

- 자식 프로세스가 종료될 때 부모 프로세스에 SIGCHLD라는 시그널을 보내면, 부모 프로세스에서 wait() 시스템 콜을 호출해 자식 프로세스의 상태 정보를 받고 자원 회수 → 이 때 실패하면 좀비 프로세스

**고아 프로세스** : 부모 프로세스가 자식 프로세스보다 먼저 종료되는 경우 자식 프로세스

- 이럴 때 자식 프로세스의 부모 PID를 init 프로세스 PID인 1로 바꿔주면, 고아 프로세스의 부모 프로세스가 init 프로세스가 됨 → 고아 프로세스 작업 종료 시 init 프로세스가 고아 프로세스의 자원을 회수하여 좀비 프로세스가 되는 것 방지 가능
