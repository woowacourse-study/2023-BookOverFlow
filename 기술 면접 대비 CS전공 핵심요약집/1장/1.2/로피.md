# 1.2 프로세스

## 1.2.1 프로세스와 스레드

### 프로세스

- 컴퓨터에서 실행 중인 하나의 프로그램(특정 작업을 수행하기 위한 명령어의 집합)
- 운영체제로부터 자원을 할당받은 **작업의 단위**
- OS로부터 독립된 메모리 영역(코드, 데이터, 스택, 힙) 할당
- 다른 프로세스의 메모리 영역에 접근
- 하드디스크에 있는 프로그램을 실행하면, 실행을 위해서 **메모리 할당**이 이루어지고, 할당된 메모리 공간으로 바이너리 코드가 올라가게 된다. 이 순간부터 **프로세스**라 불린다.

  ![IMG_C7155C703CC6-1.jpeg](https://github.com/team-replace/replace-android/assets/50761690/06419b16-35ce-4d14-9b6f-6a466f599842)

  ![IMG_B94A1EE4E4E9-1.jpeg](https://github.com/team-replace/replace-android/assets/50761690/5b1d7fc0-057e-4ebc-9273-e9b19759d223)

  **프로세스의 메모리 영역 구조**

    - 스택(stack)
        - 지역 변수, 함수의 매개변수, 반환되는 주소 값 등이 저장되는 영역
        - 지연변수, 매개변수, 리턴값 등 **잠시 사용되었다가 사라지는 데이터**를 저장하는 영역
        - 함수 호출 시 할당되고 함수 반환 시 소멸
        - 높은 주소 값에서 낮은 주소 값으로 메모리가 할당, 영역 크기는 컴파일 때 결정
    - 힙(heap)
        - 사용자에 의해 동적 메모리 할당이 일어나는 영역
        - C 언어에서 malloc()으로 할당되는 영역이라고 보면 됨
        - 낮은 주소 값에서 높은 주소 값으로 메모리가 할당, 영역 크기는 런타임 때 결정
    - 데이터(data)
        - 전역 변수, 정적 변수, 배열, 구조체 등이 저장되는 영역
        - BSS(Block Stated Symbol) 영역과 데이터 영역으로 나뉨
            - BSS 영역 - 초기화하지 않은 변수
            - 데이터 영역 - 초기화한 변수
    - 코드(code)
        - 실생활 코드가 기계어로 컴파일되어 저장되는 영역
        - 텍스트(text) 영역

스택 영역과 힙 영역은 동적으로 메모리 할당 가능, 두 영역 사이에 빈 메모리 공간 존재

스택 - LIFO(Last In First Out, 후입선출) 방식

힙 - FIFO(First In First Out, 선입선출) 방식

메모리 영역을 공유하기 때문에 서로의 영역을 침범하는 문제 생길 수 있음

- 스택 오버플로(stack overflow) - 스택 영역이 힙 영역을 침범
- 힙 오버플로(heap overflow) - 힙 영역이 스택 영역을 침범

### 스레드

- 프로세스에서 실제로 실행되는 흐름의 단위
- 하나의 프로세스는 하나 이상의 스레드 가짐
- 프로세스 안에 존재하므로 프로세스의 메모리 공간을 이용, 지역 변수를 저장하는 스택 영역 할당
- 프로세스 내에서 **Stack**만 따로 할당받고, Code, Data, Heap영역은 공유하는 스레드
- 전역 변수를 저장하는 힙 영역은 다른 스레드와 공유

  ![IMG_32ED1335BEF7-1.jpeg](https://github.com/team-replace/replace-android/assets/50761690/6b5a8b37-1249-4101-a1f6-8a493d7f337d)

  **이런 방식으로 메모리를 공유하는 이유?**

  스레드는 “흐름의 단위로" CPU 의 입장에서 최소 작업 단위가 된다. 반면 운영체제는 이렇게 작은 단위까지 직접 작업하지 않기 때문에 운영체제의 관점에서는 프로세스가 최소 작업단위가 된다.

  여기서 중요한 점은 하나의 프로세스는 하나 이상의 스레드를 가진다는 점이다. 따라서, 운영체제 관점에서는 프로세스가 최소 작업 단위인데, 이 때문에 같은 프로세스 소속의 스레드끼리 메모리를 공유하지 않을 수 없다.


사용자 레벨 스레드와 커널 스레드

## 1.2.2 PCB

### PCB(Process Control Block, 프로세스 제어 블록)

- 프로세스를 제어하기 위해 프로세스 정보 저장
- 프로세스가 생성될때마다 고유의 PCB가 생성되고, 프로세스가 완료되면 PCB 는 제거
- 프로세스 간 문맥교환이 일어나면서, 프로세스는 진행하던 작업들을 PCB에 저장하고, 이후에 자신의 순서가 왔을 때 이어서 처리

![IMG_4A9A590423AC-1.jpeg](https://github.com/team-replace/replace-android/assets/50761690/edc4b795-8f09-4f8a-8454-8a1dfc413a31)

## 1.2.3 프로세스의 생성

부모 프로세스가 자식 프로세스를 생성하는 것

리눅스, 유닉스 계열의 OS에서는 최초의 프로세스 init이 존재하고, 그 프로세스가 다른 자식 프로세스를 생성할 수 있고 그 자식 프로세스는 또 다른 자식 프로세스를 생성

프로세스의 생성에는 사용자 프로그램이 아니라, 운영체제의 시스템 콜을 통해서만 가능, 이렇게 생성된 프로세스는 트리 구조를 형성하고 각자 고유한 번호인 pid를 가지게 됨

새로운 프로세스는 기존 프로세스에 fork() 함수 호출해 생성

fork() 함수에서는 함수를 호출한 프로세스를 복사하는 기능 존재

- 기존 프로세스 - 부모(parent) 프로세스
- 복사된 프로세스 - 자식(child) 프로세스
- 부모 프로세스에서 fork() 함수 호출시 → 부모프로세스는 자식 프로세스의 PID 값, 자식 프로세스는 0을 반환

![IMG_3CFF2494C71B-1.jpeg](https://github.com/team-replace/replace-android/assets/50761690/8faa6f9e-f5d6-45e3-b514-559b94b1bb5c)

운영체제가 프로세스를 종료하는 경우

- 프로세스가 운영체제의 종료 서비스(exit())를 호출해 정상 종료하는 경우
- 프로세스의 실행 시간 또는 특정 이벤트 발생을 기다리는 시간이 제한된 시간을 초과한 경우
- 프로세스가 파일 검색 또는 입출력에 실패하는 경우
- 오류가 발생하거나 메모리 부족 등이 발생하는 경우

부모 프로세스가 자식 프로세스를 종료하는 경우

- 자식 프로세스가 할당된 자원을 초과해 사용할 때
- 자식 프로세스에 할당된 작업이 없을 때

## 1.2.4 프로세스 상태도

모든 프로세스는 CPU에 의해 생성되고 소멸하는 과정을 거침

**프로세스의 5가지 상태**

- 생성(new)
    - 프로세스가 PCB를 가지고 있지만 OS로부터 승인 받기 전
- 준비(ready)
    - OS로부터 승인받은 후 준비 큐에서 CPU 할당을 기다림
- 실행(running)
    - 프로세스가 CPU를 할당받아 실행함
- 대기(waiting)
    - 프로세스가 입출력이나 이벤트 발생을 기다려야 해서 CPU 사용을 멈추고 기다림
- 종료(terminated)
    - 프로세스 실행을 종료함

![IMG_A19BAB8B2383-1.jpeg](https://github.com/team-replace/replace-android/assets/50761690/c4ffde45-074f-4f0a-b0fc-32c9b41cf225)

**프로세스 변화 과정**

- 생성 → 준비
    - 생성 상태의 프로세스가 OS로부터 승인을 받아, 준비 상태의 프로세스가 모여 있는 자료구조인 준비 큐에 추가됨
    - 승인(admit) - CPU를 제외한 다른 자원이 준비되어 해당 프로세스가 준비 상태가 될 수 있도록 OS가 허락하는 것을 의미
- 준비 → 실행
    - 준비 큐에 있는 프로세스 중 우선순위가 높은 프로세스가 디스패치(dispatch) 되어 실행됨
    - 디스패치 - 프로세스에 CPU 자원을 할당해 해당 프로세스가 준비 상태에서 실행 상태가 되는 것
- 실행 → 준비
    - 운영체제는 실행 상태의 프로세스가 프로세서를 독점하지 않도록 인터럽트 클록을 두어 특정 프로세스가 할당된 시간 동안만 프로세서를 점
    - CPU 독점을 방지하기 위해 타임아웃(timeout)되어 준비 상태로 변경됨
    - 인터럽트 - CPU가 특정 기능을 수행하는 도중에 급하게 다른 일을 처리하고자 할 때 사용할 수 있는 기능
- 실행 → 대기
    - 입출력 또는 이벤트 때문에 대기 상태로 변경됨
- 대기 → 준비
    - 입출력 또는 이벤트가 완료되어 준비 상태로 변경됨
- 실행 → 종료
    - 실행 중인 프로세스가 정상적으로 끝나서 종료 상태로 변경됨

## 1.2.5 멀티 프로세스와 멀티 스레드

**동시성**

- 하나의 코어(싱글 코어)에서 여러 작업을 번갈아 가면서 처리하는 방식
- **컨텍스트 스위칭(context switching) -** 하나의 CPU에서 여러 작업을 번갈아 처리하기 위해 처리 중인 작업을 교체하는 것

**병렬성**

- CPU가 여러 개(멀티 코어) 있어서 각 CPU에서 각 작업을 동시에 처리하는 방식
- 물리적인 시간 관점에서 동시에 여러 작업이 처리

![IMG_6F6703390E5B-1.jpeg](https://github.com/team-replace/replace-android/assets/50761690/774ee945-a8d9-4036-b6a7-71f2f71425bd)

### 멀티 프로세스

- 응용 프로그램 하나를 여러 프로세스로 구성하는 것을 의미
- 한 프로세스가 죽어도 다른 프로세스에 영향을 주지 않음
- 응용 프로그램을 프로세스 하나로 구성하는 것보다 여러 개로 구성하는 것이 안정적
- 시간과 메모리 공간을 많이 사용한다는 단점
    - CPU는 하나의 작업만 처리
    - 여러 프로세스를 처리하려면 CPU에서 처리 중인 프로세스를 교체하는 컨텍스트 스위칭 작업이 이루어져야 함
    - CPU에서 기존에 처리하던 프로세스가 할당받은 메모리 영역을 다른 프로세스에게 사용할 수 있게 교체하면서 시간과 메모리 필요 → **오버헤드**
    - 프로세스는 독립적인 메모리 할당 → 프로세스 간에 공유할 자원이 있다면 IPC(Inter Process Communication)를 통해 프로세스 간에 자원 공유 → 공유할 메모리 직접 참조보다 비효율적

![IMG_2B9190B01528-1.jpeg](https://github.com/team-replace/replace-android/assets/50761690/8a4b0f32-01bb-4d25-8971-fadf9df8212c)

### 멀티 스레드

- 스레드를 여러 개 생성해 스레드들이 각자 다른 작업을 처리하는 것을 의미
- 스레드 간에 힙, 데이터, 코드 영역 공유
- 컨텍스트 스위칭할 때 오버헤드가 적게 발생하고 IPC를 사용하지 않아도 되어 멀티 프로세스의 단점 보완
- 여러 개의 스레드를 생성하는 것이 독립적인 메모리 공간을 갖는 프로세스를 여러 개 만드는 것보다 효율적
- 스레드 간 자원 공유가 프로세스 간 자원 공유보다 시스템 처리 비용이 적고 프로그램 응답 시간도 단축
- 스레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 **통신 부담이 적어서 응답 시간이 빠르다.**
- 스레드에 문제가 생기면 프로세스 내 다른 스레드에 영향을 미칠 수 있음
- 자원을 공유하기 때문에 필연적으로 **동기화 문제**가 발생할 수 밖에 없다. 교착상태가 발생하지 않도록 주의해야 한다.

![IMG_F0A4AE2DEBFE-1.jpeg](https://github.com/team-replace/replace-android/assets/50761690/46ede733-2cd2-439d-a93e-45ffbb1962c0)

## 1.2.6 컨텍스트 스위칭

**인터럽트(interrupt)**

- 방해하다, 중단시키다
- CPU에서 프로세스를 처리하다가 입출력 관련 이벤트가 발생하거나 예외 상황이 발생할 때 이에 대응할 수 있게 CPU에 처리를 요청하는 것
- 인터럽트 발생하는 경우
    - 입출력이 발생할 때
    - CPU 사용 시간이 만료되었을 때
    - 자식 프로세스를 생성할 때

CPU는 하나의 프로세스만 처리 가능하기 때문에 멀티 프로세스를 처리하려면 CPU 스케줄러에 의해 인터럽트가 발생하면서 컨텍스트 스위칭이 일어남

- 컨텍스트(context) - CPU가 처리하는 프로세스의 정보를 의미

### 컨텍스트 스위칭

- 멀티 프로세스 환경에서 CPU가 처리 중인 프로세스의 정보를 바꾸는 것

  ![IMG_3F67331B0F72-1.jpeg](https://github.com/team-replace/replace-android/assets/50761690/7df5032f-378f-4918-8d4b-92b1e6545257)

  그림에서 보면, CPU가 P1을 처리하던 중 운영체제에 의해 인터럽트 발생

  P1은 유휴 상태(idle)로 변하고 스케줄러는 레지스터에 있는 처리 중인 작업 정보를 P1의 PCB에 저장

  P2의 PCB에 있는 정보를 가져와 레지스터에 로드하고 CPU는 P2를 처리하기 시작

  P1의 정보를 P1에 PCB에 저장하고, P2의 PCB에 저장된 정보를 레지스터에 로드하는 동안 CPU는 아무 일도 못함 → 어떤 처리를 하는데 간접적인 처리 시간과 메모리가 소요되는 경우 ‘오버헤드가 발생한다’

  멀티 스레드 처리의 경우에도 컨텍스트 스위칭 발생

    - 멀티프로세스의 컨텍스트 스위칭보다 시간과 메모리 자원을 적게 사용
        - 멀티 스레드는 스택을 제외한 힙, 데이터, 코드를 공유하므로 레지스터에 저장하고 로드해야하는 데이터가 상대적으로 적기 때문

  CPU에서 처리 중인 프로세스가 중간에 변경되어도 이전에 실행하던 코드를 이어서 실행할 수 있는 이유

    - PCB에 프로그램 카운터와 스택 포인터 값이 저장되어 있기 때문
        - 프로그램 카운터(PC, Program Counter) - 프로세스가 이어서 처리해야 하는 명령어의 주소 값
        - 스택 포인터(stack pointer) - 스택 영역에서 데이터가 채워진 가장 높은 주소 값
    - 이어서 실행할 명령어의 주소 값이 무엇인지, 데이터가 스택에 어디까지 채워져 있는지 알고 있어서 컨텍스트 스위칭 원활히 이루어짐

**문맥교환이 아닌 경우 ?**

- 프로세스가 실행 상태일 때, **시스템 콜이나 인터럽트가 발생하면 CPU 의 제어권이 운영체제에게로 넘어와, 원래 실행중이던 프로세스의 업무를 잠시 멈추고 운영체제의 코드가 실행된다.**
- 이는, 하나의 프로세스가 사용자 모드에서 실행되다가, 커널 모드로 실행 모드만 바뀌는 것일 뿐 CPU 를 점유하는 프로세스가 다른 사용자 프로세스로 변경되는 과정이 아니기 떄문이다.

![Untitled](https://github.com/team-replace/replace-android/assets/50761690/5d01f5cb-f97f-423d-b2c0-cc389a3b3559)

![Untitled](https://github.com/team-replace/replace-android/assets/50761690/c32dd16d-4b0a-4cf9-972f-f1415f674c6d)

## 1.2.7 프로세스 동기화

### 경쟁 상태(race condition)

- 공유 자원에 동시에 접근해 경쟁하는 상태
- 여러 프로세스 또는 스레드에서 하나의 공유 자원에 접근하는 경우, 이 때 자원에 접근하는 순서에 따라 결과 값 달라짐
- ex) 너무 많은 우유 문제(too much milk problem)

  ![IMG_41C42B518385-1.jpeg](https://github.com/team-replace/replace-android/assets/50761690/98f560f8-e10a-48f6-a82c-eccc97eddd8a)

  공유 자원 - 냉장고

  엄마, 아빠 - 프로세스

  우유가 총 2개가 되는, 의도하지 않은 결과를 초래 → 이러한 문제 해결 위해 프로세스 동기화 이루어져야 함


### 임계 영역(critical section)

- 공유 자원에 접근할 수 있고 접근 순서에 따라 결과가 달라지는 코드 영역
- 여러 프로세스(또는 스레드)가 자원을 공유하는 상황에서 하나의 프로세스(스레드)만 접근할 수 있도록 제한해둔 영역
- 임계 영역에서 경쟁 상태가 발생하는 것을 방지하려면 여러 프로세스가 공유 자원에 접근해도 데이터의 일관성이 유지되도록 **프로세스 동기화** 해야함
- 임계 영역에 여러 접근이 동시에 발생하는 것을 방지하기 위한 조건
    - 상호 배제 기법(mutual exclusive)
        - 어떤 프로세스가 임계 영역을 실행 중일 때 다른 프로세스가 임계 영역에 접근할 수 없음
        - 뮤텍스, 세마포어
    - 진행(progress)
        - 임계 영역에 실행 중인 프로세스가 없을 때 다른 프로세스가 임계 영역 실행
    - 한정된 대기(bounded waiting)
        - 임계 영역에 접근 요청을 했을 때 무한한 시간을 기다리지 않음
        - 임계구역 진입횟수에 한계를 두어 같은 프로세스가 계속해서 독점해서 사용하지 못하게 한다 -> 다른 프로세스들이 기아상태에 빠지지 않게 한다

### 뮤텍스(mutex)

- 락(lock)을 가진 프로세스만이 공유 자원에 접근할 수 있게 하는 방법
- ex) 화장실 예
    - 뮤텍스의 작동방식은 화장실과 화장실 열쇠가 하나뿐인 식당과 같음

      ![IMG_E205785656C3-1.jpeg]https://github.com/team-replace/replace-android/assets/50761690/26ef98ed-64b0-403c-b694-a49936e6f244)

      화장실 - 공유 자원을 포함한 임계 영역

      열쇠 - 락

      A, B - 공유 자원에 접근하려는 프로세스

      임계 영역에 접근한 프로세스가 임계영역에 락을 건다고 해서 **락킹 매커니즘(locking mechanism)**

      **스핀락(spinlock)**

        - 바쁜 대기(busy waiting)의 한 종류
            - 바쁜 대기 - 프로세스가 공유 자원에 접근할 수 있는 권한을 얻을 때까지 확인하는 과정
        - 락을 얻기 위해 프로세스가 반복문을 돌면서 기다리는 것
        - 프로세스가 대기 상태가 되지 않고 반복문을 돌면서 자원의 사용 가능 여부를 확인하므로 프로세스가 빠르게 교체될 수 있음
        - 임계 구역에 진입하는 프로세스는 진입 코드를 계속해서 반복 실행하며 CPU를 낭비


### 세마포어(semaphore)

- 공유 자원에 접근할 수 있는 프로세스의 수를 정해 접근을 제어하는 방법

  ![IMG_67C3D20C7175-1.jpeg](https://github.com/team-replace/replace-android/assets/50761690/c9748e5f-824c-4e3d-ac80-c1def2383173)


화장실 - 공유 자원을 포함한 임계 영역

A,B,C,D - 공유 자원에 접근하려는 프로세스

화장실 개수(열쇠 개수) - 공유 자원에 접근할 수 있는 프로세스의 수를 제어하기 위한 정수 변수

임계 영역에 접근할 수 있는 키 n개를 지정하고 이 중 하나를 가진 프로세스만이 임계 영역에 접근하게 하는 방식

- 공유 자원에 접근한 프로세스가 접근을 해제하면 다른 프로세스가 접근할 수 있도록 신호를 보낸다고 해서 **시그널링 메커니즘(signaling mechanism)**

### 세마포 원리

1. 처음 정수는 임계구역에 들어갈 수 있는 쓰레드 수를 나타낸다.
2. 임의의 쓰레드가 임계구역에 쓰레드가 존재하지 않을 경우 acquire()를 실행한다.
3. 세마포는 정수값을 1 감소시킨다. 만약 정수값이 0보다 작을 경우 세마포의 Ready Queue의 쓰레드를 block시킨다.
4. 임의의 쓰레드가 release()를 명령어를 수행하여 임계구역을 나간다.
5. 세마포는 정수값을 1 증가시킨다.
6. 줄을 서고 있던 다음 쓰레드가 wakeup을 통해 탈출한다.
7. 해당 쓰레드가 임계구역에 들어간다.

### 1. 카운팅 세마포

가용한 개수를 가진 자원에 대한 접근 제어용으로 사용되며, 세마포는 그 가용한 자원의 개수로 초기화된다. 자원을 사용하면 세마포가 감소, 방출하면 세마포가 증가한다.

### 2. 이진 세마포(== Mutex)

뮤텍스라고도 부르며, 상호배제(Mutual Exclusion)의 줄임말이다. 이름 그대로 0과 1 사이의 값만 가능하다

> 동기, 비동기 - 작업 순서에 대한 개념
블로킹, 넌블로킹 - 작업을 위한 대기를 구분하는 개념

동기(synchronization)
- 여러 작업을 처리할 때 작업 순서를 보장함
  비동기(asynchronization)
- 여러 작업을 처리할 때 작업 순서를 보장하지 않음
  블로킹(blocking)
- 작업을 수행할 때 대기할 수 있다는 것을 의미하며 작업 순서를 보장하지 않음
  넌블로킹(non-blocking)
- 작업을 시작하면 대기 없이 수행한다는 것을 의미
>

## 1.2.8 교착 상태

### 교착 상태(deadlock)

- 2개 이상의 프로세스가 각각 자원을 가지고 있으면서 서로의 자원을 요구하며 기다리는 상태
- 교착 상태가 발생하는 4가지 필요 충분 조건
    - 상호 배제(mutual exclusion)
        - 하나의 공유 자원에 하나의 프로세스만 접근할 수 있음
    - 점유와 대기(hold and wait)
        - 프로세스가 최소 하나의 자원을 점유하고 있는 상태에서 추가로 다른 프로세스에서 사용 중인 자원을 점유하기 위해 대기
    - 비선점(non-preemption)
        - 다른 프로세스에 할당된 자원을 뺏을 수 없음
    - 환형 대기(circular wait)
        - 프로세스가 자신의 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구
- 교착 상태를 막기 위한 방법
    - 상호배제 부정
        - 여러 프로세스가 동시에 하나의 공유 자원을 사용할 수 있음
        - 서로의 자원을 기다리는 상황을 예방
    - 점유와 대기 부정
        - 프로세스가 실행되기 전에 필요한 모든 자원을 할당함으로써 프로그램 대기 없앰
        - 프로세스가 자원을 점유하지 않은 상태에서만 자원 요구
    - 비선점 부정
        - 자원을 점유한 프로세스가 다른 자원을 요구할 때 점유한 자원 반납
    - 환형 대기 부정
        - 자원을 선형 순서로 정렬해 고유 번호 할당
        - 각 프로세스에서 요구할 수 있는 번호의 방향을 정해서 한쪽 방향으로만 자원 요구

## 1.2.9 스레드 안전

멀티 스레드 환경에서 하나의 변수, 함수, 객체에 스레드 여러 개가 동시에 접근해도 문제가 없음을 의미

- 다음과 같이 세 가지를 통해 thread-safe한 상태인지 판단할 수 있다.

> 1. 전역 변수나 힙, 파일과 같이 여러 스레드가 동시에 접근할 수 있는 자원을 사용하는가?
>
>
> 2. 핸들과 포인터를 통한 데이터의 간접 접근이 가능한가?
>
> 3. 부수 효과를 가져오는 코드가 있는가?
>

ex) 스레드가 안전하지 않은 경우

```jsx
var++;
```

![IMG_1D14208F475F-1.jpeg](https://github.com/team-replace/replace-android/assets/50761690/ac2e6440-5b3a-4568-bd14-3b8dbd1aa7ee)

위 그림 처럼 한 줄짜리 코드에서도 스레드가 2개가 접근하면 잘못된 결과를 초래할 수 있음

**스레드 안전을 위한 조건**

- 상호배제(mutual exclusive)
    - 공유 자원에 접근해야할 때 상호배제 기법(뮤텍스 or 세마포어)을 사용해 접근 통제해야함
- 원자 연산(atomic operation)
    - 공유 자원에 접근할 때 원자 연산을 이용하거나 원자적으로 정의된 연산을 이용해 연산 도중에 다른 스레드가 접근할 수 없게 됨
    - Atomic - 공유 자원 변경에 필요한 연산을 원자적으로 분리한 뒤에 실제로 데이터의 변경이 이루어지는 시점에 Lock을 걸고, 데이터를 변경하는 시간 동안 다른 쓰레드의 접근이 불가능하도록 하는 방법
    - ‘연산했다’와 ‘연산 안 했다’ 두 가지만 존재하는 연산
- 재진입성(reentrancy)
    - 특정 함수를 하나의 스레드에서 실행 중일 때 다른 스레드가 해당 함수를 실행해도 각 스레드에 올바른 결과가 나올 수 있어야 함
- 스레드 지역 저장소(thread local storage)
    - 각 스레드에서만 접근할 수 있는 저장소를 사용해서 공유되는 자원을 줄여야 함

## 1.2.10 IPC

**IPC**

- Inter Process Communication
- 프로세스 간에 자원을 공유하는 방식

**종류**

1. 공유 메모리(shared memory)
- 프로세스 간에 공유 가능한 메모리를 구성해 자원을 공유하는 방식
- 여러 프로세스에서 접근할 수 있으므로 동기화 문제 발생

  ![IMG_71E17FFF850A-1.jpeg](https://github.com/team-replace/replace-android/assets/50761690/9a2fa1e1-6260-49bf-830c-9b58d3415fab)

1. 소켓(socket)
- 네트워크 소켓을 이용하는 프로세스 간 통신, 외부 시스템과도 이용
- 클라이언트와 서버 구조로 자원을 주고 받음

  ![IMG_6DF1142F7782-1.jpeg](https://github.com/team-replace/replace-android/assets/50761690/e43c1394-a061-457b-9f29-a72171c26423)

1. 세마포어(semaphore)
- 접근하는 프로세스를 제어해 공유 자원을 관리

1. 파이프(pipe)
- FIFO(First In First Out) 형태의 메모리인 파이프를 이용해 프로세스 간 자원을 공유하는 방식
- 단방향 통신만 지원하므로 읽기 또는 쓰기 중 하나만 할 수 있음
- 양방향 통신을 하려면 읽기 파이프와 쓰기 파이프를 각각 생성해야 함

![IMG_2831BC3A7FA5-1.jpeg](https://github.com/team-replace/replace-android/assets/50761690/e7f68ba3-233c-4d6b-887f-aa376a1dca86)

1. 메시지 큐(message queue)
- FIFO 형태의 큐 자료구조를 사용해 프로세스 간 메시지를 주고받는 방식

  ![IMG_6FB78056CD20-1.jpeg](https://github.com/team-replace/replace-android/assets/50761690/4701c508-903a-47e1-a1d2-991515cff743)


![Untitled](https://github.com/team-replace/replace-android/assets/50761690/ac3a67c1-065e-4ed1-aac5-54920b042dd4)

전자의 방식이 Messagin Passing 모델, 후자의 방식이 Shared Memeory 모델이다.

Message Passing 모델의 경우 메시지를 전달하기 위해 커널을 들린다. 이 과정에서 User Level 과 Kernel Level 을 넘나들게 되고 매번 system call 이 호출되어, 이에 따른 오버헤드가 발생한다.
Shared Memory 모델의 경우, 프로세스 사이에 공유 공간이 존재하기 때문에 시스템 호출이 필요하지 않다. 이로 인해 커널 의존성도 낮고 속도도 빠르다. 하지만 공유 공간에 대한 제한이 존재한다.

## 1.2.11 좀비 프로세스와 고아 프로세스

**좀비 프로세스(zombie process)**

- 부모 프로세스가 자식 프로세스의 종료 상태를 회수하지 않았을 경우에 남겨진 자식 프로세스
- 자식 프로세스가 종료될 때 부모 프로세스에 SIGCHLD라는 시그널을 보내면 부모 프로세스에서 wait()함수(시스템 콜)을 호출해 자식 프로세스의 상태 정보를 받고 정보를 회수함
- 이 때 자원 회수에 실패하면 좀비 프로세스 생김
- 좀비 프로세스가 쌓이면 자원 낭비

**고아 프로세스(orphan process)**

- 부모 프로세스가 자식 프로세스보다 먼저 종료되는 경우에 자식 프로세스
- 이럴 땐 자식 프로세스의 부모 PID를 init 프로세스(부팅 시 가장 먼저 실행되는 프로세스)의 PID인 1로 바꿔줌
- 이렇게 하면 고아 프로세스의 부모 프로세스는 init 프로세스가 됨
- 고아 프로세스가 작업 을 종료하면 init 프로세스가 고아 프로세스의 자원을 회수해 좀비 프로세스가 되는 것을 방지
