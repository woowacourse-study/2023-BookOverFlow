# 1.2 프로세스

## 프로세스 (process)

컴퓨터에서 실행 중인 하나의 프로그램

- 프로그램: 특정 작업을 수행하기 위한 명령어의 집합

OS는 프로그램을 실행하면서 **디스크에 저장된 데이터를 메모리로 로드**하고,

프로세스는 OS로부터 **독립된 메모리 영역**(코드, 데이터, 스택, 힙)을 **할당 받고**,

다른 프로세스의 메모리 영역에 접근할 수 없다.

![프로세스의 메모리 영역 구조](https://prod-files-secure.s3.us-west-2.amazonaws.com/d4809f18-a915-4e30-8b11-8f015eacff00/35b1dd9c-2826-4684-94a9-6691a16b6d53/Untitled.png)

프로세스의 메모리 영역 구조

**stack**

- 지역 변수, 함수의 매개 변수, 반환되는 주소 값 등이 저장
- 높은 주소 값 → 낮은 주소 값으로 메모리가 할당 ~~(LIFO)~~
- 영역 크기는 컴파일 때 결정

**heap**

- 사용자에 의해 동적 메모리 할당 발생
- 낮은 주소 값 → 높은 주소 값으로 메모리가 할당 ~~(FIFO)~~
- 영역 크기는 런타임 때 결정

**data**

- 전역 변수, 정적 변수, 배열, 구조체 등이 저장
- BSS (Block Stated Symbol) 영역 → 초기화하지 않은 변수
    
    데이터 영역 → 초기화한 변수 저장
    

**code**

- 실행할 코드가 기계어로 컴파일되어 저장
- 텍스트 영역 이라고도 함

**빈 메모리 영역**

- 스택, 힙 영역이 동적으로 메모리 할당이 가능하기 때문에 존재
- **`stack overflow`** : 스택 영역이 힙 영역을 침범하는 경우
- **`heap overflow`** : 힙 영역이 스택 영역을 침범하는 경우

## 스레드 (Thread)

프로세스에서 실제로 실행되는 흐름의 단위

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/d4809f18-a915-4e30-8b11-8f015eacff00/f270da45-da70-456d-a2ee-3db232ae16e2/Untitled.png)

- 프로세스의 메모리 공간을 이용하고,
    
    지역 변수를 저장하는 스택 영역을 할당 받음
    
- 전역 변수를 저장하는 힙 영역은 다른 스레드와 공유

### user-level thread & kernel-level thread

**다대일 모델 (many-to-one model)**

- 사용자 레벨 스레드 n개 : 커널 레벨 스레드 1개
- 하나의 스레드에서 시스템 콜을 하면 나머지는 커널 레벨 스레드 사용 못함 ⇒ 병렬성 X

**일대일 모델 (one-to-one model)**

- 사용자 레벨 스레드 1개 : 커널 레벨 스레드 1개
- 사용자 레벨 스레드 수 만큼 커널 레벨 스레드 생성 ⇒ 성능 저하 가능

**다대다 모델 (many-to-many model)**

- 사용자 레벨 스레드 n개 : 커널 레벨 스레드 m개  (n ≥ m)
- 1, 2의 장점을 모두 포함하나, 구현이 어려움

## PCB (Process Control Block)

프로세스를 제어하기 위해 프로세스 정보를 저장

- 프로세스의 현재 상태 / 프로세스 고유의 PID / 부모 프로세스의 PID / 자식 프로세스의 PID
    
    / 다음 실행할 명령어의 주소인 PC / 프로세스 우선순위 / 메모리 제한 등등… 을 저장
    

## 프로세스의 생성

기존 프로세스(**부모 프로세스**)에서 `fork()` 함수를 호출하여 **자신을 복사함으로써** 새로운 프로세스
(**자식 프로세스**)를 생성

- fork()의 반환값: `자식 프로세스의 PID 값` (부모) / `0` (자식)

### 프로세스 종료

**운영체제가 프로세스를 종료하는 경우**

- 프로세스가 운영체제의 `exit()`를 호출해 정상 종료하는 경우
- 프로세스의 실행 시간 또는 특정 이벤트 발생을 기다리는 시간이 제한 시간을 초과한 경우
- 프로세스가 파일 검색 또는 입출력에 실패하는 경우
- 오류가 발생하거나 메모리 부족 등이 발생하는 경우

**부모 프로세스가 자식 프로세스를 종료시키는 경우**

- 자식 프로세스가 할당된 자원을 초과해 사용하는 경우
- 자식 프로세스에 할당된 작업이 없는 경우

## 프로세스 상태도

프로세스는 CPU에 의해 생성되고 소멸하는 과정을 거치고,

이 과정에서 `생성(new)` `준비(ready)` `대기(waiting)` `실행(running)` `종료(terminated)` 의 
5가지 상태로 존재한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/d4809f18-a915-4e30-8b11-8f015eacff00/9789f8de-988d-4e69-8902-232bd0bc5d32/Untitled.png)

- `생성`: 프로세스가 PCB를 갖고 있지만 OS로부터 승인을 받기 전
    
          (승인: CPU를 제외한 다른 자원이 준비되어 해당 프로세스가 준비 상태가 되도록 OS가 허락하는 것)
    
- `준비`: OS로부터 승인을 받고, 준비 큐에서 CPU 할당을 기다림
- `실행`: 프로세스가 CPU를 할당받아 실행
- `대기`: 프로세스가 CPU 사용을 멈추고 입출력이나 이벤트 발생을 기다림
- `종료`: 프로세스 실행 종료

### 상태 변화

`생성→준비`: OS로부터 승인받은 프로세스가 **준비 큐(ready queue)**에 추가됨

`준비→실행`: 준비 큐에서 우선순위가 높은 프로세스가 dispatch되어 실행됨

          (디스패치: 프로세스에 CPU 자원을 할당하여 준비→실행 상태가 되는 것)

`실행→준비`: CPU 독점 방지를 위해 타임아웃(timeout)되어 준비 상태가 됨

`실행→대기`: 입출력 또는 이벤트로 인해 대기 상태로 변경

`대기→준비`: 입출력 또는 이벤트 완료로 준비 상태로 변경

`실행→종료`: 프로세스가 정상적으로 끝나 종료

## 멀티 프로세스와 멀티 스레드

**`동시성`(concurrency)**: 싱글 코어에서 여러 작업을 번갈아 가면서 처리하는 방식

- `context switching`: 처리 중인 작업을 교체하는 것

`**병렬성`(parallelism)**: 멀티 코어이므로 각 CPU에서 각 작업을 동시에 처리하는 방식 

*싱글 코어인 CPU가 2개면 멀티 프로세서.. 멀티 코어는 아님…… !?!?*

### 멀티 프로세스 (multi process)

응용 프로그램 하나를 여러 프로세스로 구성하는 것

- 한 프로세스가 죽어도 다른 프로세스에 영향을 주지 않음 → 프로그램이 안정적!
- `오버헤드`(overhead) 발생
    - 콘텍스트 스위칭 작업을 위해, 기존 프로세스가 할당받은 메모리 영역을 교체하기 위한 시간과 메모리 사용
- 프로세스는 독립적인 메모리를 할당받으므로, **IPC(Inter Process Communication)**을 통해 프로세스 간 자원을 공유해야 한다 → 비효율적!

### 멀티 스레드 (multi thread)

스레드를 여러 개 생성해 스레드들이 각자 다른 작업을 처리하는 것

- 스레드 간 힙, 데이터, 코드 영역을 공유 (프로세스가 갖고 있는 영역들임)
- 콘텍스트 스위칭 시 오버헤드가 적게 발생 (저장하고 로드할 데이터가 상대적으로 적기 때문)
- IPC 사용 안해도 됨
- 효율적인 자원 사용 가능
- 스레드 간 자원 공유가 프로세스 간 자원 공유보다 시스템 처리 비용이 적고, 프로그램 응답 시간 단축
- 공유 자원에 대한 동기화가 필수

## 콘텍스트 스위칭 (context switching)

### 인터럽트 (interrupt)

프로세스를 처리하다가 입출력 관련 이벤트가 발생하거나 예외 상황이 발생할 때

이에 대응할 수 있게 CPU에 처리를 요청하는 것

- e.g. 입출력이 발생할 때, CPU 사용 시간이 만료되었을 때, 자식 프로세스를 생성할 때

커널 모드에 들어가기 위한 진입점 !?! (시스템콜, 트랩도 그러함)

CPU의 효율성을 높이기 위해 존재함

### 콘텍스트 스위칭

멀티 프로세스 환경에서 CPU가 처리 중인 프로세스의 정보를 바꾸는 것

- CPU 스케줄러에 의해 인터럽트가 발생하면서 콘텍스트 스위칭이 이뤄짐
- context: CPU가 처리하는 프로세스의 정보

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/d4809f18-a915-4e30-8b11-8f015eacff00/42a4c151-0fa1-42be-a5bc-1cbd562a002b/Untitled.png)

- PCB에 상태를 저장하고 로드하는 동안 CPU는 아무 일도 못함 ⇒ 오버헤드 발생
- PCB에 프로그램 카운터, 스택 포인터 값 저장
    - 이어서 실행할 명령어의 주소 값, 데이터가 스택 어디까지 채워져 있는지를 알게 됨 → 이전에 실행하던 코드를 이어서 실행 가능!
    - Program Counter: 프로세스가 이어서 처리해야 하는 명령어의 주소 값
    - Stack Pointer: 스택 영역에서 데이터가 채워진 가장 높은 주소 값

## 프로세스 동기화

### 경쟁 상태 (race condition)

공유 자원에 동시에 접근해 경쟁하는 상태

### 임계 영역 (critical section)

공유 자원에 접근할 수 있고, 접근 순서에 따라 결과가 달라지는 코드 영역

임계 영역에서 경쟁 상태가 발생하는 것을 방지하기 위해 데이터의 일관성을 유지해야 함: `**프로세스 동기화**` (process synchronization)

- 일관성: 작업 순서에 따라 결과가 달라지지 않음을 보장함

**임계 영역에 여러 접근이 동시에 발생하는 것을 방지하기 위해** 충족해야 하는 조건

`상호배제 기법 (mutual exclusive)`

- 어떤 프로세스가 임계 영역을 실행 중일 때 다른 프로세스는 임계 영역에 접근 불가
- e.g. 뮤텍스, 세마포어

`진행 (progress)`

- 임계 영역을 실행 중인 프로세스가 없을 때 다른 프로세스가 임계 영역을 실행

`한정된 대기 (bounded waiting)`

- 임계 영역에 접근을 요청했을 때 무한한 시간을 기다리지 않음

### 뮤텍스 (mutex)

`락(lock)`을 가진 프로세스만이 공유 자원에 접근할 수 있게 하는 방법

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/d4809f18-a915-4e30-8b11-8f015eacff00/739950d0-6827-4783-bd42-469f9a8954df/Untitled.png)

- 임계 영역에 먼저 온 프로세스가 임계 영역에 락을 걸면 → 다른 프로세스들은 락을 해제하기 전까지 기다림 (⇒ locking mechanism)
- 스핀락 (spinlock) 을 적용할 수 있다.
    - **바쁜 대기** (busy waiting, 공유 자원에 접근할 수 있는 권한을 얻을 때까지 확인하는 과정)의 한 종류
    - 락을 얻기 위해 프로세스가 반복문을 돌면서 기다림
    - 내가 들어가려고 열심히 확인하다가 엇! 자리났네! 하면서 들어감

### 세마포어 (semaphore)

공유 자원에 접근할 수 있는 프로세스의 수를 정해 접근을 제어하는 방법

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/d4809f18-a915-4e30-8b11-8f015eacff00/9c5f4e5c-ce95-471f-b553-f90735a13f32/Untitled.png)

- 공유 자원에 접근한 프로세스가 접근을 해제하면 다른 프로세스가 접근할 수 있도록 신호를 보냄 (⇒ signaling mechanism)
- 세마포어 정수 관련: 이진 세마포어 / 카운팅 세마포어
- 대기큐에서 나오는 방식: 강성 세마포어 / 약성 세마포어

### 동기, 비동기

작업 순서에 대한 개념

`synchronization`: 여러 작업을 처리할 때 작업 순서를 보장

`asynchronization`: 여러 작업을 처리할 때 작업 순서를 보장하지 않음

### 블로킹, 넌블로킹

작업을 위한 대기를 구분하는 개념

`blocking`: 작업을 수행할 때 대기할 수 있음 → 작업 순서를 보장하지 않음

- 동기에서는 보장되나 비동기에서 보장되지 않음 ? 이거 맞아여?

`non-blocking`: 작업을 시작하면 대기 없이 수행

## 교착 상태 (deadlock)

2개 이상의 프로세스가 각각 자원을 갖고 있으면서 서로의 자원을 요구하며 기다리는 상태

### 4가지 필요 충분 조건

**상호배제 (mutual exclusion)**

- 하나의 공유 자원에 하나의 프로세스만 접근 가능
- 포크는 한 명만 들고 있을 수 있음

**점유와 대기 (hold and wait)**

- 하나의 자원을 점유하고 있는 상태에서 추가로 다른 프로세스에서 사용 중인 자원을 점유하기 위해 대기
- 포크 들고 양옆 사람 포크 기다려

**비선점 (non-preemption)**

- 다른 프로세스에 할당된 자원을 뺏을 수 없음
- 다른 사람 포크 못뺏음

**환형 대기 (circular wait)**

- 자신의 자원을 점유하면서 앞 또는 뒤에 있는 프로세스의 자원 요구
- 동그란 식탁

위의 4가지 조건 중 하나만 제거해도 데드락을 막을 수 있음

[참고] 식사하는 철학자

## 스레드 안전 (thread safe)

하나의 변수, 함수, 객체에 스레드 여러 개가 동시에 접근해도 문제가 없음을 의미

### 스레드 안전을 위한 조건

**상호배제 (mutual exclusive)**

- 공유 자원에 접근할 때 뮤텍스, 세마포어와 같은 상호 배제 기법을 사용해 접근 통제

**원자 연산 (atomic operation)**

- 공유 자원에 접근할 때 원자 연산을 이용하거나 원자적으로 정의된 연산을 이용
- 원자 연산: ‘연산했다’ ‘연산 안 했다’ 두 가지만 존재하는 연산

**재진입성 (reentrancy)**

- 특정 함수를 하나의 스레드에서 실행 중일 때, 다른 스레드가 함수를 실행해도
    
    각 스레드에 올바른 결과가 나올 수 있도록 함
    

**스레드 지역 저장소 (thread local storage)**

- 각 스레드에서만 접근할 수 있는 저장소를 사용 → 공유 자원을 줄임

## IPC (Inter Process Communication)

프로세스 간에 자원을 공유하는 방식

**공유 메모리 (shared memory)**

- 프로세스 간 공유 가능한 메모리를 구성해 자원을 공유
- 동기화 문제 발생 가능

**소켓 (socket)**

- 소켓을 이용하는 프로세스 간 통신

**세마포어 (semaphore)**

- 프로세스를 제어해 공유 자원 관리

**파이프 (pipe)**

- FIFO 형태의 메모리인 파이프를 이용해 프로세스 간 자원을 공유하는 방식
- 파이프는 단방향 통신만 지원 → 양방향 통신 하려면 read pipe와 write pipe를 각각 생성해야 함

**메시지 큐 (message queue)**

- FIFO 형태의 큐 자료구조를 사용해 프로세스 간 메시지를 주고받는 방식

## 좀비 프로세스와 고아 프로세스

**좀비 프로세스 (zombie process)**

- 부모 프로세스가 자식 프로세스의 종료 상태를 회수하지 않았을 경우에 남겨진 자식 프로세스
- 좀비 프로세스가 쌓이면 자원 낭비가 됨
- reaper process가 좀비 프로세스를 나중에 회수한대요

**고아 프로세스 (orphan process)**

- 부모 프로세스가 자식 프로세스보다 먼저 종료되는 경우에 자식 프로세스
- 자식 프로세스의 부모 PID를 1로 변경 (init process의 PID임)
