# 4-3 비선형 자료구조

> 비선형 자료구조(non-linear data structure)는 하나의 데이터 뒤에 N개의 데이터가 이어질 수 있는, 1:N 또는 N:N 구조로 데이터가 나열되는 자료구조를 뜻한다.
> 선형 자료구조와 달리 데이터를 하나하나 탐색하지 않아도 원하는 데이터를 찾을 수 있다는 장점 때문에 비선형 자료구조를 활용한 다양한 알고리즘이 있다.

## 4. 3. 1 그래프
> 그래프(graph)는 데이터를 포함하는 정점(vertex or node)과 정점을 잇는 간선(edge)으로 구성된 자료구조다.

- 인접(adjacent): 두 정점이 간선으로 연결되어 있으면 인접하다고 한다.
- 차수(degree): 정점에 연결된 간선의 수를 나타낸다.
- 진입 차수(in-degree): 해당 정점으로 향하는 간선의 수를 의미한다.
- 진출 차수(out-degree): 해당 정점에서 나가는 간선의 수를 의미한다.
- 경로(path): 한 정점에서 다른 정점으로 이어지는 정점들의 리스트를 뜻한다.
- 경로 길이(path length): 경로를 구성하는 간선의 수다.
- 단순 경로(simple path): 모두 다른 정점으로 구성된 경로를 의미한다.
- 사이클(cycle): 한 정점에서 시작해 같은 정점으로 돌아올 수 있는 경로를 의미한다.

### 그래프의 종류
> 그래프는 간선의 방향성 유무에 따라 무방향 그래프와 방향 그래프로 구분할 수 있다.

#### 1. 무방향 그래프(undirected graph)
> 무방향 그래프는 간선에 방향성이 없는 그래프다. 두 정점이 연결되어 있을 때 순서가 없으므로 `(A, B)`와 `(B, A)`는 동일한 간선을 의미한다. 정점의 개수가 n일 때 최대 간선의 개수는 `n x (n - 1) / 2` 다.

#### 2. 방향 그래프(directed graph)
> 방향 그래프는 간선에 방향성이 있는 그래프다. 두 정점이 연결되어 있을 때 A에서 B로 향하는 간선을 `<A, B>`로 표기한다. 따라서 `<A, B>`와 `<B, A>`는 다른 간선을 의미한다. 정점의 개수가 n일 때 최대 간선의 개수는 `n x (n - 1)`

#### 그 외 그래프 들
1. 부분 그래프(sub graph): 기존 그래프에서 일부 정점 또는 간선을 제외한 그래프다.
2. 가중치 그래프(weighted graph): 간선에 비용이나 가중치가 할당된 그래프다.
3. 완전 그래프(complete graph): 간선을 최대로 가진 그래프로, 연결 그래프(connected graph)라고도 한다.
    - 정점의 개수가 n일 때 무방향 그래프의 간선 수가 `n x (n - 1) / 2` 이면 완전 그래프다.
    - 이와 마찬가지로 방향 그래프의 간선의 수가 `n x (n - 1)`이면 완전 그래프다.
4. 유향 비순환 그래프(DAG, Directed Acyclic Graph): 방향 그래프이면서 사이클이 없는 그래프다.

### 경로 탐색

#### 1. 너비 우선 탐색(BFS, Breadth-First Search)
> 탐색을 시작하는 정점에서 가까운 정점을 먼저 탐색하는 방식이다.
> 먼저 발견한 정점과 인접한 정점들을 탐색하면서 큐에 삽입한다.
> 이럴 경우 이전에 방문한 정점을 큐에 삽입하면 끊임없이 탐색을 반복하게 될 수 있다.
> 따라서 탐색한 정점을 큐에 넣기 전에 이전에 방문했는지 반드시 확인해야 한다.

![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/60ecd65f-e4e2-4e5a-ae72-6948b58e467f)
![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/59d80176-7d3f-4766-b04f-8cb2154ab313)

1. 정점 A에서 탐색을 시작한다. 큐에 A를 삽입한다.
2. 큐에서 디큐를 수행하면 정점 A가 나온다. A에서 탐색 가능한 정점은 B와 C다. B와 C 모두 방문한 적이 없으므로 큐에 B와 C를 삽입한다.
3. 큐에서 디큐를 수행하면 정점 B가 나온다. B에서 탐색가능한 정점은 A, D, E다. A는 이미 방문했으므로 탐색가능한 정점은 D와 E이다. 큐에 D와 E를 삽입한다.
4. 큐에서 디큐를 수행하면 정점 C가 나온다. C에서 탐색 가능한 정점은 A, D, F이다. A와 D는 이미 방문 했으므로 탐색 가능한 정점은 F이다. 큐에 F를 삽입한다.
5. 큐에서 디큐를 수행하면 정점 D가 나온다. D와 연결된 정점 B, C, E, F를 모두 방문했으므로 큐에 삽입되는 정점은 없다.
6. 큐에서 디큐를 수행하면 정점 E가 나온다. E와 연결된 정점 B, D, F를 모두 방문했으므로 큐에 삽입되는 정점은 없다.
7. 큐에서 디큐를 수행하면 정점 F가 나온다. F와 연결된 정점 C, D, E 중 방문할 정점이 없다. 큐가 비었으므로 탐색을 종료한다.

너비 우선 탐색을 하면 비가중치 그래프에서 시작 정점부터 특정 정점까지의 최단 거리를 알 수 있다.
- 정점 A에서 방문 가능한 정점은 B와 C로 최단 거리는 1이다. 그렇다면 정점 B와 C에서 방문 가능한 정점까지의 거리는 (정점 A에서 B 또는 C 까지의 거리) +  1임을 알 수 있다.
- 따라서 B에서 탐색한 D, E까지의 거리는 2(1 + 1)가 된다.
- C에서 탐색한 F까지의 거리 또한 (A에서 C까지의 거리) + (C에서 F까지의 거리) = 2임을 알 수 있다.

#### 깊이 우선 탐색(DFS, Depth-First Search)
> 깊이 우선 탐색은 시작 정점에서 탐색 가능한 최대 깊이의 정점까지 탐색한다. 만약 최대 깊이인 정점에 도달했다면 방문한 정점들을 역순으로 재방문하면서 탐색 가능한 정점이 있는지 확인한다.
> 탐색 가능한 정점이 있다면 해당 정점부터 다시 최대 깊이 정점까지 탐색을 진행한다.
> 깊이 우선 탐색은 재귀호출 또는 스택으로 구현할 수 있다.

![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/81b0541e-b66c-4178-8d70-5998498273a6)
![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/6054bb6c-60ed-400a-b061-94f061a09ae8)

1. 정점 A에서 탐색을 시작한다. 스택에 정점 A를 삽입한다.
2. 정점 A에서 탐색 가능한 정점 B, C 중 B를 방문한다. 스택에 정점 B를 삽입한다.
3. 정점 B에서 탐색 가능한 정점 D, E 중 D를 방문한다. 스택에 정점 D를 삽입한다.
4. 정점 D에서 탐색 가능한 정점 C, F 중 C를 방문한다. 스택에 정점 C를 삽입한다.
5. 정점 C에서 탐색 가능한 정점 F를 방문한다. 스택에 정점 F를 삽입한다.
6. 정점 F에서 탐색 가능한 정점 E를 방문한다. 스택에 정점 E를 삽입한다.

정점 E에서 더 이상 탐색 가능한 정점이 없으므로 탐색 가능한 최대 깊이에 도달했다고 할 수 있다. 따라서 스택에 있는 정점들을 역순으로 방문하며 탐색 가능한 정점이 있는지 확인해야한다.


![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/56e25706-80d4-459b-a370-1c290badaa3b)
![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/95c61dee-8f6e-4f7e-bd4a-fc11dffb09d7)

1. 스택에서 pop을 하면 정점 E가 나온다. E에서 탐색 가능한 정점은 더이상 존재하지 않는다.
2. 스택에서 pop을 하면 정점F가 나온다. F에서 탐색 가능한 정점은 더이상 존재하지 않는다.
3. 스택에서 pop을 하면 정점 C가 나온다. C에서 탐색 가능한 정점은 더이상 존재하지 않는다.
4. 스택에서 pop을 하면 정점 D가 나온다. D에서 탐색 가능한 정점은 더이상 존재하지 않는다.
5. 스택에서 pop을 하면 정점 B가 나온다. B에서 탐색 가능한 정점은 더이상 존재하지 않는다.
6. 스택에서 pop을 하면 정점 A가 나온다. A에서 탐색 가능한 정점은 더이상 존재하지 않는다.

만약 pop을 한 정점에서 탐색 가능한 정점이 있다면 정점을 다시 스택에 push하면서 탐색을 수행한다.
스택을 사용하지 않고 재귀로 구현을 하면 방문해야 할 정점을 저장할 필요가 없어서 BFS 대비 저장 공간을 덜 사용한다.

## 4. 3. 2 트리
> 트리(tree)는 그래프의 한 종류로 사이클이 없어서 계층적 관계를 표현할 수 있다.

![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/941526f1-0af7-4e21-8549-eac4de56f69d)

- 루트 노드(root node): 부모 노드가 없는 노드로, 트리에는 하나의 루트 노드가 존재한다.
- 부모 노드(parent node): 루트 노드 방향으로 연결된 노드다.
- 자식 노드(child node): 루트 노드의 반대 방향으로 연결된 노드다.
- 단말 노드(leaf node): 자식 노드가 없는 노드다.
- 형제 노드(sibling node): 부모 노드가 같은 노드다.
- 레벨(level): 루트 노드로부터 노드의 상대적 위치를 의미한다. 일반적으로 루트 노드의 레벨은 0이다.
- 높이(height): 트리의 최대 레벨 + 1을 의미한다.
- 차수(degree): 자식 노드의 개수를 의미한다.

### 이진트리
> 이진 트리(binary tree)는 자식 노드가 최대 2 개인 트리다.

#### 1. 완전 이진 트리(complete binary tree)
> 트리의 마지막 레벨을 제외한 모드 레벨에 노드가 채워져 있으며, 마지막 레벨은 왼쪽에서부터 오른쪽으로 노드가 채워져 있는 이진 트리다.

![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/86c7195c-523d-4871-b877-f239ea9ce08d)

#### 2. 포화 이진 트리(perfect binary tree)
> 트리의 마지막 레벨까지 노드가 모두 채워져 있는 이진트리다. 따라서 포화 이진 트리는 완전 이진 트리라고 할 수 있다.

![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/6b91c79b-4bbd-4c97-8989-567f0187c297)

#### 3. 이진 탐색 트리(BST, Binary Search Tree)
> 한 노드의 왼쪽 서브 트리는 해당 노드의 값보다 작은 값을 노드로 구성되고, 오른쪽 서브 트리는 해당 노드의 값보다 큰 값을 가진 노드로 구성된 트리다.

- 균형 잡힌 이진 탐색 트리에서는 루트 노드와 가까운 노드일수록 검색해야하는 노드 개수가 절반으로 줄어든다.
- 따라서 값을 검색하는 데 O(log n)이 소요 된다.(n은 노드 개수) 하지만 균형이 잡히지 않은 이진 탐색 트리에서는 검색하는 데 시간 복잡도 O(n)이 소요되므로 이진 탐색 트리를 이용하는 장점이 사라진다!

![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/c38ec093-c5be-48c4-95b4-9e558a19ff43)

그래서 완전 이진 트리로 이진 탐색 트리를 구성하려면 균형 이진 탐색 트리(balanced BST)가 필요하다.
균형 이진 탐색 트리의 대표적인 예로는 레드-블랙 트리와 AVL 트리가 있다.

##### 데이터 추가
> 이진 탐색 트리에서 데이터 추가는 루트 노드부터 차례대로 값을 비교해 나가면서 삽입할 자리를 찾는 방식이다.
> 추가하려는 데이터가 비교하는 노드보다 값이 큰 경우는 오른쪽 자식 노드와 비교를 수행하고, 작은 경우는 왼쪽 자식 노드와 비교를 수행한다. 다음과 같은 이진 탐색 트리에 노드 13을 추가하는 과정은 다음과 같다.

![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/0a5f9b6f-5c5b-499d-bd58-e7f6b443460e)
1. 추가하려는 데이터 13은 루트 노드의 데이터인 15보다 작다. 따라서 다음 비교는 루트 노드의 왼쪽 자식 노드와 수행한다.
2. 추가하려는 데이터 13은 왼쪽 자식 노드인 10보다 크다. 따라서 다음 비교는 해당노드의 오른쪽 자식 노드와 수행한다.
3. 오른쪽 자식 노드의 자리가 비었으므로 13을 해당 자리에 추가한다.

##### 데이터 삭제
> 이진 탐색 트리에서 데이터를 삭제하는 경우는 자식 노드의 개수에 따라 3가지로 나눌 수 있다.

- 자식 노드가 없는 경우: 해당 노드만 삭제하면 된다. 다음 이진 탐색 트리에서 데이터 17을 삭제한다고 했을 때 데이터 17을 가진 노드는 자식 노드가 없으므로 해당 노드만 삭제하면 연산이 끝난다.
  ![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/310986e7-b7f4-41f4-af5e-5ffd13299d90)

- 자식 노드가 1개인경우: 자식 노드를 삭제한 노드의 위치로 옮기면 된다. 다음 이진 탐색 트리에서 데이터 10을 삭제한다고 했을 떄 데이터 10을 가진 노드는 데이터 5를 가진 자식 노드가 있다. 따라서 10을 가진 노드 자리에 5를 가진 노드를 위치시키면 된다.
  ![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/b7433ecd-b082-495b-8626-53d40b766272)

- 자식 노드가 2개인 경우: 오른쪽 서브 트리에서 가장 작을 값을 삭제한 노드 위치로 옮기면 된다. 또는 왼쪽 서브 트리에서 가장 큰 값을 삭제한 노드 위치로 옮겨도 된다. 다음 이진 탐색 트리에서 데이터 15를 삭제한다고 했을 떄 데이터 15를 가진 노드는 자식 노드가 2개 있다. 이때 오른쪽 서브 트리에서 가장 작은 값을 찾아 데이터 15가 있던 자리에 넣는다. 오른쪽 서브 트리에서 가장 작은 값을 찾아 데이터 15가 있던 자리에 넣는다. 오른쪽 서브 트리에서 가장 작은 값은 17이므로 17을 가진 노드를 15가 있던 자리에 위치시키면 된다.

![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/e474f587-240a-47e1-94cb-bb057df5a9d2)

#### 4. 균형 이진 탐색 트리
> 균형 이진 탐색 트리는 삽입이나 삭제 연산을 수행해도 트리의 균형을 유지하는 트리를 의미한다. 앞서 설명한 것처럼 이진 탐색 트리가 불균형인 경우 시간 복잡도에서 이점을 볼 수 없다는 단점을 보완한 트리다.
> 대표적인 예로 레드-블랙 트리와 AVL 트리가 있다.

##### 1. 레드-블랙 트리
> 레드-블랙 트리(red-black tree)는 노드가 검은색 또는 빨간색인 트리로, 정해진 규칙을 만족하면서 균형을 유지하는 트리다.

![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/3470473b-f35a-41ca-bcb5-a4ec7c6e8d28)

레드 블랙 트리는 이진 탐색 트리이면서 추가로 충족해야 하는 조건이 있다. 트리의 데이터에 대한 연산을 수행했을 때 다음 조건을 만족하지 못하면 회전과 색 변환을 해서 노드를 재배치 해야한다.
- 모든 노드는 검은색 또는 빨간 색이다.
- 루트 노드는 검은 색이다.
- 모든 단말 노드(NIL)는 검은색이다. 단말 노드는 트리의 끝을 나타내며 값을 갖지 않는다.
- 빨간색 노드의 자식 노드는 검은색이며 빨간색 노드가 연속으로 나올 수 없다.
- 루트 노드에서 임의의 단말 노드까지 경로에 검은색 노드의 개수는 모두 같다.

##### 2. AVL 트리
> AVL 트리는 자가 균형 이진 탐색 트리로, 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차이를 유지해 균형을 잡는 트리다. 높이 차이를 아려면 왼쪽 서브 트리의 높이에서 오른쪽 서브 트리의 높이를 뺀 값인 BF(Balance Factor)를 사용한다.

- 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차이는 최대 1이다.
- 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차이가 1보다 커지면 균형을 잡아 높이 차이를 줄인다.

AVL 트리에는 LL, RR, LR, RL이라는 4가지 불균형 상황이 있다. 불균형 상황이면 트리를 회전해 균형을 유지한다.
오른쪽 회전은 해당 노드를 중심으로 시계방향 회전을, 왼쪽 회전은 해당 노드를 중심으로 반시계 방향 회전을 의미한다.

1. LL(Left Left) 불균형: 왼쪽으로 불균형을 이룰 경우에 가운데 노드를 중심으로 오른쪽으로 회전해서 균형을 맞춘다.
   ![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/8d385522-b725-41f8-a705-fde82ae518d7)

2. RR(Right Right) 불균형: 오른쪽으로 불균형을 이룰 경우에 가운데 노드를 중심으로 왼쪽으로 회전해서 균형을 맞춘다.
   ![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/72aa6c32-f65c-43a0-9af2-d0460d6633cc)

3. LR(Left Right) 불균형: 왼쪽, 오른쪽으로 불균형을 이룰 경우에 마지막 레벨에 위치한 노드를 중심으로 왼쪽으로 회전한 후 다시 오른쪽으로 회전해서 균형을 맞춘다.
   ![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/f8331796-baf5-41b3-8a5f-3f1ac03c04cf)

4. RL(Right Left) 불균형: 오른쪽, 왼쪽으로 불균형을 이룰 경우 마지막 레벨에 위치한 노드를 중심으로 오른쪽으로 회전한 후 왼쪽으로 회전해서 균형을 맞춘다.
   ![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/65e23df8-f37e-4d1f-a151-3cfdf38fc4c6)

## 4. 3. 3 우선순위 큐
> 우선순위 큐(priority queue)는 우선순위가 높은 데이터가 먼저 나오는 자료구조다.
> 큐와 동일하게 데이터 삽입과 삭제 연산을 지원한다. 데이터 삭제 연산을 수행하면 우선순위가 가장 높은 데이터를 얻을 수 있다.
> 우선순위 큐를 구현하는 방식은 배열, 연결 리스트, 완전 이진 트리인 힙이 있다.

| 구현 방법                         | 삽입     | 삭제     |
| --------------------------------- | -------- | -------- |
| 배열(unsorted array)              | O(1)     | O(n)     |
| 연결 리스트(unsorted linked list) | O(1)     | O(n)     |
| 배열(sorted array)                | O(n)     | O(1)     |
| 연결 리스트(sorted linked list)   | O(n)     | O(1)     |
| 힙(heap)                          | O(log n) | O(log n) |

## 4. 3. 4 힙
> 힙(heap)은 완전 이진 트리로, 최댓값 또는 최솟값을 빠르게 찾을 수 있는 자료구조다.
> 우선순위 큐를 구현하는데 자주 사용한다.

- 최대 힙(max heap): 부모 노드의 값이 자식 노드의 값보다 크거나 같은 완전 이진트리다.
- 최소 힙(min heap): 부모 노드의 값이 자식 노드의 값보다 작거나 같은 완전 이진트리다.

![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/210d2baa-7235-46e2-863e-fa1966b3296c)

#### 삽입 연산
> 힙에 데이터를 삽입할 때는 힙의 맨 끝에서 이루어진다. 부모 노드와 우선순위(최댓값 또는 최솟값)를 비교해 부모 노드보다 우선순위가 높으면 위치를 바꾸면서 루트노드까지 비교한다.

![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/c4fb5202-cea3-4e14-ab6a-c9d5f41709f6)

1. 최대 힙의 맨 끝에 데이터 30을 가진 노드를 추가한다.
2. 최대 힙이므로 부모 노드의 값이 30보다 작으면 새로 추가한 노드와 위치를 바꿔야한다. 새로 추가한 노드의 부모 노드 값은 19이므로 새로 추가한 노드의 우선 순위가 높다. 따라서 자리를 바꾼다.
3. 데이터 30을 가진 노드와 부모 노드의 값을 비교한다. 부모 노드의 값인 25보다 크므로 자리를 바꾼다.
4. 데이터 30을 가진 노드가 루트드가 되어 비교 가능한 노드가 없으므로 연산을 종료한다.

#### 삭제 연산
> 힙에서 데이터 삭제는 우선순위가 가장 높은 노드를 삭제하는 연산이다.
> 즉, 루트 노드를 삭제하게 된다. 삭제한 후에는 루트 노드 자리에 힙의 마지막 노드(마지막 레벨의 가장 오른쪽 노드)를 옮긴 후 힙을 재정렬한다.

![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/6d863584-3006-4305-8f0f-a6e60f86110b)

1. 루트 노드를 삭제한다.힙의 마지막 노드(2)를 루트 노드 자리로 옮긴다.
2. 새로운 루트 노드(2)와 자식 노드 2개(10, 19) 중에서 우선순위가 높은 자식 노드의 값(19)을 비교한다. 자식 노드의 우선순위가 높으므로 위치를 바꾼다.
3. 바뀐 위치에서 자식 노드와 값을 비교한다. 자식 노드의 값(17)보다 우선순위가 낮으므로 위치를 바꾼다.
4. 비교할 수 있는 자식 노드가 없으므로 연산을 종료한다.

## 4. 3. 5 해시 테이블
> 해시 테이블(hash table)은 하나의 키(key)에 대해 하나의 값(value)을 저장하는 형태의 자료구조다.
> 키는 해시 함수(hash function)를 사용해 해시를 얻을 수 있다.
> 해시는 값이 저장되어 있는 해시 테이블의 인덱스를 찾을 수 있는 값이다.
> 해시 함수에 키를 넣으면 해시 테이블에서 매칭되는 결과 값에 한 번에 접근할 수 있다.
> 따라서 연산은 평균적으로 `O(1)`의 시간 복잡도를 갖는다.

![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/62798aa6-43f6-496a-a706-6b08be87e492)

### 해시 충돌
> 서로 다른 키에 대해 같은 해시가 도출되는 것을 말한다.
> 해시 충돌 문제를 해결하기 위한 방법에는 체이닝과 개방 주소법이 있다.

#### 1. 체이닝(chaining)
> 해시 충돌이 발생하면 같은 해시가 나오는 키의 값을 연결 리스트에 저장하는 방식이다.
> 연결 리스트에 노드를 저장하므로 저장 공간에 대한 제약이 적다는 장점이있다.
> 하지만 하나의 해시(인덱스)에 노드가 몰릴 수 있다는 단점이 있다.

![image](https://github.com/woowacourse-study/2023-cs-study/assets/137751140/6097e95d-ceb2-43dd-ba3f-2c60cf099ab4)

### 2. 개방 주소법(open addressing)
> 해시 충돌이 발생했을 때 해당 해시가 아닌 비어 있는 공간에 값을 저장하는 방식이다.

#### 선형 조사법(linear probing)
> `h[n]`에서 해시 충돌이 발생하면 `h[n+1]` 과 같이 다음 인덱스로 이동하면서 빈 공간을 찾는 방식이다.
> 선형 조사법은 충돌이 발생하면 다음 인덱스에 데이터를 저장하므로 특정 인덱스 범위에 데이터가 몰리는 군집화 현상이 나타나는 단점이 있다.

#### 이차 조사법(quadratic probing)
> 이차는 거듭제곱을 의미한다. `h[n]`에서 해시 충돌이 발생하면 `h[n+1x1]`, `h[n+2x2]`, `h[n+3x3]`과 같이 거듭제곱한 인덱스 만큼 이동하고 빈 공간을 찾으면 데이터를 저장하는 방식이다.
> 이차 조사법은 선형 조사법보다 군집화 현상이 상대적으로 적지만, 완전히 해겨한다고 할 수는 없다.

#### 이중 해싱(double hashing)
> 해시 충돌이 발생하면 다른 해시 함수를 한 번 더 적용하는 방법이다.
