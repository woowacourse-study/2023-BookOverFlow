# 4.2 선형 자료구조

## 선형 자료구조 (linear data structure)

- 연속적으로 데이터가 나열되는 자료구조
- 하나의 데이터 뒤에 다른 하나의 데이터가 연결
- e.g. 배열, 리스트, 스택, 큐 등

## 배열 (array)

- 정해진 크기만큼 데이터가 일렬로 저장되는 정적 자료구조
- **element**: 각 데이터
- **index**:데이터를 가리키는 번호

### 접근

- `O(1)`
- (처음 데이터의 주소 값) + (데이터 타입의 메모리 크기) * (접근하려는 데이터의 인덱스)

### 검색

- `O(n)`
- 인덱스 0부터 하나씩 탐색하므로

### 삽입

- `O(n)`
- 데이터들을 뒤로 한 칸씩 이동

### 삭제

- `O(n)`
- 데이터들을 앞으로 한 칸씩 이동

## 연결 리스트 (linked list)

- 선형 자료구조 중 하나
- 크기가 정해져있지 않은 동적 자료구조
- 여러 개의 **node**로 구성
    - 노드 - `데이터`, `다음 노드의 주소 값` 을 저장
- **head 포인터**: 첫 번째 노드를 가리킴
- **tail 포인터**: 마지막 노드를 가리킴

### 검색

- `O(n)`
- 첫 번째 노드부터 하나씩 값을 확인하는 선형 탐색 필요

### 추가

- `O(n)`
- 데이터를 추가하려는 위치로 이동하기까지 최대 O(n)이 소요되고,
    
    추가 연산 자체는 O(1)이 소요된다.
    

### 삭제

- `O(n)`
- 데이터를 추가하려는 위치로 이동하기까지 최대 O(n)이 소요되고,
    
    삭제 연산 자체는 O(1)이 소요된다.
    

### 다른 연결 리스트

- 위에서 설명한 것은 `단순 연결 리스트`

**이중 연결 리스트 (double linked linear list)**

- 노드 - `데이터`, `앞 노드의 주소 값`, `다음 노드의 주소 값` 을 저장
- 양방향 탐색이 가능
- 구현이 상대적으로 어렵고, 메모리 차지가 많아짐

**원형 연결 리스트 (circular linked linear list)**

- 헤드 포인터가 마지막 노드를 가리킴
- 마지막 노드의 다음 노드 주소 값이 NULL이 아닌 첫 번째 노드의 주소 값을 가리킴
- 삽입과 삭제 연산을 효율적으로 수행 가능

## 스택 (stack)

- 데이터를 쌓는 형태
- **LIFO** (Last In First Out, **후입선출**) 형태의 자료구조
- **top**: 마지막으로 저장한 데이터의 인덱스
- 구현 시 **배열**, **연결 리스트**를 이용
- 최근에 처리한 작업들을 하나씩 꺼낼 때 사용
    - e.g. 어떤 작업의 주소를 취소할 때, 웹 브라우저에서 뒤로가기 할 때

### push (삽입)

- `O(1)`
- top 변수를 이용하기 때문

### pop (삭제)

- `O(1)`

### peek

- `O(1)`
- 가장 위에 있는 데이터 확인

### isEmpty

- `O(1)`

### isFull

- `O(1)`

## 큐 (queue)

- 데이터가 순차적으로 들어오는 형태
- **FIFO** (First In First Out, **선입선출**) 형태의 자료구조
- **front**: 큐의 맨 앞
- **rear**: 큐의 맨 뒤
- 구현 시 **배열**, **연결 리스트**를 이용
- 작업 요청이 들어온 순서대로 작업을 처리하기 위해 사용
    - e.g. CPU를 할당받기 위해 프로세스들이 대기하는 준비 큐

### enqueue (삽입)

- `O(1)`
- rear에 새로운 데이터 삽입

### dequeue (삭제)

- `O(1)`
- front에서 데이터 삭제

### peek

- `O(1)`
- front에 있는 데이터 확인

### isEmpty

- `O(1)`

### isFull

- `O(1)`

### 배열로 구현하는 큐의 문제점

- 삽입 연산으로 큐를 꽉 채운 뒤, 1개만 남기고 삭제 연산을 수행하면
    
    → [ ] [ ] [ ] [ ] [ data ] 의 형태가 됨
    
- front, rear가 같은 데이터를 가리키므로, 큐에 데이터가 가득 찼다고 판단될 수 있음
- 이를 해결하기 위한 방법: 순환 큐

### 순환 큐 (원형 큐, circular queue)

- [ ] [ ] [ ] [ ] [ data ] 에서 삽입 연산을 진행하면
    
    → [ new ] [ ] [ ] [ ] [ data ] 의 형태가 됨
    
- 배열의 시작과 끝이 구분되지 않아 데이터의 삽입과 삭제가 유연하게 수행 가능

## 덱 (deque, double-ended queue)

- **큐 + 스택** 형태의 자료구조
- 양쪽 끝에서 데이터의 삽입/삭제가 모두 가능