# 4-2 선형 자료구조

> 선형 자료구조(linear data structure)는 연속적으로 데이터가 나열되는 자료구조를 나타낸다. 즉, 하나의 데이터 뒤에 다른 하나의 데이터가 연결된다.
> 대표적인 선형 자료구조로는 배열, 리스트, 스택, 큐 등이 있다.

## 4. 2. 1 배열
> 배열(array)은 정해진 크기만큼 데이터가 일렬로 저장되는 정적(static)자료 구조다.
> 각 데이터를 배열의 요소 또는 원소(element)라고 하며
> 데이터를 가리키는 번호를 인덱스(index)라고 한다.

### 배열의 원소 접근
> 배열에서 특정 인덱스의 데이터에 접근하는 데 걸리는 시간 복잡도는 O(1)이다.

배열의 첫 번째 데이터에 대한 주소값에 (데이터 타입의 메모리 크기) x (접근하려는 인덱스)를 더하면 되기 때문이다.
즉, 더하기 연산으로 한 번에 접근할 수 있으므로 시간 복잡도는 O(1)이 된다.

### 배열의 원소 검색
> 배열에서 데이터를 검색하는 데 걸리는 시간 복잡도는 O(n)이다.

n의 크기를 가진 배열에서 최악의 경우 n-1 인덱스까지 검색을 해야하므로 O(n)이다.

### 배열의 원소 삽입
> 배열에서 특정 위치에 새로운 데이터를 삽입하는 데 걸리는 시간 복잡도는 O(n)이다.

데이터를 추가하려는 인덱스에 이미 데이터가 있다면 해당 데이터 부터 뒤로 한칸 씩 옮겨야하기 때문에 O(n)이다.
반면에 배열의 가용 공간보다 배열 크기가 작은 경우, 마지막 위치에 원소를 추가하려는 경우에는 원소들을 뒤로 한 칸씩 옮기는 연산이 없기 때문에 O(1)이다.

### 배열의 원소 삭제
> 배열에서 특정 인덱스의 데이터를 삭제하는 데 걸리는 시간 복잡도는 O(n)이다.

배열에서 데이터를 삭제하려는 경우 뒤에 있던 데이터들의 인덱스를 한칸씩 앞당겨 줘야하는 연산이 필요하기 때문에 O(n)이다.
삽입 때와 마찬가지로 삭제하려는 데이터가 배열의 마지막 인덱스라면 시간 복잡도는 O(1)이 된다.

### 코틀린에서의 배열
> [[Array]]는 실제로 정의된 내용이 많지는 않다. 모두 확장함수로 마치 Array Class 내부에 정의되어있는 것처럼 되어있다.

## 4. 2. 2 연결 리스트
> 연결리스트는 대표적인 선형 자료구조의 하나로, 배열과 달리 크기가 정해져 있지 않은 동적 자료구조이다.
> 이는 연결 리스트가 여러 개의 노드로 구성되기 때문이다. 노드는 데이터와 다음 노드가 저장된 주소 값을 가지고 있다.
> 연결 리스트는 헤드 포인터와 테일 포인터로 시작과 끝을 알 수 있다.
> 연결 리스트에서 첫 번째 노드는 헤드 포인터가 가리키고, 마지막 노드는 가리킬 다음 노드가 없다. 그래서 다음 노드를 가리키는 주소값이 null이다. 마지막 노드는 테일 포인터가 가리킨다.

- 연결 리스트는 데이터의 추가 및 삭제가 자유롭다.
  -> 기존의 노드들의 위치를 이동할 필요가 없기 때문이다.
- 연결 리스트는 인덱스가 없기 때문에 특정 위치의 데이터에 접근하는 데 배열보다 시간이 오래 걸린다.

### 연결 리스트의 검색
> 연결 리스트에서 특정 데이터를 검색하는 데 드는 시간 복잡도는 O(n)이다.
> 인덱스가 없기때문에 하나씩 순회하며 찾아야한다.

### 연결 리스트의 원소 추가
> 연결 리스트에서 데이터를 추가하는 연산 자체는 O(1)이다.
> 하지만 데이터를 추가하려는 위치의 노드까지 이동하기 까지 O(n)이 소요된다.
> 따라서 연결 리스트의 맨 앞에 데이터를 추가하는 경우에는 O(1)이 소요되고, 나머지 위치에 노드를 추가하는 경우에는 O(n)이 소요된다.

### 연결 리스트의 원소 삭제
> 연결 리스트에서 첫 번째 데이터를 삭제하는 경우 O(1)이 소요된다.
> 하지만 첫 번째 데이터를 제외한 나머지 위치에서 데이터를 삭제하는 경우에는 해당 위치까지 이동하기 위한 연산을 해서 최대 O(n)이 소요될 수 있다.

### 연결 리스트의 종류

#### 1. 이중 연결 리스트(double linked linear list)
> 이중 연결 리스트의 노드는 앞 노드의 주소 값과 다음 노드의 주소 값을 모두 저장한다.
> 그래서 단순 연결 리스트와 달리 양방향 탐색이 가능한 구조다.

##### 이중 연결 리스트의 특징
- 단순 연결 리스트보다 구현하기 어렵다.
- 한 노드당 주소 값을 2개 저장해야 해서 메모리를 많이 차지하는 단점이 있다.
- 노드의 연결 순서와 무관하게 노드를 연속적으로 탐색해야 하는 경우에 단순 연결 리스트 대비 시간 면에서 효율적이다. (ex. 앞으로 갔다 뒤로 갔다.)

#### 2. 원형 연결 리스트(circular linked linear list)
- 원형 연결 리스트는 마지막 노드가 null 값이 안니라 첫 번째 노드의 주소 값을 가리키는 구조다.
- 다른 연결 리스트와 달리 헤드가 마지막 노드를 가리키면 삽입과 삭제 연산을 효율적으로 수행할 수 있다.

##### 원형 연결 리스트의 특징
- 새로운 노드를 맨 마지막 또는 맨 앞에 삽입할 때 상수 시간이 소요된다.
- 헤드가 마지막 노드를 가리키고 있어서 O(1)에 마지막 노드에 접근할 수 있다.
- 마지막 노드가 가리키던 주소값을 새로운 노드가 가리키게 하고, 마지막 노드는 새로운 노드를 가리키게 한다.
- 헤드가 새로운 노드를 가리키면 마지막에 노드를 추가하는 경우에도 O(1)에 수행할 수 있다.
- 순환구조라서 어느 노드던지 배열의 다른 노드에 모두 접근할 수 있다.

## 4. 2. 3 스택

![stack](https://blog.kakaocdn.net/dn/lU13u/btqFzGa6Eip/EMJh4HSKrS8RFPhmCpmEc0/img.png)

> 스택(stack)은 데이터를 쌓는 형태로, 마지막에 들어온 데이터가 먼저 나가는 LIFO(Last In First Out, 후입 선출) 형태의 자료구조이다.

| 연산    | 설명                                | 시간 복잡도 |
| ------- | ----------------------------------- | ----------- |
| push    | 스택에 새로운 데이터 삽입           | O(1)        |
| pop     | 스택에서 가장 위에 있는 데이터 삭제 | O(1)        |
| peek    | 스택에서 가장 위에 있는 데이터 삭제 | O(1)        |
| isEmpty | 스택이 비어 있는지 확인             | O(1)        |
| isFull  | 스택이 가득 찼는지 확인             | O(1)        |      |

### 스택의 사용 사례
1. 웹 브라우저 뒤로가기 할 때 등 최근에 처리한 작업들을 하나씩 꺼낼 때
2. 그림판 이전작업 불러 오기
3. 액티비티 스택
## 4. 2. 4 큐

![](https://lamarr.dev/images/algorithm/queue.jpg)

> 큐(queue)는 데이터가 순차적으로 들어오는 형태로, 먼저 들어온 데이터가 먼저 나가는 FIFO(First In First Out, 선입 선출) 형태의 자료구조다.

- front
    - 큐의 맨 앞
    - 데이터가 삭제되는 곳
- rear
    - 큐의 맨 끝
    - 데이터가 들어오는 곳


| 연산    | 설명                           | 시간 복잡도 |
| ------- | ------------------------------ | ----------- |
| enqueue | 큐의 rear에 새로운 데이터 삽입 | O(1)        |
| dequque | 큐의 front에서 데이터 삭제     | O(1)        |
| peek    | 큐의 front에 있는 데이터 확인  | O(1)        |
| isEmpty | 큐가 비어있는지 확인           | O(1)        |
| isFull  | 큐가 가득 찼는지 확인          | O(1)        |

### 문제점
> 배열로 큐를 구현 시 enqueue로 데이터를 채우고 dequeue를 하면 결국에 데이터를 앞으로 한칸씩 옮기는 과정이 일어난다. 안그러면 데이터를 더이상 rear로 넣지 못하기 떄문이다.
> 하지만 데이터를 한 칸씩 옮기는 것도 결국에 O(n)인 무거운 작업이기 때문에 나온 것이 원형 큐(circular queue)다.

### 원형 큐(circular queue)
![](https://i.namu.wiki/i/wZ8T1JTAFS03j1evNJyHY3dMns0jHpmwX9BW9SnJ2lSR2TpDX96Zx1EZ4mldEDUTLq6gjAkMKTtHA5S4kmlN6D9Y9228n6ajP3_0CzZj5JUqvB3hKrS0sBU9OFIYECf-GYVPc5ayrab5GWMYTi6B-g.webp)

### 덱(deque; Double Ended Queue)
![](https://i.namu.wiki/i/FnXa1jqlRVlgURw3TorVe3gxlZfuExitlwNBGLJFitibWPg-BV22tRDUvWqwQUc4aKf3imvzMCvfEXOOA_HneCXfJiWB6_yvS0TKnmxf7u2nB8ruISB-MrcjoDArb-OUKua9OmXsmMI2QYRKu0TxKg.webp)

> 양쪽 끝에서 데이터의 삽입과 삭제가 모두 가능한 자료구조로, 큐와 스택을 합친 형태다.
