# JCF

Java 플랫폼에는 컬렉션 프레임워크가 포함되어 있습니다. 컬렉션은 객체 그룹을 나타내는 객체(예: 클래식 벡터 클래스)입니다. 컬렉션 프레임워크는 컬렉션을 표현하고 조작하기 위한 통합 아키텍처로, 구현 세부 사항과 독립적으로 컬렉션을 조작할 수 있습니다.

## 컬렉션 프레임워크의 주요 장점
- 데이터 구조와 알고리즘을 제공하므로 사용자가 직접 작성할 필요가 없어 프로그래밍 노력이 줄어듭니다.
- 데이터 구조와 알고리즘의 고성능 구현을 제공함으로써 성능을 향상시킵니다. 각 인터페이스의 다양한 구현이 상호 교환 가능하므로 구현을 전환하여 프로그램을 조정할 수 있습니다.
- 컬렉션을 주고받을 수 있는 공통 언어를 설정하여 서로 관련이 없는 API 간의 상호 운용성을 제공합니다.
- 여러 개의 임시 컬렉션 API를 학습해야 하므로 API 학습에 필요한 노력이 줄어듭니다.
- 애드혹 컬렉션 API를 생성할 필요가 없으므로 API를 설계하고 구현하는 데 필요한 노력을 줄일 수 있습니다.
- 컬렉션과 컬렉션을 조작할 수 있는 알고리즘에 대한 표준 인터페이스를 제공하여 소프트웨어 재사용을 촉진합니다.

## 컬렉션 프레임워크의 구성
- 컬렉션 인터페이스
    - set, list, map과 같은 다양한 유형의 컬렉션을 나타냅니다. 이러한 인터페이스는 프레임워크의 기초를 형성합니다.
- 범용 구현
    - 컬렉션 인터페이스의 기본 구현입니다.
- 레거시 구현
    - 이전 릴리즈의 컬렉션 클래스인 vector와 hashtable은 컬렉션 인터페이스를 구현하기 위해 개조되었습니다.
- 특수 목적 구현
    - 특수한 상황에서 사용하도록 설계된 구현입니다. 이러한 구현은 비표준 성능 특성, 사용 제한 또는 동작을 표시합니다.
- 동시 구현
    - 고도의 동시 사용을 위해 설계된 구현입니다.
- 래퍼 구현
    - 동기화와 같은 기능을 다른 구현에 추가합니다.
- 편의성 구현
    - 컬렉션 인터페이스의 고성능 '미니 구현'.
- 추상적인 구현
    - 사용자 지정 구현을 용이하게 하기 위한 컬렉션 인터페이스의 부분 구현.
- 알고리즘
    - 목록 정렬과 같이 컬렉션에서 유용한 기능을 수행하는 정적 메서드입니다.
- 인프라
    - 컬렉션 인터페이스에 대한 필수 지원을 제공하는 인터페이스입니다.
- 배열 유틸리티
    - 기본 유형 및 참조 객체의 배열을 위한 유틸리티 함수. 엄밀히 말하면 컬렉션 프레임워크의 일부가 아닌 이 기능은 컬렉션 프레임워크와 동시에 Java 플랫폼에 추가되었으며 일부 동일한 인프라에 의존합니다.

![image](https://github.com/woowacourse-study/2023-cs-study/assets/22425650/baabd525-50d2-4a42-aae2-df1bbab8a94c)
![image](https://github.com/woowacourse-study/2023-cs-study/assets/22425650/aa20b743-da81-4da3-8aa9-6b75ee4cbae3)
### ArrayList (implement List)
- 크기가 가변적이다.
- 기본 생성자로 구현 시 기본 10의 크기를 가진 Object 배열을 가진다.
- 미리 정해둔 배열 크기보다 많은 원소를 가져야할 때 기존의 배열보다 크기가 큰 배열에 복사하는 로직을 가진다.
- 추가 삭제로 인한 시간 복잡도는 `O(n)`
- 동기화 처리가 되어있지 않다.

### Vector (implement List)
- Collection이 나오기 전에 ArrayList를 대신하여 가변크기를 가지는 자료구조로 사용
- syncronized 키워드를 통해 어느 정도 동기화를 지원한다.
- 구버전 호환을 위해 존재한다.

### Stack(extend Vector)
- 후입선출 LIFO(Last-In-First-Out) 자료구조
- 마지막에 들어온 원소가 처음으로 나간다
- 들어올때는 push, 나갈때는 pop이라는 용어를 사용
- Stack은 Vector를 상속하기 때문에 문제점이 많아 잘 안쓰인다. (대신 ArrayDeque 사용)

### LinkedList (implement List, Deque)
- Doubly Linked LIst로 구현이 되어있다.
- Stack과 Queue를 지원하는 메서드들이 구현되어있다.
- 데이터 삽입, 삭제에 대해서 상대적으로 빠른 속도를 가지지만 검색에 대해서는 느리다.

### PriorityQueue (implement Queue)
- 우선 순위를 가지는 큐 (우선 순위 큐)
- 일반적인 큐와는 조금 다르게, 원소에 우선 순위(priority)를 부여하여 우선 순위가 높은 순으로 정렬되고 꺼낸다
- 수행할 작업이 여러 개 있고 시간이 제한되어 있을 때 우선순위가 높은 것부터 수행할때 쓰인다 (네트워크 제어, 작업 스케쥴링)
- 우선순위 큐에 저장할 객체는 필수적으로 **Comparable** **인터페이스**를 구현해야한다. compareTo() 메서드 로직에 따라 자료 객체의 우선순위를 결정하는 식으로 동작되기 때문이다.
- 저장공간으로 배열을 사용하며, 각 요소를 힙(heap) 형태로 저장한다.

### ArrayDeque (implement Deque)
- 스택으로 사용할 때 Stack 클래스보다 빠르며, 대기열로 사용할 때는 LinkedList보다 빠르다.
- 사이즈에 제한이 없다.
- null 요소는 저장되지 않는다

### HashSet(implement Set)
- 배열과 연결 노드를 결합한 자료구조 형태
- 가장 빠른 임의 검색 접근 속도를 가진다
- 추가, 삭제, 검색, 접근성이 모두 뛰어나다
- 대신 순서를 전혀 예측할 수 없다

### LinkedHashSet(implement Set)
- 순서를 가지는 Set 자료구조
- 추가된 순서 또는 가장 최근에 접근한 순서대로 접근 가능
- 만일 중복을 제거하는 동시에 저장한 순서를 유지하고 싶다면, HashSet 대신 LinkedHashSet을 사용하면 된다
- 다만 성능에 있어서 HashSet보다 느리다

### TreeSet(implement SortedSet)
- 이진 검색 트리(binary search tree) 자료구조의 형태로 데이터를 저장
- 중복을 허용하지 않고, 순서를 가지지 않는다
- 대신 데이터를 정렬하여 저장하고 있다는 특징이다
- 정렬, 검색, 범위 검색에 높은 성능을 뽐낸다. 

### HashMap
- Hashtable을 보완한 컬렉션
- 배열과 연결이 결합된 Hashing형태로, 키(key)와 값(value)을 묶어 하나의 데이터로 저장한다
- 중복을 허용하지 않고 순서를 보장하지 않는다
- 키와 값으로 null이 허용된다
- 추가, 삭제, 검색, 접근성이 모두 뛰어나다
- HashMap은 비동기로 작동하기 때문에 멀티 쓰레드 환경에서는 어울리지않는다 (대신 ConcurrentHashMap 사용)

### LinkedHashMap
- HashMap을 상속하기 때문에 흡사하지만, Entry들이 연결 리스트를 구성하여 데이터의 순서를 보장한다.
- 일반적으로 Map 자료구조는 순서를 가지지 않지만, LinkedHashMap은 들어온 순서대로 순서를 가진다.

### HashTable
- 자바 초기 버전에 나온 레거시 클래스
- Key를 특정 해시 함수를 통해 해싱한 후 나온 결과를 배열의 인덱스로 사용하여 Value를 찾는 방식으로 동작된다
- HashMap 보다는 느리지만 동기화가 기본 지원된다
- 키와 값으로 null이 허용 X

### TreeMap
- 이진 검색 트리의 형태로 키와 값의 쌍으로 이루어진 데이터를 저장 (TreeSet 과 같은 원리)
- TreeMap은 SortedMap 인터페이스를 구현하고 있어 Key 값을 기준으로 정렬되는 특징을 가지고 있다.
- 정렬된 순서로 키/값 쌍을 저장하므로 빠른 검색(특히 범위 검색)이 가능하다
- 단, 키와 값을 저장하는 동시에 정렬을 행하기 때문에 저장시간이 다소 오래 걸리다
- 정렬되는 순서는 숫자 → 알파벳 대문자 → 알파벳 소문자 → 한글 순이다.
