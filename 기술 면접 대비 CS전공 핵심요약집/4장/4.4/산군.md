# 4.4(JCF)

## JCF(Java Collection Framework)(⭐⭐⭐)

- 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합
    - 데이터 보관 자료구조 및 데이터 처리 알고리즘을 구조화하여 클래스로 구현해놓은 것
- 컬렉션마다 문법이 달랐고, 공통 인터페이스의 필요성을 느껴 JCF가 만들어짐

![Untitled](4%204(JCF)%20058dbaca6781402ab6559f3b4cdd0da6/Untitled.png)

## 컬렉션 인터페이스

- Iterable을 상속 받으며, Map과 달리 Iterator() 메서드가 존재한다.

### List

- 순서가 있는 데이터의 집합으로, 데이터의 중복을 허용한다.

**ArrayList**

- 가변 크기의 선형 리스트로 저장 용량이 존재한다.
- 기본 저장 용량은 ‘10’이며, 저장 용량을 초과하면 자동으로 용량이 증가되며 데이터가 추가된다.

**LinkedList**

- 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 자료구조이다.

**Vector**

- JDK 1.0부터 있던 자료구조로, 호환성을 위해 남겨졌지만 현재는 레거시 상태이다.
- ArrayList와 유사하며, 차이점은 ArrayList는 비동기방식이고 Vector는 동기방식이다.
- Vector는 ArrayList보다 성능이 좋지 못하며, 스레드 안전하지 못하므로 지양한다.
    - 멀티 스레드 환경에선 ArrayList synchronized방식을 사용한다.

**Stack**

- Vector를 상속하여 사용하는 LIFO 방식의 자료구조
    - Vector가 레거시 클래스이므로, 오라클 문서에선 Deque를 이용해 구현하길 권고함

### **Queue**

- FIFO 방식의 자료구조
- 주로 LinkedList를 이용하여 구현한다.

H

**Priority Queue**

- FIFO가 아닌 우선순위 큐이다.
- 우선순위는 comparator를 통해 정의해주거나, comparable 인터페이스를 상속한 객체를 이용해야한다.
    - null 요소는 허용하지 않는다.

**Deque**

- Double-Ended Queue의 약어로, 큐의 양쪽 끝에서 삭제 및 추가가 일어날 수 있는 구조이다.
- 사용방식에 따라 Queue 혹은 Stack이 될 수 있다.
- 구현 클래스로 LinkedList와 ArrayDeque가 있다.

**ArrayDeque**

- 대표적인 Deque의 구현 클래스이다.
    - 사이즈 제한이 없는 가변 배열이다.
    - null 요소는 저장할 수 없다.
    - 비동기처리 방식이다.
    - 원형 큐 방식으로 구현된다.
    - Stack 목적으로 구현했을 때 Stack 보다 빠르며, Queue 구현 목적으로 구현했을 때 LinkedList보다 빠르다.

### Set

- 중복 요소를 저장하지 않으며, 순서 또한 보장되지 않는다.
    - equals()와 hashcode()를 통해 중복요소를 걸러낸다.
    - 저장하기 전 삽입되는 요소의 해시코드 값을 호출하고, 저장되어 있는 해시코드와 비교 후 같은 해시코드가 있다면 equals를 통해 한번 더 비교한다.

**HashSet**

- Set을 이용하기 위해 가장 많이 사용하는 구현 클래스이다.
- HashSet은 해시 알고리즘을 사용하여 검색 속도가 빠르다는 장점이 있다.
- HashMap을 생성자로 인스턴스를 생성한다.

**LinkedHashSet**

- Set과 원리는 같으나 순서를 보장한다.
- HashSet을 상속받으며, LinkedHashMap으로 구현되어 있다.

**TreeSet**

- 중복 요소는 저장하지 않으나, 특정 기준에 따라 정렬이 가능하다.
- TreeMap을 생성자로 인스턴스를 생성한다.

### Map

- 키-벨류 형식으로 저장하는 자료구조이다.
- 키는 중복되지 않으며, 벨류는 중복이 허용된다.
- 키를 통해 데이터에 바로 접근이 가능해 탐색 속도가 빠르다.
- 데이터의 순서를 보장하지 않는다.

**HashTable**

- Map 인터페이스의 구현 클래스이며, 자바 초기 버전에 나온 레거시 클래스이다.
- 키-벨류 모두 null 일 수 없으며, 대부분의 메서드가 동기화처리 되어 있다.
- 키를 특정 해시 함수를 통해 해싱한 후 나온 결과를 배열의 인덱스로 사용하여 벨류를 탐색한다.

**HashMap**

- Map 인터페이스의 구현 클래스이며, HashTable을 보완하였다.
- 비동기로 작동하며, HashTable에 비해 싱글 스레드에서의 성능이 좋다.
    - 멀티 스레드 환경에선 ConcurrentHashMap을 사용한다.

**LinkedHashMap**

- Map 인터페이스의 구현 클래스이며, HashMap을 상속받았다.
- LinkedList를 이용해 데이터의 순서를 보장한다.
    
    

**TreeMap**

- Map 인터페이스의 구현 클래스이며, Key를 기준으로 원하는 방식으로 정렬할 수 있다.
- 레드 블랙 트리로 구현되어 있다.

**Map은 요소라고 정의할만한 것이 모호하기때문에 컬렉션을 상속받지 않는다고 한다.**