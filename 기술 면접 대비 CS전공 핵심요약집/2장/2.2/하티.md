# 2.2 TCP와 UDP

## TCP, UDP

- 전송 계층에서 사용하는 대표적인 프로토콜
    - IP는 네트워크 계층에 해당함
- 전송 계층 (4 layer)
    - 송신자—수신자의 논리적 연결 담당
    - TCP/UDP 프로토콜을 통해 통신을 활성화. 포트를 열어두고, 프로그램들이 전송을 할 수 있도록 제공

## TCP (Transmission Control Protocol)

- 연결형 서비스 지원 (송신부—수신부의 역할을 확인)
- 데이터의 신뢰성 보장 (데이터 손실이 없음을 보장함)
- 데이터 송수신 속도가 느림
- 패킷 교환 방식: 가상 회선 방식 (패킷이 전달되는 회선이 정해져 있음)
- 패킷의 전송 순서 보장
- 패킷의 수신 여부 확인
- 송신부—수신부 1:1 통신

## TCP 핸드셰이킹

송신부 — 수신부를 연결하는 과정에서,

- 연결을 **시작**할 때 `3-way handshaking`
- 연결을 **종료**할 때 `4-way handshaking`

송신부—수신부 간 연결을 제어 및 관리하기 위해 **플래그 값**을 주고 받음

- **SYN** - synchronization, 연결을 생성
- **FIN** - finish, 연결 종료
- **ACK** - acknowledgment, 전송한 데이터를 수신자가 받았음을 알림
- RST - reset, 연결 재설정
- PSH - push, 빠른 응답이 필요한 데이터를 응용 계층으로 즉시 전송
- URG - urgent, 다른 데이터보다 우선순위가 높은 데이터를 전송

### 3-way 핸드셰이킹

상대방 컴퓨터와의 **세션을 수립**하는 과정

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/d4809f18-a915-4e30-8b11-8f015eacff00/516449ad-266d-4451-8d96-041264279f13/Untitled.png)

1. 송신부→수신부 
`SYN(N)`을 전송 
2. 수신부→송신부 
연결 요청을 수락하는 `ACK(N+1)`과 
`SYN(M)`을 전송
3. 송신부→수신부 
`ACK(M+1)`을 전송

### 4-way 핸드셰이킹

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/d4809f18-a915-4e30-8b11-8f015eacff00/8f0e8908-b24d-4289-8bef-88d01321ea7d/Untitled.png)

1. 송신부→수신부
연결 종료를 위해 `FIN` 전송
2. 수신부→송신부
FIN에 응답으로 `ACK` 전송하고
연결을 종료하기 위한 작업 수행
3. 수신부→송신부
연결을 종료할 준비가 끝나면 `FIN` 전송
4. 송신부→수신부
FIN에 응답으로 `ACK` 전송
일정시간이 지나야 **CLOSED
(**(1) 패킷이 FIN 메시지 수신보다 지연되어 패킷 유실되는 경우,
(2) ACK 메시지가 제대로 전달되지 않아 연결 해제가 이뤄지지 않는 경우 대비)

### TCP Keep Alive 패킷

**세션 연결을 유지하기 위해** 일정 시간이 경과한 후 TCP Keep Alive 패킷을 보냄으로써 **연결 유지 상태 확인**

- 연결 유지를 원하는 쪽에서 전송

응답을   

- 받으면    → 시간을 처음부터 다시 측정
- 못받으면 → 연결 종료

효과

- 동일한 수신부로부터 재요청이 오는 경우 불필요한 3-way 핸드셰이킹 줄임
- FIN 메시지를 받지 못한 경우에 발생할 수 있는 불필요한 연결 (== 좀비 커넥션) 방지

## TCP 제어 방법

TCP의 데이터 신뢰성을 보장하기 위한 제어 방법

- 발생 가능 문제: packet 손실 / packet 순서 바뀜 / 네트워크 혼잡 /  수신부 overload

### 흐름 제어 (flow control)

데이터 송신부와 수신부에서 **데이터 처리 속도의 차이 때문**에 생기는 데이터 손실을 방지하는 방법

1. **정지-대기 (stop-wait)**

데이터를 보낸 후 ACK 메시지를 받을 때까지 다음 데이터를 보내지 않고 **기다리는 방식**

- 일정 시간 동안 ACK 메시지를 받지 못하면 패킷을 재전송
- 시간적 비효율 有

1. **슬라이딩 윈도우 (sliding window)**

데이터의 수신 여부(ACK)를 확인하지 않고, 
수신부에서 설정한 윈도우 크기만큼 데이터를 연속적으로 보낼 수 있도록 하여 **데이터 흐름을 동적으로 제어**하는 방식

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/d4809f18-a915-4e30-8b11-8f015eacff00/aadb5214-9801-4bf1-a891-d3e11c782036/Untitled.png)

- 윈도우 크기: 응답받지 않고도 보낼 수 있는 데이터의 최대 개수, 3-way 핸드셰이킹 과정에서 결정됨
- 정지—대기 방식의 단점을 보완함

### 혼잡 제어 (congestion control)

송신부의 **데이터 전달 속도와 네트워크 속도 차이**로 데이터 손실이 발생하는 것을 방지하기 위한 방법

- 혼잡: 네트워크에 패킷 수가 과도하게 증가하는 현상
- 혼잡 발생으로 일정 시간동안 응답을 받지 못함 → 송신부는 메시지 전송 실패로 판단, 패킷 재전송 → 악순환

1. **AIMD (Additive Increase Multiplicative Decrease)**
    
    데이터를 **전달**할 때 **합 증가 방식**으로 윈도우의 크기를 더해감 *(+1, +1, …)*
    
    데이터 **손실이 발생**하면 (실패or시간 초과) **곱 감소 방식**으로 윈도우의 크기를 배수 단위로 줄임 *($1\over2$, $1\over2$, …)*
    
    - 시간이 지나면 여러 송신부 간에 네트워크 대역폭을 공평하게 사용
    - 네트워크 대역폭을 넓게 사용하기까지 시간이 오래 걸림
    - 네트워크가 혼잡해지는 상황을 미리 감지 못함
    
2. **느린 시작 (slow start)**
    
    윈도우 크기 1로 시작, ACK 수신할 때마다 +1
    
    - 송신하는 패킷 수가 지수 함수 형태로 증가
    
    혼잡이 발생하면 윈도우 크기를 다시 1로 줄임
    
    - AIMD가 초기 전송 가능 패킷 수가 적다는 단점 보완
    
3. **혼잡 회피 (congestion avoidance)**
    
    윈도우 크기에 대한 임계점을 정하는 방식
    
    - 윈도우 크기가 지수 함수 형태로 증가하다가, 임계점에 도달하면 선형적으로 증가
    - ACK 메시지를 받지 못해 타임아웃 발생한 시점에서
        
        윈도우 크기의 절반을 임계점으로 설정, 윈도우 크기를 초기값으로 변경
        
    
4. **빠른 회복 (fast recovery)**
    
    혼잡이 발생하면 혼잡 윈도우 크기를 절반으로 줄인 후 선형적으로 증가하는 방식
    
    - 즉, 혼잡 상황이 발생하면 AIMD 방식으로 동작
    
5. **빠른 재전송 (fast retransmit)**
    
    Duplicate ACK가 3번 발생하면 윈도우 사이즈를 절반으로 줄이고, ACK를 받으면 다시 사이즈를 키우는 방식
    
    - Duplicate ACK 3번 → 혼잡으로 판단
    

### 오류 제어 (error control)

통신 중 데이터에 **오류 또는 유실이 발생할 때 데이터의 신뢰성을 보장하기 위해** 오류를 제어하는 방식

데이터에 오류 또는 유실 발생을 인지하는 경우

- 수신부에서 NAK (Negative Acknowledge) 메시지를 보낸 경우
- 3 Duplicate ACK가 발생한 경우
- ACK 메시지를 받지 못해 타임아웃이 발생한 경우

1. **정지-대기**
    
    ACK 메시지를 받지 못해 타임아웃이 발생하면 해당 패킷을 다시 보내는 방식
    
    데이터를 1개만 보내고 메시지를 기다려야 하므로 ARQ 방식 사용
    
    - ARQ (Qutomatic Repeat Request): 재전송 요청
    
2. **Go-Back-N ARQ**
    
    연속적으로 데이터를 보냈을 때 누락된 데이터가 있으면 송신부에서 해당 데이터부터 재전송하는 방식
    
    - e.g. 패킷 3, 4, 5 보냄 → ACK 4 메시지 수신 → 패킷 4, 5 재전송
    
3. **Selective-Repeat ARQ**
    
    연속적으로 데이터를 보냈을 때 누락된 데이터가 있으면 수신부에서 해당 데이터만 재전송을 요청하는 방식
    
    - e.g. 패킷 3, 4, 5 보냄 → ACK 4 메시지 수신 → 패킷 4 재전송
    - 특정 패킷만 재전송은 효율적으로 보이나, 받은 패킷을 재정렬하는 로직이 추가로 필요

## UDP (User Datagram Protocol)

- 비연결형 서비스 (송신부—수신부 연결성 지원X)
- 데이터의 신뢰성이 낮음
- 데이터 전송 속도 빠름
- 패킷 교환 방식: 데이터그램 패킷 교환 방식 (데이터그램 형태의 통신을 지원)
- 송신부에서 전달한 패킷 순서 — 수신부에서 받은 패킷 순서 다를 수 있음
- 패킷의 수신 여부를 확인하지 않음
- 송신부—수신부 1:1 통신, 1:N, N:N 통신 모두 가능

## UDP의 오류 검출

최소한의 신뢰성을 보장하기 위해 **체크섬(checksum) 방식으로 오류를 검출**

`체크섬`: 데이터의 무결성을 보장하는 간단한 방법

체크섬을 만들기 위한 데이터를 모두 더함 

→ 오버플로되는 캐리가 발생하면 해당 캐를 떼서 데이터에 다시 더한 후 1의 보수를 취해 체크섬을 만듦

- UDP 헤더, IP 헤더의 일부 정보와 데이터로 체크섬 값 생성

→ 체크섬 값을 UDP 헤더의 체크섬 영역에 넣어 수신부에 전송

→ 체크섬을 포함한 모든 값을 더해 비트가 모두 1이 나오는지 확인 (== 송신부와 동일한 체크섬 값이 나오는지 확인하는 것임)

오류 100% 검출 불가능

- 데이터의 순서가 바뀌거나 오류가 발생할 가능성이 있음

선택 사항이므로, 체크섬 값을 0으로 보내면 체크섬을 계산하지 않음