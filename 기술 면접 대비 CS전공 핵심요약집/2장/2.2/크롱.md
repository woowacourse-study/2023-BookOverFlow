## 2.2 TCP와 UDP

TCP와 UDP는 전송 계층에서 사용하는 프로토콜이다. 

보통 TPC/IP라고 하는데 IP는 네트워크 계층의 프로토콜이다.

<br><br>

### 2.2.1 TCP

연결형 서비스를 지원하고 데이터의 신뢰성을 보장한다.

특징은 다음과 같다.

- 송신자와 수신자의 연결을 확인하는 연결형 서비스다.
- 패킷 교환 방식은 패킷이 전달되는 회선이 정해져있는 가상 회선 방식(논리적 연결)이다.
- 패킷의 전송 순서가 보장된다.
- 송신자와 수신자는 1:1 통신을 한다.
- 데이터 손실이 없음을 보장하므로 신뢰성이 높다.
- 데이터의 송수신 속도가 느리다.

> 연결형 서비스?
> 
> 
> ---
> 
- 송신자, 수신자 사이에 논리적인 연결을 확립하고 데이터를 전송한다.
- 패킷의 순서가 맞지 않을 위험이 적고 오류 발생 시 재전송한다.

> 가상 회선 방식
> 
> 
> ---
> 
- 패킷 교환 방식 중 하나다.
- 모든 패킷을 같은 경로로 전송한다.

> 데이터그램 방식
> 
> 
> ---
> 
- 패킷마다 최적의 경로로 전송된다.
- 보낸 패킷의 순서와 수신자에게 도착하는 패킷의 순서가 다를 수 있다.

<br><br>

### 2.2.2 TCP 핸드셰이킹

연결형 서비스를 지원하기 위해 송신자와 수신자를 연결하는 과정을 거치는데 연결을 시작할 때는 3-way 핸드셰이킹, 연결을 종료할 때는 4-way 핸드셰이킹을 한다.

핸드셰이킹 과정에서는 송신자와 수신자 사이에서 연결을 제어 및 관리하도록 플래그를 주고 받는다. 주로 사용하는 플래그 값은 다음과 같다.

| SYN | Synchronization의 약자로, 연결을 생성할 때 사용 |
| --- | --- |
| FIN | Finish의 약자로, 연결을 끊을 때 사용 |
| ACK | Acknowledgement의 약자로 데이터를 전송하면 수신자가 받았음을 알려줄 때 사용 |
| RST | Reset의 약자로 연결을 재설정할 때 사용 |
| PSH | Push의 약자로 빠른 응답이 필요한 데이터를 응용 계층으로 즉시 전송할 때 사용 |
| URG | Urgent의 약자로 다른 데이터보다 우선순위가 높은 데이터를 전송할 때 사용 |

<br><br>

### 3-way 핸드셰이킹

데이터를 주고받기 전에 상대방 컴퓨터와 세션을 수립하는 과정이다. 

데이터의 정확한 전달을 위해 필요한 절차다.

데이터 송신자와 수신자 모두 데이터를 주고받을 준비가 되었음을 보장한다.
<center>
<img src="https://github.com/krrong/baekjoon-algorithm/assets/84285337/fda27a75-d615-40cd-8783-5b585db3d0f0" width=300>
</center>

1. 송신자가 수신자에게 SYN 메시지를 보낼 때 임의의 숫자 N을 함께 보낸다. 송신자는 수신자에게 응답이 오기 전까지 SYN_SENT 상태가 된다.
2. 수신자는 SYN 메시지를 받으면 ACK 메시지를 송신자에게 전송한다. ACK 메시지에는 송신자에게 받은 N에 1을 더한 N + 1 값을 함께 보낸다. 수신자도 송신자와의 연결을 확인하기 위해 SYN 메시지와 임의의 숫자 M을 함께 보낸다. 그리고 수신자는 SYN_RECEIVED 상태가 된다.
3. 송신자가 ACK + SYN 메시지를 받으면 연결이 성립되었다는 의미인 established 상태가 된다. 메시지에 대한 응답으로 ACK 메시지와 수신자로부터 받은 M에 1을 더한 M + 1 값을 함께 보낸다. 송신자로부터 ACK 메시지를 받으면 수신자는 established 상태가 된다.

<br><br>

### 4-way 핸드셰이킹

TCP 연결을 해제할 때 이뤄지는 과정이다.

<center>
<img src="https://github.com/krrong/baekjoon-algorithm/assets/84285337/a38639a9-23b8-4cb3-aa25-8d6debc6f7e6" width=300>
</center>

1. 송신자가 수신자와 연결을 종료하기 위해 FIN 메시지를 보낸다. 송신자는 FIN_WAIT1 상태가 된다.
2. 수신자는 FIN 메시지를 받으면 ACK 메시지를 보내며 CLOSE_WAIT 상태가 된다. 메시지를 보낸 후 수신자는 연결을 종료하기 위한 작업을 한다. 송신자는 수신자가 보낸 ACK 메시지를 받고 FIN_WAIT2 상태가 된다.
3. 수신자가 연결을 종료할 준비가 되면 송신자에게 FIN 메시지를 보내고, LAST_WAIT 상태가 된다.
4. 송신자는 FIN 메시지에 응답하기 위해 ACK 메시지를 보내고, TIME_WAIT 상태가 된다. 일정 시간이 지나면 CLOSED 상태가 된다. TIME_WAIT을 유지하는 이유는 FIN 메시지 전에 보낸 패킷이 FIN 메시지 수신보다 지연되어 발생하는 패킷 유실에 대비하기 위함이다.

<br><br>

### 2.2.3 TCP 제어 방법

TCP 데이터 신뢰성을 보장하기 위한 방법으로, 흐름제어, 혼잡제어, 오류제어가 있다.

<br><br>

### 흐름제어

데이터 송신자와 수신자에서 데이터 처리 속도의 차이 떄문에 생기는 데이터 손실을 방지하는 방법이다.

지나친 패킷을 수신하지 않도록 하는 방법이고, 수신자가 송신자에게 현재 상태를 피드백한다.

흐름제어는 대표적으로 다음과 같은 방식이 있다.

<br><br>

### 정지-대기(stop-wait)

송신자가 데이터를 보낸 후 수신자로부터 ACK 메시지를 받을 때까지 다음 데이터를 보내지 않고 기다리는 방식이다. 송신자가 패킷을 보내고 일정 시간동안 수신자로부터 ACK 메시지를 받지 못하면 패킷을 재전송한다. 

간단한 방법이지만, 이전 메시지에 대한 응답을 받아야만 다음 메시지를 보낼 수 있어 시간 면에서 비효율적이다.

<center>
<img src="https://github.com/krrong/baekjoon-algorithm/assets/84285337/585831e7-f5d1-4544-bafc-87804382c86f" width=400>
</center>

<br><br>

### 슬라이딩 윈도우(Sliding window)

송신자가 데이터의 수신 여부(ACK)를 확인하지 않고 수신부에서 설정한 윈도우 크기만큼 데이터를 연속적으로 보낼 수 있게 하는 방식이다. 윈도우 크기는 응답받지 않고도 보낼 수 있는 데이터의 최대 개수를 의미하며, 3-way 핸드셰이킹 과정에서 정해진다. (송신자가 수신자의 윈도우 크기에 맞춘다.)

수신자의 수신 여부와 상관없이 일정 크기의 데이터를 연속적으로 보내서 ACK 메시지를 받아야만 다음 메시지를 보낼 수 있는 정지-대기 방식의 단점을 보완한다.

<center>
<img src="https://github.com/krrong/baekjoon-algorithm/assets/84285337/eea63089-d23d-434a-a89e-8ffe2065715a" width=500>
</center>

1. 윈도우 크기가 4일 때 송신자가 데이터 1, 2를 보낸다. 3, 4도 보낼 수 있지만 아직 보내지 않은 상태다.
2. 수신자는 데이티ㅓ 1, 2를 받았다는 ACK 메시지를 보낸다.
3. 송신자는 수신자가 데이터 1, 2를 받은 것을 확인하고 윈도우를 2칸 이동한다. 따라서 3부터 6까지 데이터를 보낼 수 있는 상태가 된다. 송신자는 데이터 3, 4, 5를 보낸다.
4. 수신자는 데이터 3, 4를 받았다는 ACK 메시지를 보낸다. 송신자는 수신자에서 데이터 3, 4를 받았다는 ACK 메시지를 받아 윈도우를 2칸만 이동한다. 이제 데이터 7, 8도 보낼 수 있는 상태가 된다.

<br><br>

### 혼잡제어

송신자의 데이터 전달 속도와 네트워크 속도 차이로 데이터 손실이 발생하는 것을 방지하기 위한 방법이다.

네트워크 혼잡을 피하기 위한 방법이고, 혼잡은 네트워크에 패킷 수가 과도하게 증가하는 증상을 의미한다.

송신자는 메시지 전송에 실패했다고 판단해 수신부에 패킷을 재전송하는데, 이는 혼잡을 가중하기 때문에 악순환을 야기한다.

<br><br>

### AIMD(Additive Increase Multiplicative Decrease)
💡 혼잡 윈도우 : 그냥 전송 가능한 버퍼크기라고 보면 된다. 송신자는 자신의 최대 혼잡 윈도우 크기만큼 데이터를 전송할 수 있다.

데이터를 전달할 때 합 증가 방식으로 혼잡 윈도우의 크기를 더해가면서 키운다.

데이터 손실이 발생하면 혼잡 윈도우의 크기를 곱 감소 방식을 정용해 1/2배와 같이 배수 단위로 줄인다.

<center>
<img src="https://github.com/krrong/baekjoon-algorithm/assets/84285337/874fd2c3-8a15-4375-a30e-fafceae93c2b" width=300>
</center>

AIMD 방식은 시간이 지나면 여러 송신자 간에 네트워크 대역폭을 공평하게 사용할 수 있게 된다.

하지만 네트워크 대역폭을 넓게 사용하기까지 시잔이 오래걸린다는 단점이 있다.

<br><br>

### 느린 시작(slow start)

윈도우 크기가 1인 상태에서 시작해 ACK 메시지를 수신할 때마다 윈도우 크기를 1씩 늘려간다.

혼잡이 발생하면 윈도우 크기를 1로 줄이는 방식이다.

패킷 1개 성공 → 패킷 2개 성공 → 패킷 4개 성공 → 패킷 16개 성공 …

패킷 수가 지수 함수 형태로 증가한다.

<center>
<img src="https://github.com/krrong/baekjoon-algorithm/assets/84285337/bce8ba6b-f8ad-43b6-a04e-746d295cb6a6" width=300>
</center>

느린 시작 방법은 AIMD 방식에서 초기에 전송 가능한 패킷 수가 적다는 단점을 보완한다.

<br><br>

### 혼잡 회피

윈도우 크기가 지수 함수 형태로 증가하다가 혼잡이 발생하는 것을 방지하기 위해 윈도우 크기에 대한 임계점을 정하는 방식이다. 윈도우 크기가 임계점에 도달하면 윈도우 크기를 선형적으로 증가하게 한다.

ACK 메시지를 받지 못해 타임아웃이 발생하면 윈도우 크기의 절반을 임계점으로 설정하고 윈도우 크기를 초깃값으로 변경한다.

<br><br>

### 빠른 회복

혼잡이 발생하면 혼잡 윈도우 크기를 절반으로 줄인 후 선형적으로 증가하는 방식이다.

혼잡이 처음 발생하면 AIMD 방식으로 동작한다.

<br><br>

### 빠른 재전송

Duplicate ACK는 받아야 할 패킷을 못 받아서 다시 달라는 요청을 말한다.

Duplicate ACK가 3번 발생하면 해당 시점의 윈도우 크기를 1/2로 줄인다. 그 뒤로 ACK 메시지를 받으면 다시 윈도우 크기를 키우는 방식이다.

Duplicate ACK는 패킷이 순서대로 도착하지 않아서 받아야 할 차례의 패킷을 ACK 메시지와 함께 요청하는 것을 뜻한다.

<center>
<img src="https://github.com/krrong/baekjoon-algorithm/assets/84285337/eda69b01-f8a4-40cb-ab56-f5707df222a2" width=400>
</center>

송신자가 0-5 패킷을 보냈지만, 수신자는 패킷 2를 받지 못했다. 수신자는 패킷 3, 4, 5에 대해 패킷 2를 보내라고 응답한다. 해당 응답이 3번 반복되면 송신측에서는 패킷 2를 재전송한다. 이 때 윈도우 크기는 1/2로 줄어든다.

<br><br>

> TCP Tahoe
> 

느린 시작을 사용해 혼잡 윈도우 크기를 지수적으로 키운다. 

혼잡이 발생했다고 판단되면 혼잡이 발생한 윈도우 크기의 절반을 ssthresh로 설정하고 혼잡 윈도우의 크기를 초기화 한다.

<center>
<img src="https://github.com/krrong/baekjoon-algorithm/assets/84285337/0137fc3c-5e71-4c38-87c8-609d9fb0b738" width=300>
</center>

ssthresh 초기값 : 4

혼잡 윈도우 크기를 지수적으로 키우다가 ssthresh인 4에 도달하면 AIMD를 사용해 혼잡 윈도우 크기를 선형적으로 키운다.

혼잡 윈도우 크기가 6이 되었을 때 혼잡으로 3 Duplicate ACK가 발생한다. 그러면 혼잡 윈도우 크기를 1로 초기화하고 ssthresh 값을 혼잡이 발생한 크기인 6의 절반은 3으로 줄인다.

이후 다시 윈도우 크기가 5일 때 타임아웃이 발생하면 윈도우 크기를 1로 초기화하고 ssthresh 값을 2로 변경한다.

<br><br>

> TCP Reno
> 

3 Duplicate ACK와 타임아웃을 구분해 대응한다. 3 Duplicate ACK가 발생하면 혼잡 윈도우 크기를 절반으로 줄이고, 줄인 혼잡 윈도우 크기를 ssthresh 값으로 설정한다.

타임아웃이 발생하면 혼잡 윈도우 크기를 1로 초기화 한다. 이 때 ssthresh 값은 변경하지 않는다.

<center>
<img src="https://github.com/krrong/baekjoon-algorithm/assets/84285337/91ad3b9e-c132-4bca-86ac-e7b5d615365f" width=300>
</center>

혼잡 윈도우 크기를 지수적으로 키우다가 ssthresh 값인 4에 도달했을 때, AIMD를 사용해 혼잡 윈도우 크기를 선형적으로 키운다. 

혼잡 윈도우 크기가 6에 도달했을3 Duplicate ACK가 발생하면 혼잡 윈도우 크기를 절반으로 줄이고 ssthresh 값도 혼잡 윈도우 크기와 동일하게 설정한다.

혼잡 윈도우 크기가 5가 되었을 때 타임아웃이 발생하면 ssthresh 값은 유지하지만, 혼잡 윈도우 크기는 1로 줄인다.

이후 혼잡 윈도우 크기는 지수적으로 증가하다가 ssthresh 값인 3에 도달하면 선형적으로 증가한다. 

<br><br>

### 오류 제어

데이터를 오류 또는 유실이 발생할 때 데이터의 신뢰성을 보장하기 위해 오류를 제어하는 방식이다.

전송 도중에 발생한 부호 오류를 검출한다.

오류 또는 유실 발생을 인지하는 경우는 다음과 같다.

- 수신자가 잘못된 데이터를 받았다는 응답인 NAK메시지를 보낸 경우
- 3 Duplicate ACK가 발생할 때
- 수신자로부터 ACK 메시지를 받지 못해 타임아웃이 발생할 때

<br><br>

### 정지-대기

송신한 패킷에 대한 ACK 메시지를 일정 시간 동안 받지 못해 타임아웃이 발생하면 해당 패킷을 다시 보내는 방식이다.

<center>
<img src="https://github.com/krrong/baekjoon-algorithm/assets/84285337/c8771528-9145-4caa-b4f4-88f4aae52755" width=300>
</center>

수신자가 1개의 데이터만 보내고 메시지를 기다려야 하기 때문에 ARQ 방식이 사용된다. 

ARQ (Automatic Repeat Request)는 재전송 요청을 의미한다.

<br><br>

### Go-Back-N ARQ

송신자가 연속적으로 데이터를 보낼 때 누락된 데이터가 있으면 송신자가 해당 데이터부터 재전송하는 방식이다.

패킷 0~2를 보냈을 때 수신자가 ACK 3 메시지를 보내면 송신자는 다음에 패킷 3부터 보낸다. 그리고 패킷 3~5를 보냈을 때 ACK 4 메시지를 받으면 4와 5를 재전송한다.

<center>
<img src="https://github.com/krrong/baekjoon-algorithm/assets/84285337/a22e1481-2d76-4033-a212-c727423a8174" width=300>
</center>

<br><br>

### Selective-Repeat ARQ

송신자가 연속적으로 데이터를 보냈을 때 누락된 데이터가 있으면 수신자에서 해당 데이터만 재전송을 요청하는 방식이다.

수신자에서 패킷 0~2까지 잘 수신하면 패킷 3을 보내라는 의미인 ACK 3 메시지를 보낸다. 그리고 송신자가 패킷 3~5까지 보냈을 때 패킷 4를 받지 못하면 패킷 4를 보내라는 의미로 ACK 4 메시지를 보낸다. 이 요청을 받은 송신자는 패킷 4를 다시 보내고, 이를 받은 수신자는 패킷 6을 요청한다.

<center>
<img src="https://github.com/krrong/baekjoon-algorithm/assets/84285337/3adb1299-09b8-4ec1-ac7c-ad8973e8f4e0" width=300>
</center>

특정 패킷을 재전송하는 것이 효율적으로 보이지만, 받은 패킷을 재정렬하는 로직이 추가로 필요하다.

<br><br>

### 2.2.4 UDP

TCP와 마찬가지로 전송 계층에 해당하는 네트워크 프로토콜이다.

송신자와 수신자의 연결을 지원하지 않고 데이터그램 형태의 통신을 지원한다. 그래서 3-way 핸드셰이킹 같은 과정 없이 패킷을 바로 송수신한다. 이 방식은 신뢰성이 낮지만 속도가 빠르다는 장점이 있다.

특징은 다음과 같다.

- 송신자와 수신자의 연결이 보장되지 않는 비연결형 서비스다.
- 패킷이 서로 다른 회선으로 교환될 수 있는 데이터그램 패킷 교환 방식이다.
- 송신자가 전달한 패킷 순서와 수신자가 받은 패킷 순서가 다를 수 있다.
- 패킷의 수신 여부를 확인하지 않는다.
- 1:1 통신, 1:N 통신, N:N 통신 모두 가능하다.
- 데이터의 신뢰성이 낮다.
- 데이터의 전송 속도가 빠르다.

| 구분 | TCP | UDP |
| --- | --- | --- |
| 연결 방식 | 연결형 서비스 | 비연결형 서비스 |
| 패킷 교환 방식 | 가상회선 방식 | 데이터그램 방식 |
| 전송 순서 | 순서 보장 | 순서를 보장하지 않음 |
| 수신 여부 | 확인 | 확인하지 않음 |
| 통신 방식 | 1:1 통신 | 1:1, 1:N, N:N 통신 |
| 신뢰성 | 높음 | 낮음 |
| 속도 | 느림 | 빠름 |

<br><br>

### UDP의 오류 검출

최소한의 신뢰성을 보장하기 위해 체크섬 방식으로 오류를 검출한다.

체크섬은 데이터의 무결성을 보장하는 간단한 방법으로, 처크섬을 만들기 위한 데이터를 모두 더한다. 만약 오버플로우되는 캐리가 발생하면 해당 캐리를 떼서 데이터에 다시 더한 후 1의 보수를 취해 체크섬을 만든다.

<center>
<img src="https://github.com/krrong/baekjoon-algorithm/assets/84285337/c01840c7-7952-4bda-af7f-15d1d5ce93aa" width=300>
</center>

UDP 송신자는 UDP의 헤더, IP 헤더의 일부 정보(발신 IP 주소, 수신 IP 주소, 프로토콜 ID 등)와 데이터로 체크섬 값을 생성한다. 생성한 체크섬 값을 UDP 헤더의 체크섬 영역에 넣어 수신자에게 보낸다.

수신자는 체크섬을 포함한 모든 값을 더해 비트가 모두 1이 나오는지 확인하고 모든 비트가 1이 아니라면 송신자가 보낸 체크섬과 동일한 값이 나온다는 것을 의미한다.

하지만 체크섬을 이용해도 오류를 100% 검출할 수 있는 것은 아니다. 데이터를 각각 비교하는 것이 아니라 값을 더해 확인하는 방식이라 데이터의 순서가 바뀌거나 오류가 발생해도 체크섬이 같은 경우가 있기 때문이다.

체크섬은 선택 사항이기 때문에 송신자가 체크섬 값을 0으로 보내면 수신자는 체크섬을 계산하지 않는다.