# 2.2(TCP와 UDP)

- TCP와 UDP는 전송 계층에서 사용하는 대표적인 프로토콜이다.
- 서비스를 개발할 때 어느 프로토콜을 사용해야 용이할지 각각의 특징을 잘 이해해야한다.

## 2.2.1 TCP(Transmission Control Protocol)란?(⭐⭐⭐)

- TCP는 전송 계층에 해당하는 네트워크 프로토콜로, **연결형 서비스를 지원하고 데이터의 신뢰성**을 보장한다.
    - 송신부와 수신부의 연결을 확인하는 연결형 서비스다.
    - 패킷 교환 방식은 패킷이 전달되는 회선이 정해져 있는 가상 회선 방식이다.
    - 패킷의 전송 순서가 보장된다.
    - 패킷의 수신 여부를 확인한다.
    - 송신부와 수신부는 1:1 통신을 한다.
    - 데이터 손실이 없음을 보장하므로 신뢰성이 높다.
    - 데이터의 송수신 속도가 느리다.

### 패킷교환방식

- 패킷 교환 방식은 가장 많이 사용하는 데이터 통신 방식으로, 가상 회선을 이용한 방식과 데이터그램을 이용한 방식이 있다.
    - 가상 회선 방식: 데이터를 주고받기 전에 패킷을 전송할 경로인 가상 회선을 설정해서 모든 패킷을 같은 경로로 전송한다.
    - 데이터그램 방식: 패킷마다 최적의 경로로 전송되는 방식으로, 송신부에서 보낸 패킷의 순서와 수신부에 도착하는 패킷의 순서가 다를 수 있다.

![Untitled](2%202(TCP%E1%84%8B%E1%85%AA%20UDP)%2077fb272a31704bdc97282877a765888b/Untitled.png)

## 2.2.2 TCP 핸드셰이킹(⭐⭐⭐)

- TCP는 연결형 서비스를 지원하기 위해 송신부와 수신부를 연결하는 과정을 거친다.
- **연결을 시작할 때는 3-way 핸드셰이킹, 종료할 때는 4-way 핸드셰이킹**을 한다.
- 핸드셰이킹 과정에서는 송신부와 수신부 간 연결을 제어 및 관리하도록 플래그 값을 주고 받는다.
    - **SYN**: Synchronization(동기화)의 약자로, 연결을 생성할 때 사용
    - **FIN**: Finish(종료)의 약자로, 연결을 끊을 때 사용
    - **ACK**: Acknowledgment(승인)의 약자로, 데이터를 전송하면 수신자가 받았음을 알려 줄 때 사용
    - RST: Reset(초기화)의 약자로, 연결을 재설정할 때 사용
    - PSH: Push(밀다)의 약자로, 빠른 응답이 필요한 데이터를 응용 계층으로 즉시 전송할 때 사용
    - URG: Urgent(긴급)의 약자로, 다른 데이터보다 우선순위가 높은 데이터를 전송할 때 사용

### 3-way 핸드셰이킹

- 데이터를 주고받기 전에 **상대방 컴퓨터와 세션을 수립하는 과정**으로, 데이터의 정확한 전달을 위해 필요한 절차이다.
    - 이 과정에서 데이터의 송신자와 수신자 모두 데이터를 주고받을 준비가 되었음을 보장한다.
    
    ![Untitled](2%202(TCP%E1%84%8B%E1%85%AA%20UDP)%2077fb272a31704bdc97282877a765888b/Untitled%201.png)
    
    1. 송신부가 수신부와 연결하기 위해 SYN 메시지를 N과 함께 보낸다.
        1. 송신부는 수신부로부터 응답을 받기 전까지 SYN_SENT 상태가 된다.
    2. 수신부는 ACK 메시지를 N+1 과 함께 보낸다.
        1. 수신부 또한 송신부와의 연결을 확인하기 위해 SYN 메시지를 M과 함께 보내며 SYN_RECEIVED 상태가 된다.
    3. 송신부가 ACK + SYN 메시지를 받으면, 연결이 성립되었다는 의미인 ESTABLISHED 상태가 된다.
        1. M+1 을 다시 수신부에 보내며, 이 때 ACK 메시지엔 송신부가 전송하려는 데이터가 포함될 수 있다.
        2. 수신부가 메시지를 받으면 ESTABLISHED가 된다.

### 4-way 핸드셰이킹

- TCP **연결을 해제할 때 이뤄지는 과정**이다.
    
    ![Untitled](2%202(TCP%E1%84%8B%E1%85%AA%20UDP)%2077fb272a31704bdc97282877a765888b/Untitled%202.png)
    
    1. 송신부가 수신부와의 연결을 종료하기 위해 FIN 메시지를 보낸다.
        1. 이때 송신부는 FIN_WAIT1 상태가 된다.
    2. 수신부가 FIN 메시지를 받으면 응답으로 ACK를 보낸다.
        1. 수신부는 CLOSE_WAIT 상태가 된다.
        2. 수신부는 메시지를 보낸 후 앱을 종료하는 등 연결을 종료하기 위한 작업을 한다.
    3. 송신부는 응답을 받고 FIN_WAIT2 상태가 된다.
    4. 수신부에서 연결을 종료할 준비가 끝나면 송신부에 FIN 메시지를 보내고 LAST_WAIT 상태가 된다.
    5. 송신부는 FIN 메시지에 응답하기 위해 ACK 메시지를 보내고 TIME_WAIT 상태가 된다.
        1. 일정 시간이 지나면 CLOSED 상태가 된다.
        2. 일정시간 TIME_WAIT을 하는 이유는 FIN 메시지 전에 보낸 패킷이 FIN 메시지 수신보다 지연되어 발생하는 **패킷 유실**에 대비하기 위해서다.
        3. 또한, 수신부에 ACK 메시지가 제대로 전달되지 않아 연결 해제가 이뤄지지 않는 경우도 대비한다.
        4. 수신부는 송신부로부터 ACK 메시지를 받고 CLOSED 상태가 된다.
- 세션이 연결되면 이를 유지하기 위해 일정 시간이 경과한 후 TCP Keep Alive 패킷을 던져 연결 유지 상태를 확인할 수 있다.
    - TCP Keep Alive 패킷은 연결을 유지하길 원하는 쪽에서 보낸다.
    - 패킷에 대한 응답을 받으면 다시 시간을 측정하고, 응답을 받지 못하면 연결을 종료한다.
    - 이는 동일한 송신부로부터 재요청이 오는 경우의 불필요한 3-way 핸드셰이킹을 줄일 수 있다.
    - 또한, FIN 메시지를 받지 못한 경우에 발생할 수 있는 불필요한 연결, **좀비 커넥션을 방지**할 수 있다.

## 2.2.3 TCP 제어 방법(⭐⭐⭐)

### 흐름제어(flow control)

- **데이터 송신부와 수신부에서 데이터 처리 속도의 차이 때문에 생기는 데이터 손실을 방지하는 방법**이다.

1. 정지-대기(stop-wait)
- 송신부에서 데이터를 보낸 후 수신부로부터 ACK 메시지를 받을 때까지 다음 데이터를 보내지 않고 기다린다.
- 일정시간 지연되면 패킷을 재전송한다.
- 시간 면에서 비효율적이다.

![Untitled](2%202(TCP%E1%84%8B%E1%85%AA%20UDP)%2077fb272a31704bdc97282877a765888b/Untitled%203.png)

1. 슬라이딩 윈도우(sliding window)
- 송신부에서 데이터의 수신 여부(ACK)를 확인하지 않고 수신부에서 설정한 윈도우 크기만큼 데이터를 연속적으로 보낼 수 있게 해서 데이터 흐름을 동적으로 제어하는 방식이다.
- 윈도우 크기는 응답받지 않고도 보낼 수 있는 데이터의 최대 개수를 의미하며, 3-way 핸드셰이킹 과정에서 정해진다.
- 내가 이해한 바로는, 이해하기 쉽게 n 사이즈의 버퍼를 두고, 응답 대기에 의존하지 않고 n 사이즈 버퍼만큼 계속 통신하는 것 같다.
- 수신부가 수신 후 응답한 ACK 만큼 n 사이즈 버퍼는 윈도우가 응답한 ACK만큼 이동한다.
- 정지-대기 방식의 단점을 보완한다.

![Untitled](2%202(TCP%E1%84%8B%E1%85%AA%20UDP)%2077fb272a31704bdc97282877a765888b/Untitled%204.png)

![Untitled](2%202(TCP%E1%84%8B%E1%85%AA%20UDP)%2077fb272a31704bdc97282877a765888b/Untitled%205.png)

### 혼잡 제어(congestion control)

- **송신부의 데이터 전달 속도와 네트워크 속도 차이로 데이터 손실이 발생하는 것을 방지하기 위한 방법**이다.
    - 혼잡이란 네트워크 패킷 수가 과도하게 증가하는 증상을 의미한다.
- 혼잡이 발생해 네트워크에 패킷이 쌓이며 일정시간 응답을 받지 못하면, 송신부는 메시지 전송에 실패했다고 판단해 수신부에 패킷을 재전송한다.
    - 이는 혼잡을 가중한다.
    - 따라서 TCP는 혼잡 윈도우의 크기를 조절해 혼잡에 대응한다.

1. AIMD(Additive Increase Multiplicative Decrease)
    - 데이터를 전달할 때 합 증가 방식으로 혼잡 윈도우의 크기를 더해가면서 키운다.
    - 데이터 손실이 발생하면 혼잡 윈도우의 크기를 곱 감소 방식을 적용해 1/2배와 같이 배수 단위로 줄인다.
        
        ![Untitled](2%202(TCP%E1%84%8B%E1%85%AA%20UDP)%2077fb272a31704bdc97282877a765888b/Untitled%206.png)
        
    - AIMD 방식은 시간이 지나면 여러 송신부 간에 네트워크 대역폭을 공평하게 사용할 수 있게 된다.
        - 데이터 유실이 발생하면 윈도우 크기 증가폭 대비 윈도우 크기 감소폭이 크기 때문에 네트워크의 대역폭을 넓게 사용하기까지 시간이 오래 걸린다는 단점이 있다.(이해안갔음) → 새로 들어온 호스트와 기존 호스트의 혼잡 윈도우 크기의 평균치가 비슷하다.

1. 느린 시작(slow start)
- 윈도우 크기가 1인 상태에서 시작해 ACK 메시지를 수신할 때마다 윈도우 크기를 1씩 늘려나간다.
- 그러다 혼잡이 발생하면 윈도우 크기를 1로 줄인다.
- AIMD 방식에서 초기에 전송 가능한 패킷 수가 적다는 단점을 보완한다.(제곱증가)
    
    ![Untitled](2%202(TCP%E1%84%8B%E1%85%AA%20UDP)%2077fb272a31704bdc97282877a765888b/Untitled%207.png)
    

1. 혼잡 회피(congestion avoidance)
- 윈도우 크기가 지수 함수 형태로 증가하다가 혼잡이 발생하는 것을 방지하기 위해 윈도우 크기에 대한 임계점(threshold)을 정하는 방식이다.
- 윈도우 크기가 임계점에 도달하면, 이후부턴 선형으로 증가한다.
- ACK 메시지를 받지 못해 타임아웃이 발생하면, 해당 시점에서 윈도우 크기의 절반을 임계점으로 설정하고, 윈도우 크기를 초깃값으로 변경한다.

1. 빠른 회복(fast recovery)
- 혼잡이 발생하면 혼잡 윈도우 크기를 절반으로 줄인 후 선형적으로 증가하는 방식이다.
- 혼잡이 처음 발생하면 AIMD 방식으로 동작한다.

1. 빠른 재전송(fast retransmit)
- Duplicate ACK가 3번 발생하면 해당 시점의 윈도우 크기를 1/2로 줄인다.
- 그 뒤로 ACK 메시지를 받으면 다시 윈도우 크기를 키우는 방식이다.
- Duplicate ACK는 패킷이 순서대로 도착하지 않아서 받아야 할 차례의 패킷을 ACK 메시지와 함께 요청하는 것을 뜻한다.

![Untitled](2%202(TCP%E1%84%8B%E1%85%AA%20UDP)%2077fb272a31704bdc97282877a765888b/Untitled%208.png)

### TCP 혼합 제어 정책

- TCP는 여러 혼잡 제어 방식을 혼합해 사용한다.
- TCP Tahoe, TCP Reno, NEW Reno, Cubic 등 다양한 혼잡 제어 정책이 있는데, TCP Tahoe와 TCP Reno가 대표적이다.
    - 두 방식 모두 느린 시작 방식을 사용하다 임계점을 넘어가며 AIMD 방식으로 전환한다.
    - 이때 임계점은 느린 시작 방식의 임계점을 의미해서 ssthresh(slow start threshold)라고 한다.

1. TCP Tahoe
- 초반에 느린 시작을 통해 지수적으로 윈도우를 키우며, 혼잡 발생시 윈도우 크기의 절반을 ssthresh로 설정하고 혼잡 윈도우의 크기를 초기화한다.

![Untitled](2%202(TCP%E1%84%8B%E1%85%AA%20UDP)%2077fb272a31704bdc97282877a765888b/Untitled%209.png)

- 느린 시작 → 임계점 도달 → AIMD 선형 증가 → 3 Duplicate ACK, 타임아웃 등 발생 → 혼잡윈도우 크기 1로 초기화 및 ssthresh 절반값 지정

1. TCP Reno
- TCP Tahoe와 어느정도 유사하나, 타임아웃과 3 Duplicate ACK를 구분해 대응한다.
    - 3 Duplicate ACK 발생시, 혼잡 윈도우 크기와 ssthresh 값을 절반으로 줄인다(빠른회복).
    - 타임아웃 발생 시, 혼잡 윈도우 크기를 1로 초기화하며, ssthresh 값은 변경하지 않는다.
    
    ![Untitled](2%202(TCP%E1%84%8B%E1%85%AA%20UDP)%2077fb272a31704bdc97282877a765888b/Untitled%2010.png)
    

### 오류 제어

- 통신 중 **데이터에 오류 또는 유실이 발생할 때 데이터의 신뢰성을 보장하기 위해 오류를 제어하는 방식**이다.
    - 잘못된 데이터를 받았다는 응답인 NAK(Negative Acknowledge) 메시지를 보낸 경우
    - 3 Duplicate ACK가 발생할 때
    - 타임아웃이 발생할 때

1. 정지-대기
- 타임아웃 발생 시 해당 패킷을 다시 보낸다.
- 흐름 제어에 나와있던 방식과 동일하다.
- ARQ(Automatic Repeat Request) 방식이 사용되며, 이는 재전송 요청을 의미한다.

![Untitled](2%202(TCP%E1%84%8B%E1%85%AA%20UDP)%2077fb272a31704bdc97282877a765888b/Untitled%2011.png)

1. Go-Back-N ARQ
- 송신부에서 연속적으로 데이터를 보냈을 때, 누락된 데이터가 있으면 송신부에서 해당 데이터부터 재전송하는 방식이다.

![Untitled](2%202(TCP%E1%84%8B%E1%85%AA%20UDP)%2077fb272a31704bdc97282877a765888b/Untitled%2012.png)

3. Selective-Repeat ARQ

- 누락된 데이터만 재전송을 요청하는 방식이다.
- 특정 패킷만 재전송한다는 점은 효율적이지만, 받은 패킷을 재정렬하는 로직이 추가로 필요하다.

![Untitled](2%202(TCP%E1%84%8B%E1%85%AA%20UDP)%2077fb272a31704bdc97282877a765888b/Untitled%2013.png)

## 2.2.4 UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)(⭐⭐⭐)

- TCP와 마찬가지로 전송 계층에 해당하는 네트워크 프로토콜이다.
- **송신부와 수신부 간 연결을 지원하지 않고 데이터그램 형태의 통신을 지원**한다.
    - 3-way 핸드셰이킹 같은 과정 없이 패킷을 바로 송수신한다.
    - 신뢰성이 낮을 수 있지만 속도가 빠르다는 장점이 있다.

### UDP

- 송신부와 수신부의 연결이 보장되지 않는 비연결형 서비스다.
- 패킷이 서로 다른 회선으로 교환될 수 있는 데이터그램 패킷 교환 방식이다.
- 송신부에서 전달한 패킷 순서와 수신부에서 받은 패킷 순서가 다를 수 있다.
- 패킷의 수신 여부를 확인하지 않는다.
- 1:1 통신, 1:N 통신, N:N 통신 모두 가능하다.
- 데이터의 신뢰성이 낮다.
- 데이터의 전송 속도가 빠르다.

| 구분 | TCP | UDP |
| --- | --- | --- |
| 연결 방식 | 연결형 | 비연결형 |
| 패킷 교환 방식 | 가상 회선 방식 | 데이터그램 방식 |
| 전송 순서 | 보장됨 | 보장되지 않음 |
| 수신 여부 | 확인함 | 확인하지 않음 |
| 통신 방식 | 1:1  | 1:1, 1:N, N:N |
| 신뢰성 | 높음 | 낮음 |
| 속도 | 느림 | 빠름 |

## 2.2.5 UDP의 오류 검출(⭐⭐⭐)

- 최소한의 신뢰성을 보장하기 위해 **체크섬(checksum)** 방식으로 오류를 검출할 수 있다.
- 체크섬은 데이터의 무결성을 보장하는 간단한 방법으로, 체크섬을 만들기 위한 데이터를 모두 더한다.
    - 이때 오버플로되는 캐리가 발생하면 해당 캐리를 떼서 데이터에 다시 더한 후 1의 보수를 취해 체크섬을 만든다.
        - 캐리(carry): 2진수의 덧셈 연산 시 자릿수가 넘어가는 것을 의미한다.
        - 1의 보수: 각 자릿수의 값이 모두 1인 수에서 주어진 2진수를 빼면 나오는 수이다.

![Untitled](2%202(TCP%E1%84%8B%E1%85%AA%20UDP)%2077fb272a31704bdc97282877a765888b/Untitled%2014.png)

- UDP 송신부는 UDP의 헤더, IP 헤더의 일부 정보(발신 IP 주소, 수신 IP 주소, 프로토콜 ID 등)와 데이터로 체크섬 값을 생성한다.
- 생성한 체크섬 값을 UDP 헤더의 체크섬 영역에 넣어서 수신부에 보낸다.
    - 수신부는 체크섬을 포함한 모든 값을 더해 비트가 모두 1이 나오는지 확인한다.
- 완벽한 오류검증은 아니며, 순서가 바뀌거나 오류가 발생해도 체크섬이 같은 경우가 있기 때문이다.
- UDP의 체크섬은 선택 사항이므로 송신부에서 체크섬 값을 0으로 보내면 수신부는 체크섬을 계산하지 않는다.