# 2.3 HTTP

## 2.3.1 HTTP(HyperText Transfer Protocol)

인터넷 상에서 데이터를 전송하기 위한 프로토콜, TCP/IP 계층에서 응용 계층에 속함

1. **비연결성(connectionless)**
- **클라이언트에서 요청을 보낸 후 서버로부터 응답을 받으면 연결을 끊는 것**
- 불특정 다수를 대상으로 하는 서비스에 유리
- 서버에서 응답을 받고 나서도 연결을 유지하려면 그만큼의 자원을 사용하게 되지만 연결을 유지않음으로써 자원 아낌
- 서버가 클라이언트를 기억할 수 없다는 단점(연결 유지 하지 않아서)
- 동일한 클라이언트에서 연속적으로 요청이 오면 연결과 연결 해제 과정을 반복하게 되어 자원 낭비
- **HTTP Keep Alive** 사용(일정 시간 동안 연결 유지)
    - 마지막 응답 이후 일정 시간 동안 연결을 유지해 동일한 클라이언트로부터 요청이 오면 연결 생략
    - HTTP 연결 시 일정 시간 동안 요청을 유지할 수 있도록 사용하는 HTTP 헤더의 일종
    - 클라이언트에서 HTTP 요청 보낼 때 헤더에 Keep Alive 추가해서 보내면 서버에서 연결을 유지할 시간을 Keep Alive 헤더에 추가해 응답

1. **무상태(stateless)**
- **서버에서 클라이언트의 상태를 저장하지 않는 것**
- 클라이언트는 요청에 필요한 데이터를 모두 가지고 있어야 함 —> 쿠키
    - 쿠키 - 클라이언트의 로컬 웹 브라우저에 저장하는 데이터 파일, 키와 값 저장 ex) 웹 사이트 로그인, 온라인 쇼핑몰 장바구니
- 서버가 클라이언트로부터 받은 요청 사항을 모두 저장 —> 세션
    - 세션 - 서버에서 클라이언트와의 연결 정보를 저장 및 관리, 서버에 데이터가 저장되므로 보안 면에서는 쿠키보다 좋음, 접속자가 많을 경우 서버 과부하
- 서버 확장성이 높음 → 클라이언트의 요청에 응답하는 서버가 바뀌어도 되기 때문에 서버 확장 가능
    - 특정 서버에 문제가 생겨 응답하지 못하는 문제 보완

![IMG_4036.JPG](https://github.com/team-replace/replace-android/assets/50761690/fd0f121f-a22d-4c06-bba7-3b0d478def9c)

HTTP에서는 **HTTP 메시지**(클라이언트와 서버가 통신하기 위해 정형화된 데이터) 주고 받음

![IMG_4037.JPG](https://github.com/team-replace/replace-android/assets/50761690/0cd9fc70-5b3c-4da1-9224-e9933619c33c)

- 요청 라인(request line): 요청 URI, 요청 방법, HTTP 버전
- 상태 라인(status line): 요청에 대한 HTTP 상태코드와 HTTP 버전 포함
- 헤더(header): 키-값으로 구성된 다수의 헤더 항목 구성
- 빈 줄(blank line): 헤더의 끝을 나타내는 빈 줄, 헤더와 바디 구분
- 바디(body): 요청 방법 메서드가 POST인 경우에만 바디가 있고, 그 외 메서드일 때는 비어있는 상태로 전달

## 2.3.2 HTTPS

**보안 계층인 SSL/TLS를 이용해 HTTP의 보안을 강화한 웹 통신 프로토콜**

HTTP는 데이터 암호화를 거치지 않고 전송해서 보안에 취약 → 이를 보완한 HTTPS 등장

**SSL** -> ****넷스케이프에서 개발한 암호화 프로토콜, 몇 가지 문제점이 있었는데, 이를 보완해 새로운 암호화 프로토콜인 **TLS** 개발

현재 HTTP에서 통용되는 방식은 TLS 지만 SSL이라는 명칭이 사라지지 않아서 SSL or SSL/TLS라고 부름

![http.jpeg](https://github.com/team-replace/replace-android/assets/50761690/1425f80e-1f99-4467-98a7-cc4cbc21fa06)

HTTPS 동작 방식

- 데이터를 송신할 때 응용 계층에서 보안 계층의 SSL/TLS로 데이터를 보내면 데이터를 암호화해 전송 계층 전달
- 데이터를 수신할 때 전송 계층에서 보낸 데이터를 보안 계층의 SSL/TLS에서 받아 복호화한 후 응용계층으로 보냄

SSL/TLS에서 암호화를 위해 2가지 암호화 방식

- **대칭 키 암호화 방식**
    - 데이터의 암호화와 복호화에 모두 같은 키인 대칭 키를 이용하는 방식
    - 수신자가 가진 키를 송신자에게 줌 → 수신자가 같더라도 송신자가 다르면 이용하는 키가 다름 → 송신자는 받은 키로 데이터를 암호환 후 수신자에게 보냄 → 수신자는 동일한 키로 데이터를 복호화
    - 대칭 키가 유출되지 않도록 주의
- **공개 키 암호화 방식 (한 쌍의 키)**
    - 데이터의 암호화와 복호화를 다른 키로 하는 방식
    - 데이터를 암호화할 때는 공개 키를, 데이터를 복호화할 때는 비밀 키를 사용
        - 공개키로 암호화 하면 개인키로 복호화 할 수 있고, 개인키로 암호화 하면 공개키로 복호화 할 수 있습니다.
        - 이렇듯 **한 쌍의 키로 암호화, 복호화를 하는 방식을  RSA 알고리즘**  이라 합니다!
    - 수신자는 공개키를 송신자에게 줌 → 송신자가 달라도 공개 키는 같음 → 송신자는 수신자에게 받은 키로 데이터를 암호화 → 수신자는 비밀 키로 송신자에게 받은 데이터를 복호화
    - 비밀 키가 있어야만 데이터를 복호화할 수 있어서 공개 키 유출 염려하지 않아도 됨

—> 왜 공개키 암호화 방식만 사용하지 않고 대칭 키 암호화 방식도 같이 사용하나요?

**RSA 알고리즘을 이용한 암호화 방식은 복잡한 수학적 원리로 이루어져 있어,**

**CPU 리소스를 크게 소모한다는 단점**이 있기 때문입니다.

이때문에, RSA 비대칭키 방식으로만 통신을 하기에 성능상 어려움이 있습니다.

## 2.3.3 웹 페이지 접속 과정

![IMG_4038.JPG](https://github.com/team-replace/replace-android/assets/50761690/5d75aa35-6ff0-44e4-afa2-a07cd4c6f9c4)

1) 사용자가 URL을 웹 브라우저에 입력

2) 웹 브라우저는 입력한 URL을 가지고 인터넷에서 연결할 서버를 파악하기 위해 입력한 도메인을 사용하여 웹 사이트를 호스팅 하는 서버의 IP주소를 알아냄, DNS를 사용해서 작업 수행

3) 웹 브라우저는 DNS 서버에서 받은 IP를 통해 웹 서버와 TCP/IP 연결을 하고 HTTP 요청 보냄

4) 웹 서버는 받은 HTTP 요청에 응답, 응답은 웹 페이지에 필요한 리소스 포함

5) 웹 브라우저는 받은 응답을 바탕으로 사용자에게 웹 페이지 보여줌
