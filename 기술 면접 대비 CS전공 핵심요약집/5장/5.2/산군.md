# 5.2(최소 신장 트리)

- 신장 트리는 그래프의 모든 정점을 포함하는 트리를 의미한다.
- 그 중에서 최소 신장 트리(MST, Minimum Spanning Tree)는 가중치가 있는 그래프에서 간선의 가중치 총합이 가장 작은 신장 트리를 의미한다.

## 5.2.1 프림 알고리즘(Prim algorithm)(⭐⭐)

- 프림 알고리즘은 그리디 알고리즘으로, 임의의 정점을 시작점으로 트리를 확장하면서 최소 신장 트리를 생성하는 방식이다.
- 현재 트리에 포함된 정점과 연결된 간선 중 가중치가 가장 작은 간선으로 연결된 정점을 선택하는 과정을 반복하며 모든 정점이 포함될 때까지 트리를 확장한다.

![Untitled](5%202(%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5)%203372a3a36a1f47b88091aa3cfb62e8b8/Untitled.png)

- 임의의 정점으로부터 탐색 가능한 정점 중 가중치가 가장 작은 간선만을 선택해 트리에 추가한다.

## 5.2.2 크루스칼 알고리즘(Kruskal algorithm)(⭐⭐)

- 크루스칼 알고리즘은 그리디 알고리즘이며, 간선을 오름차순으로 정렬한 뒤 가중치가 낮은 간선을 선택하면서 최소 신장 트리를 생성하는 방식이다.
    - 만약 특정 간선을 선택했을 때 사이클이 생성된다면, 해당 간선은 선택하지 않고 다음으로 가중치가 낮은 간선을 확인한다.
- 크루스칼 알고리즘에서는 가중치의 오름차순으로 간선을 정렬하는 알고리즘과 사이클의 생성 여부를 판단하는 유니온 파인드(union-find) 알고리즘을 함께 사용한다.

![Untitled](5%202(%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5)%203372a3a36a1f47b88091aa3cfb62e8b8/Untitled%201.png)

- 가중치를 오름차순으로 작은 것 부터 이어본다.
- 사이클이 형성된다면, 그 다음 가중치를 선택해 연결하며 모든 정점이 연결될 때 까지 반복한다.
- 정점을 기준으로 트리를 생성하는 프림 알고리즘과 달리 간선을 기준으로 트리를 생성한다.

**유니온 파인드 알고리즘**

- 유니온 파인드는 2개의 원소가 같은 집합에 속하는지 판단하는 알고리즘으로, 그래프에서 2개의 노드가 같은 그래프에 속하는지 판별할 수 있다.
- 그래프에는 루트 노드가 없기 때문에 대표 노드를 설정해 그래프를 구분한다.
- 유니온은 두 노드를 하나의 그래프로 합치는 연산을, 파인드는 특정 노드가 속한 그래프의 대표 노드를 찾는 연산을 의미한다.

**그리디 알고리즘(greedy algorithm)**

- 탐욕 알고리즘이라고도 하며, 각 단계에서 최선의 선택이 모여 전역으로 최적의 해결 방안을 찾는 방식이다.
- 그리디 알고리즘은 2가지 조건을 만족해야 한다.
    - 앞에서 선택한 결과가 나중의 선택에 영향을 주지 않아야 한다.
    - 지역적인 문제에 대한 최선의 선택이 전역적인 문제에 대해서도 최적의 해여야 한다.

- 배열의 뒤부터 정렬된다.

![Untitled](5%202(%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5)%203372a3a36a1f47b88091aa3cfb62e8b8/Untitled%202.png)

![Untitled](5%202(%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5)%203372a3a36a1f47b88091aa3cfb62e8b8/Untitled%203.png)

- 배열의 n번째 요소를 정렬하는 데 n-1번 비교하므로 모든 요소를 정리하기 위해선 [ n(n-2)/2 ] 만큼 연산을 수행해야 한다.
- 따라서, 시간 복잡도 O(n^2) 이 소요된다.
- 버블 정렬은 정렬을 수행하는 데 비교적 느린 편이지만, 별도의 메모리 공간이 필요하지 않다.

## 5.1.2 선택 정렬(selection sort)(⭐⭐)

- 선택 정렬은 배열을 순회하면서 배열의 앞에서부터 차례대로 각 인덱스에 들어갈 값을 선택해 위치시킨다.
- 오름차순이라면, 배열의 첫 번째 자리에는 최솟값을 위치시키고, 두 번째 자리에는 배열에서 최솟값 다음으로 작은 값을 위치시킨다.

![Untitled](5%202(%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5)%203372a3a36a1f47b88091aa3cfb62e8b8/Untitled%204.png)

![Untitled](5%202(%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5)%203372a3a36a1f47b88091aa3cfb62e8b8/Untitled%205.png)

- 이와 같이 선택 정렬은 배열을 순회하면서 각 인덱스에 최솟값을 위치시킨다.
- 배열의 크기를 n이라고 할 때, 각 인덱스 i에 들어갈 숫자를 찾기 위해 n-i개의 값을 비교한다.
- [ n(n-1)/2 ] 번 연산을 수행하므로, O(n^2)의 시간 복잡도가 소요된다.
- 버블 정렬과 마찬가지로 수행 시간은 느린 편이지만 별도의 메모리 공간이 필요하지 않고 구현도 비교적 간단한 편에 속한다.

## 5.1.3 삽입 정렬(insertion sort)(⭐⭐)

- 삽입 정렬은 배열을 앞에서부터 순회하면서 정렬된 부분의 적절한 위치에 값을 삽입하는 방식이다.

![Untitled](5%202(%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5)%203372a3a36a1f47b88091aa3cfb62e8b8/Untitled%206.png)

![Untitled](5%202(%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5)%203372a3a36a1f47b88091aa3cfb62e8b8/Untitled%207.png)

- 삽입 정렬은 배열 전체를 순회하며 각 순회에서 인덱스 i 요소를 적절한 위치에 삽입하기 위해 최대 n-1 번 탐색한다.
- [ n(n-1)/2 ] 번 연산을 수행하므로, O(n^2)의 시간 복잡도가 소요된다.

## 5.1.4 합병 정렬(merge sort)(⭐⭐⭐)

- 합병 정렬은 재귀를 이용하는 분할 정복 알고리즘이다.
- 분할은 배열을 쪼개는 것이고, 정복은 분할한 배열을 정렬하면서 하나로 합병하는 것을 의미한다.
- 그래서 배열을 크기가 0 또는 1이 될 때까지 절반씩 분할한다.
- 분할된 각각의 배열은 다시 하나의 배열로 합쳐지면서 정렬을 수행한다.

![Untitled](5%202(%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5)%203372a3a36a1f47b88091aa3cfb62e8b8/Untitled%208.png)

![Untitled](5%202(%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5)%203372a3a36a1f47b88091aa3cfb62e8b8/Untitled%209.png)

![Untitled](5%202(%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5)%203372a3a36a1f47b88091aa3cfb62e8b8/Untitled%2010.png)

- 합병 정렬의 시간 복잡도는 O(nlogn)으로 수행 시간 면에서 효율적이다.
    - O(n)은 배열이 정렬되는 데 걸리는 시간 복잡도이고, O(logn)은 배열의 분할 또는 합병 시 걸리는 시간복잡도다.

## 5.1.5 퀵 정렬(quick sort)(⭐⭐⭐)

- 퀵 정렬은 합병 정렬과 마찬가지로 분할 정복 알고리즘이다.
- 배열에서 피봇(pivot)이라는 특정 값을 선택해 피봇보다 작은 값으로 구성된 배열과 피봇보다 큰 값으로 구성된 배열로 분할해 정렬하는 방식이다.
    - 피봇은 일반적으로 배열의 첫 번째 요소나 마지막 요소를 선택한다.
    - 피봇을 기준으로 배열에서 피봇보다 작은 값은 피봇의 왼쪽으로, 피봇보다 큰 값은 오른쪽으로 옮기면서 배열을 두 개로 분할해 정렬한다.
- 퀵 정렬을 수행할 때 low와 high라는 변수를 두어 피봇보다 작은 수와 피봇보다 큰 수를 분리한다.

![Untitled](5%202(%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5)%203372a3a36a1f47b88091aa3cfb62e8b8/Untitled%2011.png)

- low는 배열의 첫 번째 요소에서 시작해 오른쪽으로 한 칸씩 이동한다.
    - low가 가리키는 값이 피봇보다 작으면 오른쪽으로 한 칸을 이동하고, 피봇보다 크면 이동하지 않는다.
- high는 배열의 마지막 요소에서 시작해 왼쪽으로 한 칸씩 이동한다.
    - high가 가리키는 값이 피봇보다 크면 왼쪽으로 한 칸을 이동하고, 피봇보다 작으면 이동하지 않는다.
- 둘 다 이동하지 않을 때, 두 변수가 가리키는 값을 교환해 배열의 왼쪽에는 피봇보다 작은 값이, 배열의 오른쪽에는 피봇보다 큰 값이 위치하도록 한다.
- low와 high가 엇갈릴 때 피봇을 기준으로 배열이 나눠졌음을 의미한다.
- 분할은 배열의 크기가 1 이하가 될 때까지 반복해서 수행한다.

![Untitled](5%202(%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5)%203372a3a36a1f47b88091aa3cfb62e8b8/Untitled%2012.png)

- 분할 정복을 기반으로 한 퀵 정렬의 평균적인 시간 복잡도는 O(nlogn)이다.
    - 하지만 평균적인 시간 복잡도가 되려면 피봇을 기준으로 배열을 균등하게 분할할 수 있어야 한다.
    - 최악의 경우 시간 복잡도는 O(n^2)이 될 수 있다.
- 피봇으로 어떤 값을 선택하느냐에 따라 퀵 정렬의 성능이 좌우된다.

## 5.1.6  힙 정렬(heap sort)(⭐⭐⭐)

- 힙 정렬은 최대 힙이나 최소 힙 자료구조를 이용해 정렬을 수행한다.
    - 최대 힙으로 오름차순 정렬을, 최소 힙으로 내림차순 정렬을 할 수 있다.
- 힙 정렬 과정은 크게 배열을 힙으로 만드는 힙 생성 알고리즘 과정과 힙에서 요소를 꺼내 정렬하는 과정으로 나눈다.
- 힙 생성 알고리즘(heapify)은 특정 노드의 두 자식 중 우선순위가 더 높은 자식 노드와 위치를 교환하는 방식이다.
- 먼저 배열을 힙으로 만드는 과정을 수행한다.

![Untitled](5%202(%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5)%203372a3a36a1f47b88091aa3cfb62e8b8/Untitled%2013.png)

![Untitled](5%202(%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5)%203372a3a36a1f47b88091aa3cfb62e8b8/Untitled%2014.png)

- 생성한 최대 힙에서 삭제 연산을 이용해 정렬을 수행한다.
- 비교순서 궁금
- 힙 정렬을 수행하면 시간 복잡도는 O(nlogn)이다.
    - 힙 생성 알고리즘을 수행하는 데 O(logn)이, 전체 요소가 n개여서 전체 정렬하는 데 O(nlogn)이 걸린다.

# **비교하지 않는 정렬 알고리즘**

## 5.1.7 기수 정렬(radix sort)(⭐)

- 기수 정렬은 비교하지 않는 정렬 알고리즘으로, 낮은 자릿수부터 정렬을 수행한다.
- 십진수에서 각 자릿수에는 0부터 9까지 숫자가 올 수 있다.
    - 그래서 숫자별로 버킷(bucket)이라는 큐를 생성한다.
    - 정렬하려는 숫자들의 각 자릿수에 해당하는 숫자를 각각의 버킷에 넣어 정렬하고 이를 자릿수만큼 반복한다.

![Untitled](5%202(%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5)%203372a3a36a1f47b88091aa3cfb62e8b8/Untitled%2015.png)

- 0부터 9까지에 해당하는 버킷을 만든다.
- 1의 자릿수를 기준으로 순서대로 버킷에 넣는다.
- 순차적으로 배열에 넣는다.
- 10의 자릿수를 기준으로 버킷에 넣는다.
- 다시 배열에 넣는다.
- 데이터 개수를 n, 최대 자릿수를 d라고 할 때 기수 정렬의 시간 복잡도는 O(dn)으로 빠른편에 속한다.
    - 하지만 버킷을 구성하기 위한 추가 메모리가 필요하고, 정렬할 수 있는 데이터 타입이 한정적이라는 단점이 있다.

## 5.1.8 계수 정렬(counting sort)(⭐)

- 계수 정렬은 이름 그대로 데이터의 개수를 세서 정렬하는 방식이다.
- 정렬하려는 데이터 숫자의 범위를 인덱스로 갖는 빈 배열을 생성한다.
- 이후 정렬히려는 배열을 순회하면서 데이터에 해당하는 인덱스의 값을 1씩 증가시킨다.
- 따라서 계수 정렬은 데이터의 범위가 0 또는 양의 정수여야 한다는 제약 조건이 있다.

![Untitled](5%202(%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%20%E1%84%89%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5)%203372a3a36a1f47b88091aa3cfb62e8b8/Untitled%2016.png)

- 그냥 정렬하려는 배열의 크기만한 빈 배열을 만들고, 인덱스 0부터  1씩 증가시키면서, 해당 계수가 정렬하려는 배열에 몇 개 있는지 카운팅 하는 알고리즘이라고 이해했다.
- 정렬하려는 데이터의 개수를 n, 데이터의 최댓값을 k라고 할 때, 계수 정렬의 시간 복잡도는 O(n+k)가 된다.
- 데이터의 최댓값이 무한대에 수렴하면 시간 복잡도 역시 무한으로 발산한다.
    - 즉, 정렬하려는 데이터가 시간 복잡도에 영향을 끼친다는 것을 알 수 있다.
    - 데이터 범위만 한 크기의 배열을 생성해야 하므로 추가로 사용되는 메모리 공간이 있다는 점을 주의해야한다.