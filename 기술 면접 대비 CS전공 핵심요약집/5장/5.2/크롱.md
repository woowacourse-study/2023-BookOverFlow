# 5.2 최소 신장 트리

- 신장 트리는 그래프의 모든 정점을 포함하는 트리를 의미한다.
- 최소 신장 트리(MST, Minimum Spanning Tree)는 가중치가 있는 그래프에서 간선의 가중치 총합이 가장 작은 신장 트리를 의미한다.

<br><br>

### 5.2.1 프림 알고리즘

- 임의의 정점을 시작점으로 트리를 확장하면서 최소 신장 트리를 생성하는 방식이다.
- 현재 트리에 포함된 정점과 연결된 간선 중 가중치가 가장 작은 간선으로 연결되는 정점을 선택하는 과정을 반복하며 모든 정점이 포함될 때까지 트리를 확장한다.

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/873f1fc1-1795-4b1f-9c7b-b52b68402004" width=500>

- 예시
    - 시작 정점은 S다.
    - S에서 갈 수 있는 정점은 A, C, B이며 각각의 간선의 가중치는 3, 6, 13이다. 가장 작은 가중치인 3을 선택하여 A를 트리에 추가한다.
    - 트리에서 갈 수 있는 정점은 B, C, D이며 각각의 간선의 가중치는 13, 5, 18이다. 가장 작은 가중치인 5를 선택하여 C를 트리에 추가한다.
    - 트리에서 갈 수 있는 정점은 B, D이며 각각의 간선의 가중치는 10, 1이다. 가장 작은 가중치인 1을 선택하여 D를 트리에 추가한다.
    - 트리에서 갈 수 있는 정점은 B, E이며 각각의 간선의 가중치는 10, 7이다. 가장 작은 가중치인 7을 선택하여 B를 트리에 추가한다.
- 가중치가 가장 작은 간선으로 연결된 정점을 트리에 추가하면서 최소 신장 트리를 생성한다.
- 배열로 구현하는 경우 시간 복잡도는 $O(n^2)$ 이고, 최소 힙으로 구현하는 경우 시간 복잡도는 $O(E\,log\,V)$이다.

<br><br>

## 5.2.2 크루스칼 알고리즘

- 간선을 오름차순으로 정렬한 뒤 가중치가 가장 낮은 간선을 선택하면서 최소 신장 트리를 생성하는 방식이다.
- 특정 간선을 선택했을 때 사이클이 생성되는 경우 해당 간선은 선택하지 않고 다음으로 가중치가 낮은 간선을 확인한다.
- 가중치를 오름차순으로 정렬하는 알고리즘과 사이클의 생성 여부를 판단하는 유니온 파인드 알고리즘을 함께 사용한다.

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/02315979-dd05-490f-8303-ea0e6505db20" width=500>

- 예시
    - 가중치가 가장 작은 1을 선택하여 D, E를 연결한다.
    - 다음으로 가중치가 가장 작은 3을 선택하여 A, B를 연결한다.
    - 다음으로 가중치가 가장 작은 5를 선택하여 B, D를 연결한다.
    - 다음으로 가중치가 가장 작은 6을 선택하면 사이클이 생기기 때문에 선택하지 않는다.
    - 다음으로 가중치가 가장 작은 7을 선택하여 C, F를 연결한다.
    - 다음으로 가중치가 가장 작은 9을 선택하여 E, F를 연결한다.
- 간선을 기준으로 트리를 생성한다.
- 간선의 개수가 E일 때 시간 복잡도는 $O(E\,log\,E)$ 이다.
- 그래프가 sparse할수록 유리하다.

<br><br>

> 유니온 파인드 (Union-Find)
> 
- 2개의 원소가 같은 집합에 속하는지 판단하는 알고리즘이다.
- 그래프에는 루트 노드가 없기 때문에 대표 노드를 설정하여 그래프를 구분한다.
- Union(x, y) : x집합 + y집합을 의미하며 집합을 합쳤을 때 최상위 노드를 반환한다.
    - 간선을 잇는 연산
- Find(x) : 연산의 시간 복잡도는 최대 O(n)
    - Union 연산의 순서에 따라 트리가 불균형해질 수 있기 때문이다.
    - 경로 압축 최적화 기법이 필요하다.

- 초기화
    
    ```cpp
    // 초기화
    parent[i] = -1; // 초기 부모의 값은 나올 수 없는 값 넣기
    ```
    
    - 자신의 부모는 나올 수 없는 값으로 초기화한다.

- Find 연산
    
    ```cpp
    // x가 속한 트리의 루트 번호를 반환한다.
    int find(int x) {
    	if (parent[x] < 0) return x; // x가 루트 노드이면 자기 자신을 반환
    	return find(parent[x]); // x가 루트가 아니라면, 재귀를 통해서 루트를 찾음
    }
    ```
    
    - 하지만 이렇게 구현하면 한 가지 문제가 있다. 아래의 그래프를 보자.
    
    <img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/1c4cdbe6-b463-447e-b1ff-e93cae8d0616" width=300>
    
    - find(1)이 호출되어 1의 부모노드를 찾기 위해 8번의 연산을 열심히 진행했다. 그런데 이 결과를 저장해놓지 않기 때문에 다시 find(1)이 호출되면 똑같이 8번의 연산을 진행해야 한다.

- Find 연산 (경로 압축 최적화)
    
    ```cpp
    // 경로 압축 최적화
    int find(int x) {
    	if (parent[x] < 0) return x; // x가 루트 노드이면 자기 자신을 반환
    	return parent[x] = find(parent[x]); // x가 루트가 아니라면, 재귀를 통해서 루트를 찾고 저장
    }
    ```
    
    - 그래서 find연산의 결과를 부모 노드로 저장해주기만 하면 된다.
    - 그럼 앞에서 봤던 트리의 구조는 다음과 같이 변경된다.
    
    <img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/158e0aed-b776-4f22-b229-a2748c86eebb" width=300>
    
    - find(1)의 연산으로 경로 압축 최적화를 진행하면 다음에 다시 find(1)이 불렸을 때 상수 시간안에 해결할 수 있게된다.
    - 경로 압축 최적화를 하지 않은 find 함수의 시간 복잡도는 $O(n)$ 이다.
    - 경로 압축 최적화를 한 find 함수의 시간 복잡도는 $O(\alpha(n))$으로 바뀐다.
    - $\alpha(n)$는 애커만 함수의 역함수로 우리가 상상할 수 있는 모든 크기의 n에 대해 4 이하의 값을 가진다고 한다.
    - 경로 압축 최적화를 하면 모든 n에 대해 상수 시간 복잡도를 갖는다는 말이다.
    
- Union 연산
    
    ```cpp
    void merge(int u, int v) {
    	u = find(u);
    	v = find(v);
    	if (u == v) return; // 루트가 같다면 같은 트리이므로 합칠 필요가 없다
    	parent[u] = v; // u의 부모는 v 
    }
    ```
    
    - find 연산을 사용하여 u와 v의 부모 노드를 찾고, 부모를 변경해주기만 하면 된다.
    - union연산은 find연산의 시간 복잡도에 영향을 받는다.
    - 경로 압축 최적화가 되어있다고 했을 때 union연산의 시간 복잡도는 find연산과 마찬가지로 상수 시간이 된다.