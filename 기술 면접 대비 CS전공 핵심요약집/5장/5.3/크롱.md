# 5.3 최단 거리 알고리즘

- 최단 거리 알고리즘은 정점 간 최단 거리를 구하기 위한 알고리즘이다.
- 다익스트라 알고리즘, 벨만-포드 알고리즘, 플로이드-워셜 알고리즘이 있다.
- 다익스트라와 벨만-포드는 특정 정점에서 다른 모든 정점들까지의 최단 거리를 구할 수 있고, 플로이드-워셜 알고리즘은 모든 정점에서 다른 모든 정점들까지의 최단 거리를 구할 수 있다.

<br><br>

## 5.3.1 다익스트라 알고리즘

- 간선의 **가중치가 음수가 아닌 경우** 특정 정점에서 다른 정점까지의 최단 거리를 구하는 알고리즘이다.
- 그리디 알고리즘으로 분류되는데 그 이유는 매 단계마다 가장 비용이 적은 노드를 선택하기 때문이다.
- 우선순위 큐를 사용하여 시간 복잡도를 줄일 수 있다.
- 시간 복잡도는 $O(E logV)$이다.
    - 모든 간선을 확인하고, 정점의 개수만큼 삭제를 진행하기 때문

- 동작원리
    1. 출발 노드를 설정한다.
    2. 최단 거리 테이블을 초기화 한다.
    3. 방문하지 않은 노드 중 최단 거리가 가장 짧은 노드를 선택하여 이동한다.
    4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.
    5. 3, 4 과정을 반복한다.

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/29e14889-6639-41f6-94e0-3320d410ceeb" width=300>

| 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- |
| 0 | ∞ | ∞ | ∞ | ∞ |

<br>

- Step1
    - 출발노드는 1이다.
    - 1번 노드에서 갈 수 있는 2, 4, 5 노드의 비용을 업데이트 한다.

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/c636c372-6cad-47df-ac1b-fc6cc6f96787" width=300>

| 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- |
| 0 | 2 | ∞ | 1 | 3 |

<br>

- Step2
    - 방문하지 않은 노드 중 가중치가 가장 작은 4번 노드를 선택해 이동한다.
    - 4번 노드에서 연결된 노드는 없기 때문에 해당 `스텝이 종료된다.

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/8660e17e-3ae2-4552-af58-02f6011e1098" width=300>

| 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- |
| 0 | 2 | ∞ | 1 | 3 |

<br>

- Step3
    - 방문하지 않은 노드 중 가중치가 가장 작은 2번 노드를 선택해 이동한다.
    - 2번 노드에서 갈 수 있는 3, 5 노드의 비용을 업데이트 한다.
    - 3번 노드의 비용은 갱신되지만, 5번 노드의 비용은 9 > 3 이기 때문에 갱신되지 않는다.

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/47e33586-6f10-43cd-8bb9-701adc9945cc" width=300>

| 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- |
| 0 | 2 | 7 | 1 | 3 |

<br>

- Step4
    - 방문하지 않은 노드 중 가중치가 가장 작은 5번 노드를 선택해 이동한다.
    - 5번 노드에서 갈 수 있는 3번 노드의 비용을 업데이트 한다. (7 > 6)

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/e67f6322-6712-4993-a98c-b7a7b6e4c7f5" width=300>

| 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- |
| 0 | 2 | 6 | 1 | 3 |

<br>

- Step5
    - 방문하지 않은 노드인 3번 노드를 선택한다.
    - 3번 노드에서 이동할 수 있는 노드는 없기 때문에 종료된다.
    - 사용하지 않은 간선 2개가 있는데 이 간선을 사용하면 이미 방문한 노드를 재방문 하는 것이기 때문에 다익스트라 알고리즘이 종료된다.

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/a3fe1b7a-18c8-4d7f-94fd-3f38aa034fa6" width=300>

| 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- |
| 0 | 2 | 6 | 1 | 3 |

<br><br>

## 5.3.2 벨만-포드 알고리즘

- 특정 정점에서 다른 정점까지의 최단 거리를 구하는 알고리즘이다.
- 간선의 가중치가 음수인 경우에도 적용할 수 있다.
- **음의 사이클이 있는 경우 최소 비용이 음의 무한대로 발산하기 때문에 알고리즘을 적용할 수 없다.**
- 시간복잡도는 $O(VE)$다.
- 정점의 수를 n이라고 했을 때 전체 간선을 n-1번 순회하며 최단 거리를 갱신한다.

- 동작 원리
    1. 출발 노드를 설정한다.
    2. 최단 거리 테이블을 초기화 한다.
    3. 아래 과정을 V-1 번 반복한다.
        - 모든 간선을 하나씩 확인한다.
        - 각 간선을 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.
- 만약 음의 사이클이 생기는지 확인하고 싶다면 3번 과정을 한 번 더 수행하면 되는데, 수행한 뒤 최단 거리 테이블이 갱신되어 있다면 음의 사이클이 있는 것이다.


![BellmanFord_algorithm_example](https://github.com/woowacourse-study/2023-cs-study/assets/84285337/a54695df-4674-4e62-a991-a2500c680c98)

<br><br>


## 5.3.3 플로이드-워셜 알고리즘

- 모든 정점에서 다른 모든 정점까지의 최단 경로를 구하는 경우 사용하는 알고리즘이다.
- 모든 노드에 대해 동작하는 알고리즘이기 때문에 노드를 방문할 때 방문한 노드인지 확인할 필요가 없다.
- 매 단계마다 $O(N^2)$의 연산을 통해 **현재 노드를 거쳐가는 모든 경로를 고려한다.**
- 따라서 N개의 노드가 존재한다면 N번의 단계마다 $O(N^2)$의 연산을 진행하기 때문에 플로이드-워셜 알고리즘의 시간복잡도는 $O(N^3)$이 된다.
- 정점 1000개까지는 플로이드-워셜 알고리즘을 사용할만하다.
- 2차원 배열을 처리해야 하므로 공간복잡도는 $O(N^2)$이다.
- 각 단계에서 비용을 확인하는 점화식은 다음과 같다.
    - $D_{ab} = min(D_{ab}, D_{ak} + D_{kb})$
    - A에서 B로 가는 최소 비용과 A에서 K를 거쳐 B로 가는 최소 비용을 비교하는 것이다.
- 방향 그래프이던, 무방향 그래프이던 상관없다.
- 간선의 가중치가 음수여도 잘 동작하지만 음수인 사이클이 있는 경우 문제가 생긴다.

<br>

- Step 0

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/58240f37-0232-4fdb-9649-0c67e9cf6392" width=300>

| 출발/도착 | 1번 | 2번 | 3번 | 4번 |
| --- | --- | --- | --- | --- |
| 1번 | 0 | 2 | 5 | 3 |
| 2번 | ∞ | 0 | ∞ | ∞ |
| 3번 | 4 | 7 | 0 | ∞ |
| 4번 | ∞ | 3 | 1 | 0 |

<br>

- Step1
    - 1번 노드를 거쳐가는 경우를 고려한다.
    - D23 = min(D23, D21 + D13)
    - D24 = min(D24, D21 + D14)
    - D32 = min(D32, D31 + D12)
    - D34 = min(D34, D31 + D14)
    - D42 = min(D42, D41 + D12)
    - D43 = min(D43, D41 + D13)

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/e56e532c-376c-4e19-b1a1-6392144c14b8" width=300>

| 출발/도착 | 1번 | 2번 | 3번 | 4번 |
| --- | --- | --- | --- | --- |
| 1번 | 0 | 2 | 5 | 3 |
| 2번 | ∞ | 0 | ∞ | ∞ |
| 3번 | 4 | 6 | 0 | 7 |
| 4번 | ∞ | 3 | 1 | 0 |
- 3 → 2, 3 → 4 로 이동하는 최소 비용이 줄어들었다.

<br>

- Step2
    - 2번 노드를 거쳐가는 경우를 고려한다.
    - D13 = min(D13, D12 + D23)
    - D14 = min(D14, D12 + D24)
    - D31 = min(D31, D32 + D21)
    - D34 = min(D34, D32 + D24)
    - D41 = min(D41, D42 + D21)
    - D43 = min(D43, D42 + D23)

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/e870af15-3a8a-468c-a095-24082ea24e54" width=300>

| 출발/도착 | 1번 | 2번 | 3번 | 4번 |
| --- | --- | --- | --- | --- |
| 1번 | 0 | 2 | 5 | 3 |
| 2번 | ∞ | 0 | ∞ | ∞ |
| 3번 | 4 | 6 | 0 | 7 |
| 4번 | ∞ | 3 | 1 | 0 |

<br>

- Step3

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/45e62239-05e2-421f-a0a8-8a0f6dc20b56" width=300>

| 출발/도착 | 1번 | 2번 | 3번 | 4번 |
| --- | --- | --- | --- | --- |
| 1번 | 0 | 2 | 5 | 3 |
| 2번 | ∞ | 0 | ∞ | ∞ |
| 3번 | 4 | 6 | 0 | 7 |
| 4번 | 5 | 3 | 1 | 0 |

<br>

- Step4

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/779ad826-b63c-4729-af62-9a653fe1e455" width=300>

| 출발/도착 | 1번 | 2번 | 3번 | 4번 |
| --- | --- | --- | --- | --- |
| 1번 | 0 | 2 | 4 | 3 |
| 2번 | ∞ | 0 | ∞ | ∞ |
| 3번 | 4 | 6 | 0 | 7 |
| 4번 | 5 | 3 | 1 | 0 |