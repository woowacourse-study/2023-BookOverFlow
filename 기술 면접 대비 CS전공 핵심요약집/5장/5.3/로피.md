# 5.3 최단 거리 알고리즘

**최단 거리 알고리즘**

- 정점 간 최단 거리를 구하기 위한 알고리즘
- ‘다익스트라 알고리즘’, ‘벨만-포드 알고리즘’, ‘플로이드-워셜 알고리즘’

## 5.3.1 다익스트라 알고리즘

**다익스트라 알고리즘(Dijkstra algorithm)**

- 간선의 가중치가 음수가 아닌 경우 특정 정점에서 다른 정점까지의 최단 거리를 구하는 알고리즘
- 시작 정점을 설정, 방문 가능하면서 비용이 가장 적게 드는 정점에 방문해 비용을 갱신
- 각 정점의 비용에 우선순위 큐를 사용 → 시간 복잡도 효율적
- **매번 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택하여 한 단계씩 최단 거리를 구해나간다.**

**작동 방식**

1. 초기에 시작 정점에서 방문 가능한 정점에 대한 비용을 갱신하고 나머지 정점에 대한 비용은 무한대(INF, infinite)로 설정
2. 방문하지 않는 정점 중 비용이 가장 적게 드는 정점에 방문, 해당 정점과 연결된 다른 정점의 비용을 갱신해야 하는지 확인, 만약 해당 정점을 거쳐 다른 정점에 방문할 때 기존보다 적은 비용이 든다면 비용 갱신
3. 모든 정점을 방문할 때까지 이와 같은 방식으로 정점 방문 비용 갱신, 모든 정점 방문시 알고리즘 수행 종료

![IMG_7889BCF9E564-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/20a1675f-764d-4f4f-a878-10f42f5f630b)

![dijkstra.gif](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/86bcc6d7-6059-40c4-b05d-292a4258b75f)

**구현 방법**

1. 순차 탐색

'방문하지 않은 노드 중 거리값이 가장 작은 노드'를 선택해 다음 탐색 노드로 삼는다. 그 노드를 찾는 방식이 순차 탐색이 된다. 즉 거리 테이블의 앞에서부터 찾아내야 하므로 노드의 개수만큼 순차 탐색을 수행해야 한다. 따라서 노드 개수가 N이라고 할 때 각 노드마다 최소 거리값을 갖는 노드를 선택해야 하는 순차 탐색이 수행되므로 

(*N*−1)×*N*=*O*(*N^*2)의 시간이 걸린다.

1. 우선순위 큐

거리 값을 담을 우선순위 큐는 힙으로 구현하고, 만약 최소 힙으로 구현한다면 매번 루트 노드가 최소 거리를 가지는 노드가 될 것이다.

우선순위 큐에서 사용할 '우선순위'의 기준은 '시작 노드로부터 가장 가까운 노드'가 된다. 따라서 큐의 정렬은 최단 거리인 노드를 기준으로 최단 거리를 가지는 노드를 앞에 배치한다.

위의 순차 탐색을 쓰는 구현과는 다르게 우선순위 큐를 사용하면 방문 여부를 기록할 배열은 없어도 된다. 우선순위 큐가 알아서 최단 거리의 노드를 앞으로 정렬하므로 기존 최단 거리보다 크다면 무시하면 그만이다. 만약 기존 최단거리보다 더 작은 값을 가지는 노드가 있다면 그 노드와 거리를 우선순위 큐에 넣는다. 우선순위 큐에 삽입되는 형태는 `<거리, 노드>` 꼴이다.

간선의 수를 E(Edge), 노드의 수를 V(Vertex)라고 했을 때 *O*(*E* l*og V*)가 된다. 우선순위 큐에서 꺼낸 노드는 연결된 노드만 탐색하므로 최악의 경우라도 총 간선 수인 E만큼만 반복한다. 즉 하나의 간선에 대해서는 *O*(l*og E*)이고, E는 *V^*2보다 항상 작기 때문에 E개의 간선을 우선순위 큐에 넣었다 빼는 최악의 경우에 대해서는*O*(*E* l*og V*)이다.

## 5.3.2 벨만-포드 알고리즘

**벨만-포드 알고리즘(Bellman-Ford Algorithm)**

- 특정 정점에서 다른 정점까지의 최단 거리를 구하는 알고리즘
- 간선의 가중치가 음수인 경우에도 적용
- 음의 사이클이 있으면 최소 비용이 무한하게 줄어들어서 알고리즘 적용할 수 없음
- **(정점 - 1)번의 매 단계마다 모든 간선을 전부 확인하면서 모든 노드간의 최단 거리를 구해나간다.**
    - (정점 - 1)번의 간선 탐색을 하는 이유는 최대 n - 1 개의 간선을 이용해 특정 노드에서 다른 노드까지의 최단 경로를 생성할 수 있기 때문
    - 만약 정점 개수 이상의 간선을 사용했을 때 최단 거리가 갱신된다면 이는 음의 사이클이 존재함을 의미
    - 음의 사이클이 존재한다면 최단 경로가 존재할 수 없으므로 모순 발생
    - 즉, n개 이상의 간선을 사용해 최단 거리를 생성할 수 없음
    

**동작 과정**

1. 출발 노드를 설정한다.
2. 최단 거리 테이블을 초기화한다.
3. 다음의 과정을 (V(=정점) - 1)번 반복한다.
    1. 모든 간선 E개를 하나씩 확인한다.
    2. 각 간선을 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.
- 만약 음수 간선 순환이 발생하는지 체크하고 싶다면 3번 과정을 한 번 더 수행한다.**->** 이때 최단 거리 테이블이 갱신된다면 음수 간선 순환이 존재하는 것이다.
- **V번째 단계에서 최단 거리 테이블이 갱신 여부로 음수 간선 순환을 확인**

![bellman.gif](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/b31c6a28-d343-48a1-bde9-6110c1c48c0d)

![IMG_B5AAD76B856C-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/d5fa54a2-1636-4591-b5f9-7540f08f9d20)

음수 간선이 있어도 최적의 해를 찾을 수 있다. (음수 간선의 순환을 감지할 수 있기 때문이다.)

V번 반복에 대해서 해당 정점과 연결되어 있는 모든 간선(E)을 탐색해주기 때문에 시간 복잡도는 `O(V*E) = O(VE)`가 된다.

### 플로이드-와샬(**Folyd-Warshall)** 알고리즘

- 그래프의 최단 경로 구하는 알고리즘 하나
- 모든 정점에서 모든 정점까지 최단 거리를 구함
- 시간 복잡도 `O(n^3)`
- 동적 계획법 이용

![floyd.gif](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/e01646d4-415b-4272-b05c-c516e38bb6a4)
