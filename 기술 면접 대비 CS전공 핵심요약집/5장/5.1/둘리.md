# 자료구조 5.1

- 비교하는 정렬 : 버블, 선택, 삽입, 합병, 힙, 퀵
- 비교하지 않는 정렬 : 계수, 기수

# 버블 정렬(Bubble Sort)

![IMG_6541](https://github.com/woowacourse-study/2023-cs-study/assets/15646373/17ab9c29-20b5-4b2d-a6c2-5509b3218bb8)

- 양옆에 위치한 두 값을 비교하면서 크기 순으로 정렬
- 배열의 뒤에서부터 정렬
- n번째의 요소를 정렬하는 데 n-1번 비교 → (n-1) + (n-2) + … + 2 + 1 = n(n-1)/2 만큼 연산 수행
→ O(n^2)
- 느린 편이지만 별도의 메모리 공간 필요X

# 선택 정렬(Selection Sort)

![IMG_6544](https://github.com/woowacourse-study/2023-cs-study/assets/15646373/85df30a3-8b4c-47a5-8c04-7e1e2583826f)

- 배열을 순회하면서 배열의 앞에서부터 차례대로 각 인덱스에 들어갈 값(최솟값)을 선택해 위치
- 인덱스 i에 들어갈 값을 선택하는 경우, i-1까지는 정렬이 완료된 상태,
인덱스 i부터 마지막 인덱스까지의 요소 중 최솟값 선택,
선택한 최솟값과 인덱스 i에 담긴 값의 위치를 교환
- 배열의 크기 n, 각 인덱스 i에 들어갈 숫자를 찾기 위해 n-i개의 값을 비교
(n-1) + (n-2) + … + 2 + 1 = n(n-1)/2번 연산 수행 → O(n^2)
- 느린 편이지만 별도의 메모리 공간 필요X, 구현 간단

# 삽입 정렬(Insertion Sort)

![IMG_6545](https://github.com/woowacourse-study/2023-cs-study/assets/15646373/bc2cfe6b-4f8a-480d-ab62-7816c4079335)

- 배열을 앞에서부터 순회하면서 정렬된 부분의 적절한 위치에 값을 삽입하는 방식
- 인덱스 i에 있는 a를 정렬할 차례일 때, 인덱스 0 ~ i-1까지는 이미 정렬된 상태
이 때 정렬된 부분에서 a보다 작거나 같은 수와 a보다 큰 수 사이에 a 삽입
- 전체 배열을 순회하며 각 순회에서 인덱스 i 요소를 적절한 위치에 삽입하기 위해 최대 n-i번 탐색
1 + 2 + … + (n-2) + (n-1) = n(n-1)번 연산 수행 → O(n^2)

# 합병 정렬(Merge Sort)

![IMG_6546](https://github.com/woowacourse-study/2023-cs-study/assets/15646373/4c9fdefb-69da-4228-a09f-1c0b2cc47545)

![IMG_6547](https://github.com/woowacourse-study/2023-cs-study/assets/15646373/b1abdc20-bb46-4ea1-b752-5f02a8bdfd7a)

![IMG_6548](https://github.com/woowacourse-study/2023-cs-study/assets/15646373/c0a7d6d5-63f9-4ac0-9914-03ab8b44d595)

- 재귀를 이용하는 분할 정복 알고리즘
- 분할 - 배열 쪼개기, 정복 - 분할한 배열을 정렬하면서 하나로 합병
정렬하려는 배열을 크기가 0 or 1이 될 때까지 절반씩 분할
분할된 각각의 배열이 다시 하나의 배열로 합쳐지며 정렬 수행
- 배열이 정렬되는 데 걸리는 시간 복잡도 O(n)
배열의 분할 또는 합병 시 걸리는 시간 복잡도 O(log n)
⇒ O(n log n)

# 퀵 정렬(Quick Sort)

![IMG_6549](https://github.com/woowacourse-study/2023-cs-study/assets/15646373/45bd6853-fe86-461f-a6c4-fb140764d00f)

![IMG_6550](https://github.com/woowacourse-study/2023-cs-study/assets/15646373/b8978904-3910-44af-a800-34e491fac574)

![Untitled](https://github.com/woowacourse-study/2023-cs-study/assets/15646373/3089002c-8774-459d-b378-2324850ccf28)

- 분할 정복 알고리즘
- 배열에서 피봇(pivot)이라는 특정 값을 선택해 피봇보다 작은 값으로 구성된 배열과 피봇으로 큰 값으로 구성된 배열로 분할해 정렬
    - 피봇 → 일반적으로 배열의 첫 번째 요소나 마지막 요소 선택ㅍㅅ5
- 피봇을 기준으로 배열에서 피봇보다 작은 값은 피봇의 왼쪽으로, 피봇보다 큰 값은 오른쪽으로 옮기면서 배열을 두 개로 분할해 정렬
- 분할 과정
    - low, high 변수를 두어 피봇보다 작은 수와 큰 수를 분리
    - low는 배열의 첫 번재 요소에서 시작해 오른쪽으로 한 칸씩 이동
        - low가 가리키는 값이 피봇보다 작으면 오른쪽으로 한 칸 이동, 크면 이동X
    - high는 배열의 마지막 요소에서 시작해 왼쪽으로 한 칸씩 이동
        - high가 가리키는 값이 피봇보다 크면 왼쪽으로 한 칸 이동, 작으면 이동X
    - low, high 둘 다 이동하지 않을 때 두 변수가 가리키는 값을 교환하여 배열의 왼쪽에는 피봇보다 작은 값, 오른쪽에는 피봇보다 큰 값이 위치하도록 함
    - 배열의 크기가 1 이하가 될 때까지 반복해서 수행
- 피봇을 기준으로 배열을 균등하게 분할할 수 있는 경우, 평균적인 시간 복잡도는 O(n log n)
역순으로 정렬된 배열에서 첫 번째 요소를 피봇으로 선택하는 경우 배열이 분할되지 않아서 시간 복잡도 O(n^2)
    - 피봇으로 어떤 값을 선택하느냐에 따라 퀵 정렬의 성능이 좌우됨
    
    # 힙 정렬(Heap Sort)
    
    ![IMG_6551](https://github.com/woowacourse-study/2023-cs-study/assets/15646373/047a3728-d4af-4664-8a54-03a529119005)

    ![IMG_6552](https://github.com/woowacourse-study/2023-cs-study/assets/15646373/f3bb62d0-6fa3-434d-857f-263238c81c9f)

    - 최대 힙 or 최소 힙 자료구조를 이용해 정렬 수행
        - 최대 힙으로 오름차순 정렬, 최소 힙으로 내림차순 정렬
    - 배열을 힙으로 만드는 힙 생성 알고리즘 과정 + 힙에서 요소를 꺼내 정렬하는 과정
        - 힙 생성 알고리즘(heapify) : 특정 노드의 두 자식 노드 중 우선순위가 더 높은 자식 노드와 위치를 교환하는 방식
    - 힙 생성 알고리즘을 수행하는 데 O(log n), 전체 요소가 n개라서 전체 정렬하는데 O(n log n)
    ⇒ O(n log n)

# 기수 정렬(Radix Sort)

![IMG_6553](https://github.com/woowacourse-study/2023-cs-study/assets/15646373/65f9c546-f286-49d0-a230-e591745d6dc2)

- 비교하지 않는 정렬 알고리즘
- 낮은 자릿수부터 정렬 수행
- 각 자릿수에는 0~9까지의 숫자가 올 수 있고, 숫자별로 버킷(bucket)이라는 큐 생성
- 정렬하려는 숫자들의 각 자릿수에 해당하는 숫자를 각각의 버킷에 넣어 정렬하고 이를 자릿수만큼 반복
- 데이터 개수 n, 최대 자릿수를 d라고 할 때 시간 복잡도 O(dn)
- 버킷을 구성하기 위한 추가 메모리가 필요하고 정렬할 수 있는 데이터 타입이 한정적이라는 단점

# 계수 정렬(Counting Sort)

![IMG_6554](https://github.com/woowacourse-study/2023-cs-study/assets/15646373/3dfff0a3-b033-448a-ac4e-3f59b593d579)

- 비교하지 않는 정렬 알고리즘
- 데이터의 개수를 세서 정렬하는 방식
- 정렬하려는 데이터의 범위를 인덱스로 갖는 빈 배열을 생성
ex. 데이터의 범위가 0~99라면 크기가 100인 빈 배열을 생성
- 정렬하려는 배열을 순회하면서 데이터에 해당하는 인덱스 값 +1 증가
    - 데이터의 범위가 0 or 양의 정수여야한다는 제약 조건이 있음
- 정렬하려는 데이터의 개수 n, 데이터의 최댓값 k일 때, 시간 복잡도 O(n+k)
    - 데이터의 최댓값이 무한대에 수렴하면 시간 복잡도 역시 무한으로 수렴
    - 추가로 사용하는 메모리 공간이 필요함
