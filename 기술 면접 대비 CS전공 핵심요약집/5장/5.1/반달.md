# 5.1 정렬 알고리즘

## 5.1.1 버블 정렬(bubble sort)
> 비교 기반 정렬 알고리즘인 버블 정렬(bubble sort)은 양옆에 위치한 두 값을 비교하면서 크기 순으로 정렬한다.

### 버블 정렬의 특징
- 배열의 뒤에서부터 정렬된다.
- 원소들이 서로 자리를 바꿔가며 배열의 끝을 도달하는 모습이 마치 물위로 공기방울이 떠오르는 현상 같다하여 버블정렬이다.
- 위와 같은 이유로 정렬을 위한 순회를 할 때마다. 배열의 크기를 n이라고 했을 때 n - 1, n - 2.. 이런식으로 순회할 양이 적어진다.
- 배열의 n번째 원소를 정렬하는 데 n - 1번 비교하므로 배열의 모든 원소를 정렬하려면
- (n - 1) + (n - 2) + ... + 2 + 1 = n(n - 1) / 2 만큼 연산을 수행해야한다.
- 따라서 시간 복잡도는 O(n²)이다.

### 버블 정렬의 장단점
#### 장점
- 알고리즘이 단순하다.
- 별도의 메모리 공간이 필요하지 않다.
- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않다.
    - -> 제자리 정렬(in-place sorting)
- 안정 정렬(Stable Sort) 이다.
#### 단점
- 시간 복잡도가 다른 정렬 알고리즘에 비해 매우 느린 편이다.
    - 최악 최소 평균 모두 O(n²)
- 정렬되어있지 않은 원소 두개를 스왑하는 연산이 자주 일어난다.

---
## 5.1.2 선택 정렬(selection sort)
> 비교기반 정렬 알고리즘인 선택 정렬(selection sort)은 배열을 순회하면서 배열의 앞에서부터 차례대로 각 인덱스에 들어갈 값을 선택해 위치시킨다.

### 선택 정렬의 특징
- 오름차순 정렬을 기준으로 배열의 첫 번째 자리에는 최소값을 위치시키고, 배열의 두 번째 자리에는 배열에서 최솟값 다음으로 작은 값을 위치시킨다.
- 버블정렬이 배열의 맨마지막 원소부터 정렬된다는 점에 비해 선택 정렬은 배열의 앞부분 부터 정렬된다.
- 배열을 순회하면서 각 인덱스에 최솟값을 위치시킨다.
- 배열의 크기를 n이라고 할 때, 각 인덱스 i에 들어갈 숫자를 찾기 위해 n - i개의 값을 비교한다.
- (n - 1) + (n - 2) + ... + 2 + 1 = n(n - 1) / 2 만큼 연산을 수행해야 한다.
- 따라서 시간 복잡도는 O(n²)이다.

### 선택정렬의 장단점
#### 장점
- 알고리즘이 단순하다.
- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않다.
    - -> 제자리 정렬(in-place sorting)

#### 단점
- 시간 복잡도가 다른 정렬 알고리즘에 비해 매우 느린 편이다. (O(n²))
- 불안정 정렬이다.(Unstable Sort)

---
## 5.1.3 삽입 정렬(insertion sort)
> 비교 기반 정렬 알고리즘인 삽입 정렬(insertion sort)은 배열을 앞에서부터 순회하면서 정렬된 부분의 적절한 위치에 값을 삽입하는 방식이다.

### 삽입 정렬의 특징
- 오름차순으로 정렬할 때 삽입 정렬의 작동 방식은 다음과 같다.
- 인덱스 i에 있는 a를 정렬할 차례일 때, 인덱스 0부터 i - 1까지는 이미 정렬된 상태다. 이때 배열의 정렬된 부분에서 a보다 작거나 같은 수와 a보다 큰 수 사이에 a를 삽입한다.
- 삽입 정렬은 전체 배열을 순회하며 각 순회에서 인덱스 i 요소를 적절한 위치에 삽입하기 위해 최대 n-i번을 탐색한다.
- 1 + 2 + ... + (n - 2) + (n - 1) = n(n - 1) / 2 만큼 연산을 수행해야 한다.
- 따라서 시간 복잡도는 O(n²)이다.

### 삽입 정렬의 장단점
#### 장점
-  알고리즘이 단순하다.
- 대부분의 원소가 이미 정렬되어 있는 경우, 매우 효율적일 수 있다.
    - 최선의 경우 O(n)
- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다.
    - -> 제자리 정렬(in-place sorting)
- 안정 정렬(Stable Sort)이다.
- Selection Sort나 Bubble Sort과 같은 O(n²) 알고리즘에 비교하여 상대적으로 빠르다.

#### 단점
- 평균과 최악의 시간복잡도가 O(n²)으로 비효율적이다.
- Bubble Sort와 Selection Sort와 마찬가지로, 배열의 길이가 길어질수록 비효율적이다.

> [!question]
> 선택 정렬과 삽입 정렬의 차이는 무엇인가요?
>

> [!answer]
> 두 정렬 모두 맨 앞의 index를 찾는다는 공통점을 가지고 있지만,
> 선택 정렬의 경우 i 인덱스를 찾기위해 배열 i + 1 인덱스부터 맨 마지막 인덱스까지 순회를 해야하고,
> 삽입 정렬의 경우 i 인덱스를 찾기 위해 배열을 전부 순회하는게 아닌 필요한 만큼만 최소한으로 순회한다는 장점을 가진다.

---

## 5.1.4 합병 정렬(merge sort)
> 비교 기반정렬 알고리즘인 합병 정렬(merge sort)은 재귀를 이용하는 분할 정복 알고리즘이다.

### 합병 정렬의 특징
- 분할은 배열을 쪼개는 것이고, 정복은 분할한 배열을 정렬하면서 하나로 합병하는 것을 의미한다.
- 정렬하려는 배열을 크기가 0 또는 1이 될 때까지 절반씩 분할한다. 분할된 각각의 배열은 다시 하나의 배열로 합쳐지면서 정렬을 수행한다.
- 배열이 정렬되는데 필요한 시간 복잡도가 O(n) 배열의 분할 또는 합병 시 걸리는 시간 복잡도가 O(log n)이기 때문에 총 O(n log n)이라는 시간 복잡도가 소요된다.

### 합병 정렬의 장단점
#### 장점
- 어떤 데이터를 어떤 순서로 가지던 평균, 최악, 최선의 경우 O(n log n)의 시간 복잡도를 가진다.
- 안정정렬이다.
- 연결리스트를 정렬할 때 퀵 정렬을 포함한 다른 정렬들보다 효율적이다.

#### 단점
- 배열로 구현시 합병한 배열을 저장할 또다른 배열이 필요하다.
- 데이터가 많으면 많을 수록 이동 회수가 많아 비효율 적이다.

---

## 5.1.5 퀵정렬
> 비교 기반 정렬 알고리즘인 퀵 정렬(quick sort)은 합병 정렬과 마찬가지로 분할 정복 알고리즘이다.

### 퀵정렬의 특징
- 배열에서 피봇(pivot)이라는 특정 값을 선택해 피봇보다 작은 값으로 구성된 배열과 피봇보다 큰 값으로 구성된 배열로 분할해 정렬하는 방식이다.
- 재귀호출이 한 번 진행될 때마다 최소한 하나의 원소는 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.
- 퀵 정렬은 다음 단계로 이루어 진다.
    - 분할(Divide): 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)로 분할한다.
    - 정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출 을 이용하여 다시 분할 정복 방법을 적용한다.
    - 결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병한다.

### 퀵정렬의 장단점
#### 장점
- 불필요한 데이터의 이동을 줄이고 먼 거리의 데이터를 교환할 뿐만 아니라, 한 번 결정된 피벗들이 추후 연산에서 제외되는 특성 때문에, 시간 복잡도가 O(n log n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.
- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다.

#### 단점
- **불안정 정렬(Unstable Sort)** 이다.
- 정렬된 배열에 대해서는 Quick Sort의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.

---

## 5.1.6 힙 정렬
> 비교 기반 정렬 알고리즘인 힙 정렬(heap sort)은 최대 힙이나 최소 힙 자료구조를 이용해 정렬을 수행한다.

### 힙 정렬의 특징
- 최대 힙으로 오름차순 정렬을, 최소 힙으로 내림차순 정렬을 할 수 있다.
- 힙 정렬 과정은 크게 배열을 힙으로 만드는 힙 생성 알고리즘 과정과 힙에서 원소를 꺼내 정렬하는 과정으로 나뉜다.
    - 힙 생성 알고리즘(heapify)은 특정 노드의 두 자식 노드 중 우선순위가 더 높은 자식 노드와 위치를 교환하는 방식이다.
- 힙 생성 알고리즘을 수행하는 데 O(log n)이, 전체 원소가 n개여서 전체 정렬하는 데 O(n log n)이 걸린다.

### 힙 정렬의 장단점
#### 장점
- 최댓값, 최소값을 찾는데 유리하다.
#### 단점
- 퀵, 합병 정렬에 비해 시간적으로 느려서 사용빈도가 높진 않다.

---

## 5.1.7 기수 정렬
> 기수 정렬(radix sort)은 비교하지 않는 정렬 알고리즘으로, 낮은 자릿수부터 정렬을 수행한다.

### 기수 정렬의 특징
- 십진수에서 각 자릿수에는 0부터 9까지 숫자가 올 수 있다. 그래서 숫자별로 버킷(bucket)이라는 큐를 생성한다.
- 정렬하려는 숫자들의 각 자릿수에 해당하는 숫자를 각각의 버킷에 넣어 정렬하고 이를 자릿수만큼 반복한다.

### 기수 정렬의 장단점
#### 장점
- 데이터 개수를 n, 최대 자릿수를 d라고 할 때 기수 정렬의 시간 복잡도는 O(dn)으로 빠른 편에 속한다.
#### 단점
- 정렬할 수 있는 데이터 타입음 문자열과 정수다. 부동소수점은 정렬이 불가하다.
- 버킷을 구현할 큐를 사용할 추가적인 메모리가 필요하다.

---

## 5.1.8 계수 정렬
> 비교하지 않는 정렬 알고리즘인 계수 정렬(counting sort)은 이름 그대로 데이터의 개수를 세서 정렬하는 방식이다.

### 계수 정렬의 특징
- 정렬하려는 데이터의 범위를 인덱스로 갖는 빈 배열을 생성하는데, 데이터 범위가 부터 99까지라면 크기가 100인 빈 배열을 생성한다.
- 이후 정렬하려는 배열을 순회하면서 데이터에 해당하는 인덱스의 값을 1씩 증가시킨다.
- 따라서 계수 정렬은 데이터의 범위가 0 또는 양의 정수여야 한다는 제약 조건이 있다.

### 계수 정렬의 장단점
#### 장점
- O(n)이라는 빠른 시간복잡도를 가진다.

#### 단점
- 데이터 범위만 한 크기의 배열을 생성해야하므로 추가로 사용하는 메모리 공간 낭비가 크다.
