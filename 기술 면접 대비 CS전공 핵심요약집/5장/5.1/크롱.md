# 5.1 정렬 알고리즘

- 정렬 알고리즘은 비교하는 정렬 알고리즘과 비교하지 않는 정렬 알고리즘으로 구분할 수 있다.
- 비교하는 정렬 : 버블, 선택, 삽입, 합병, 힙, 퀵 정렬
- 비교하지 않는 정렬 : 기수, 계수

<br><br>

## 5.1.1 버블 정렬(Bubble Sort)

- 양옆에 위치한 두 값을 비교하면서 크기 순으로 정렬한다.
- 배열의 뒤에서부터 정렬된다.

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/9599f6b7-92f9-456c-b52e-126428a4325c" width=600>

- n개의 데이터를 정렬하는데 n-1번의 비교 연산이 필요하다. 총 연산의 수는 $\frac{n(n-1)}{2}$ 이다.
- 시간 복잡도는 $O(n^2)$ 이다.
- 별도의 메모리 공간이 필요하지 않다.

<br><br>

## 5.1.2 선택 정렬(Selection Sort)

- 배열을 순회하면서 배열의 앞에서부터 차례대로 각 인덱스에 들어갈 값을 선택해 위치시킨다.
- $i$ 번째 들어갈 원소를 찾는 경우 $i-1$ 번째 까지의 원소들은 모두 정렬된 상태다. 따라서 $i$ 부터 마지막 원소까지 중 가장 최솟값을 선택한다.
- 선택한 최솟값과 $i$ 에 담긴 값의 위치를 교환한다.

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/dea046e0-87dc-4e8f-8e9d-361c93aab5f1" width=600>

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/b28fcde1-1516-45a8-8522-9257ede48abd" width=400>  

- 배열의 크기를 $n$이라고 했을 때 각 인덱스 $i$ 에 들어가는 원소를 찾기 위해서는 $n - i$ 번의 비교 연산이 필요하다. 총 연산의 수는 $\frac{n(n-1)}{2}$ 이다.
- 시간 복잡도는 $O(n^2)$ 이다.
- 별도의 메모리 공간이 필요하지 않다.

<br><br>

## 5.1.3 삽입 정렬(Insertion Sort)

- 배열을 앞에서부터 순회하면서 정렬된 부분의 적절한 위치에 값을 삽입하는 방식이다.
- 삽입 정렬은 데이터의 개수가 적으면 성능이 좋다.
- 입력이 내림차순인 경우 최악의 경우 $O(n^2)$, 오름차순인 경우 최적의 경우 $O(n)$이다.
- $i$ 번째 들어갈 원소를 찾는 경우 $i-1$ 번째 까지의 원소들은 모두 정렬된 상태다. 배열이 정렬된 상태에서 값 a의 위치를 찾아 삽입한다.

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/ef86a245-b324-4c57-bbb9-937d2825307b" width=600>

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/df34bcec-20f5-40a0-9cd6-542f5c7910d3" width=400>



- 전체 배열을 순회하며 각 순회에서 인덱스 $i$ 에 들어가는 원소의 자리를 찾기 위해서는 $n - i$ 번의 비교 연산이 필요하다. 총 연산의 수는 $\frac{n(n-1)}{2}$ 이다.
- 시간 복잡도는 $O(n^2)$ 이다.

<br><br>

## 5.1.4 합병 정렬(Merge Sort)

- 재귀를 이용하는 분할 정복 알고리즘이다.
- 분할은 배열을 나누는 것이고 정복은 나눈 배열을 하나로 합병하며 정렬하는 것이다.
- 정렬하려는 배열의 크기가 0 또는 1이 될 때까지 절반씩 나눈다.
- 합병 정렬은 키의 대소비교를 통해 정렬하는 알고리즘 중 최적의 알고리즘이다.


<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/242f0d64-cdb0-4f90-ac02-05956fdba5d5" width=400>

- 합병하려는 두 배열은 정렬이 완료된 상태이며, 각 배열의 앞에 있는 요소부터 비교하여 정렬한다.

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/28aab233-86a8-4ec3-a700-bb9e9d3153a5" width=400>


- 시간 복잡도는 $O(nlog\,n)$ 이다.
- $O(n)$ 은 배열이 정렬되는데 걸리는 시간이고 $O(log\,n)$ 은 배열이 나뉘고 합병되는데 걸리는 시간이다.

<br><br>

## 5.15 퀵 정렬(Quick Sort)

- 분할정복 알고리즘이다.
- **피벗**이라는 특정 값을 선택해 피벗보다 작은 값으로 구성된 배열과 피벗보다 큰 값으로 구성된 배열로 분할해 정렬하는 방식이다.
- 일반적으로 피봇은 배열의 첫 번째 원소나 마지막 원소를 선택한다.
- 피벗을 기준으로 배열에서 피벗보다 작은 값은 피벗의 왼쪽, 피벗보다 큰 값은 오른쪽으로 옮긴다.
- low와 high를 두고 움직이며 배열을 정렬한다.
- low
    - 첫 번째 원소부터 시작하여 오른쪽으로 이동한다.
    - 피벗보다 큰 값이 나올 때까지 움직인다.
- high
    - 마지막 원소부터 시작하여 왼쪽으로 이동한다.
    - 피벗보다 작은 값이 나올 때까지 움직인다.
- low와 high가 모두 멈춘경우 두 위치에 있는 값을 교환한다.
- 나눠진 배열 각각에 다시 퀵 정렬을 수행한다.

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/e7f70b70-7b82-41b8-8773-0e900b9adc4e" width=600>

- 퀵 정렬의 평균적인 시간 복잡도는 $O(nlog\,n)$ 이다.
- 1개와 $n-1$개로 나눠지도록 피벗을 설정하는 경우 최악의 경우이고 이 때의 시간 복잡도는 $O(n^2)$ 이다.

<br><br>

## 5.1.6 힙 정렬

- 최대 힙이나 최소 힙 자료구조를 이용해 정렬을 수행한다.
- 힙 정렬 과정은 크게 배열을 힙으로 만드는 힙 생성 알고리즘 과정과 힙에서 요소를 꺼내 정렬하는 과정으로 나눈다.
- 힙 생성 알고리즘은 특정 노드의 두 자식 노드 중 우선순위가 더 높은 자식 노드와 위치를 교환하는 방식이다.

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/93296049-42d3-4cc9-b2e0-455b7f650f3b" width=400>


- 생성한 힙에서 삭제 연산을 진행하며 정렬을 수행한다.
- 삭제 연산으로 꺼낸 루트 노드는 힙의 마지막 노드가 있던 자리로 이동한다.

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/5f6dcb4d-62a3-4167-901b-548fdde4e684" width=600>

- 시간 복잡도는 $O(nlog\,n)$ 이다.

---

> Additional Contents
> 
- 로트 노드를 삭제하고 한 번 내려갈 때마다 자식 중 더 큰 것과 자신을 비교해야 한다. (자식끼리 비교 1번, 큰 자식과 자신을 비교 1번) 총 2번의 비교 연산이 필요하다.
- 힙의 구조를 만족시키도록 변형하기 위해서는  $2h \approx 2logn$ 번의 연산이 필요하다.
- 입력이 배열로 주어지는 경우 힙 구조를 만족시키기 때문에 $O(n)$ 안에 힙을 만들 수 있다.
    - Left Child : $2i$
    - Right Child : $2i + 1$
    - Parent : $\frac{i}{2}$
- k개의 노드가 있을 때 한 번의 삭제 연산의 최악의 수행시간은 $2log(k)$ 이며, 전체 노드의 삭제 수행시간은   $\sum\limits_{k=1}^{n-1} log\,k \Subset \Theta(nlog\,n)$ 이다.
- 따라서 최악의 경우 시간복잡도는 $O(n) + 2n\,log(n)$이다.

> Accelerated Heapsort
> 
- 2단계(힙 구조로 변경)를 개선하는 방식이다.
- 한 번의 삭제 연산에서 $2h$ 번의 비교 연산이 발생하는데, 이를 개선하기 위해 분할 정복 기법을 사용할 수 있다.
    - 절반 높이만큼 내려간다.
    - 잘 내려갔는지 확인한다.
    - 잘못내려간 경우 올라오면서 자리를 찾는다. / 잘 내려간 경우 다시 높이의 절반만큼 내려가 동일하게 수행한다.

- 예시 K=55

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/fa08a740-18e4-468b-b9c4-5f8f7302eec4" width=300>

- 현재 높이가 7이기 때문에 3칸(h/2)만큼 내려간다.

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/8aa97c5c-f1fd-4d36-b5a9-4593aaf1e4a6" width=300>

- 70 > 55 이기 때문에 잘 내려왔다. 다시 절반 높이인 2칸(h/4)만큼 내려간다.

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/ca43edcb-91d3-499c-8202-04d4fd9bdc47" width=400>

- 50 > 55 이기 때문에 잘못 내려왔다. 위로 올라가면서 제자리를 찾는다.

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/2bbf3336-0cbc-48a0-aa53-2f195cfb5e8e" width=400>

- 60 > 55 이기 때문에 해당 위치에서 멈춘다.
- 한 번의 삭제 연산에서 일어나는 비교 연산의 횟수는 다음과 같다.
- $\frac{h}{2} + 1 + \frac{h}{4} + 1 +\frac{h}{8} + 1\,... = h + 3 \approx h$  → $\sum\limits_{k=1}^{n-1} log\,k \Subset \Theta(nlog\,n)$
- 기존의 걸리는 수행 연산보다 2배 줄였지만, 점근식 표현으로는 같다.

- 힙 생성 알고리즘을 수행하는데 $O(log\,n)$ 이 소요되고, 전체 요소가 정렬되는데 $O(n)$ 이 소요된다.

---

<br><br>

## 5.1.7 기수 정렬(Radix Sort)

- 낮은 자리수부터 정렬을 수행한다.
- 숫자별로 버킷이라는 큐를 생성한다.
- 정렬하려는 숫자들의 각 자리수에 해당하는 숫자를 각각의 버킷에 넣어 정렬하고 이를 자릿수만큼 반복한다.

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/b195821a-880d-4e58-a7fd-11a1b422a9c1" width=400>

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/ce18be8f-37f7-4f95-a0b2-9621c421ac5c" width=400>

- 데이터의 개수를 n, 최대 자릿수를 d라고 할 때 시간 복잡도는 $O(dn)$ 이다.
- d가 상수라면 상수 시간안에 해결되는 알고리즘이 되지만, d가 n이 되면 결국  $O(n^2)$ 이 된다.
- 버킷을 구성하기 위한 추가 메모리가 필요하고 정렬할 수 있는 데이터 타입이 한정적이다.

<br><br>

## 5.1.8 계수 정렬

- 데이터의 개수를 세서 정렬하는 방식이다.
- 정렬하려는 데이터의 범위를 인덱스로 갖는 빈 배열을 생성하고 순회하며 데이터에 해당하는 인덱스의 값을 1씩 증가시킨다.
- 데이터의 범위가 0 또는 양의 정수여야 한다는 제약 조건이 있다.

<img src="https://github.com/woowacourse-study/2023-cs-study/assets/84285337/df24fbf6-629d-4ac7-bc7c-12901531efbf" width=400>

- 데이터의 개수를 n, 데이터의 최댓값을 k라고 할 때 시간 복잡도는 $O(n+k)$ 다.
- 데이터의 최댓값이 무한대에 수렴하면 시간 복잡도도 역시 무한으로 수렴한다.
- 데이터 범위만큼의 배열이 필요하기 때문에 추가로 사용하는 메모리 공간이 있다.