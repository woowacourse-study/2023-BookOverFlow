# 5.1 정렬 알고리즘

정렬 알고리즘

- 비교하는 정렬 알고리즘
    - 버블 정렬, 선택 정렬, 삽입 정렬, 합병 정렬, 힙 정렬, 퀵 정렬
- 비교하지 않는 정렬 알고리즘
    - 계수 정렬, 기수 정렬

## 5.1.1 버블 정렬

**버블 정렬(bubble sort)**

- 양 옆에 위치한 두 값을 비교하면서 크기 순으로 정렬
- 배열의 뒤에서부터 정렬

![Untitled](
https://github.com/woowacourse-study/2023-cs-study/assets/50761690/fee99119-efc9-480e-ac52-5f329c71a46f)


**버블 정렬 작동 방식**

- a < b → 정렬되었다고 판단
- a > b → a와 b의 위치를 바꿔 정렬을 수행
- 위 작업을 정렬이 완료될 때까지 수행

![IMG_BBF0237D8509-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/b82303ee-8da1-403b-92b9-4c74c0a35052)

**버블 정렬 예**

1) 5와 3을 비교했을 때 5가 3보다 크므로 두 수의 위치 교환

2) 5와 8을 비교했을 때 5가 8보다 작으므로 위치 교환 X

3) 8과 1을 비교했을 때 8이 1보다 크므로 두 수의 위치 교환

4) 8과 2를 비교했을 때 8이 2보다 크므로 두 수위 위치 교환

5) 배열의 뒤, 즉 마지막 인덱스부터 정렬

배열의 첫번째 요소 부터 n번째 요소까지 오름차순으로 버블 정렬 수행, 해당 범위의 최댓값이 n번째에 위치

배열의 n번째 요소를 정렬하는데 n-1번을 비교하므로 배열의 모든 요소를 정렬하려면 (n-1) + (n-2) + … + 2 + 1 = n(n-1) / 2 연산 수행

→ 시간 복잡도 O(n^2)

장점: 별도의 메모리 공간 필요하지 않음

단점: 정렬을 수행하는데 비교적 느린 편

## 5.1.2 선택 정렬

**선택 정렬(selection sort)**

- 배열을 순회하면서 배열의 앞에서부터 차례대로 각 인덱스에 들어갈 값을 선택해 위치

![IMG_89EBFBC6B556-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/8139659a-2046-4b77-97c5-568d5768c8a7)

**선택 정렬 작동 방식**

- 인덱스 i에 들어갈 값을 선택하는 경우 인덱스 i-1까지는 정렬이 완료된 상태
- 인덱스 i부터 마지막 인덱스까지의 요소 중 최솟값 선택
- 선택한 최솟값과 인덱스 i에 담긴 값의 위치 교환
- 위 방식으로 배열 순회하면서 마지막 인덱스까지 정렬 수행

![IMG_4A3741E692DB-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/6fd59fc6-a459-462f-9e92-d7f9e4e98da2)

**선택 정렬 예**

1) 배열의 첫번째 자리에 배열에서 가장 작은 값인 1을 위치

2) 배열의 두 번째 자리에 1을 제외한 나머지 값 중 가장 작은 2를 위치

3) 배열의 세 번째 자리에 1,2를 제외한 나머지 값 중 가장 작은 3을 위치

4) 배열의 네 번째 자리에 1,2,3을 제외한 나머지 값 중 가장 작은 5를 위치

5) 배열의 다섯 번째 자리에 1,2,3,5를 제외한 나머지 값 중 가장 작은 8 위치

배열의 크기를 n이라 할 때, 각 인덱스 i에 들어갈 숫자를 찾기 위해 n-i개의 값 비교

배열 전체에 대한 정렬을 완료하려면 (n-1) + (n-2) + … + 2 + 1 = n(n-1) / 2번 연산을 수행

→ 시간 복잡도 O(n^2)

장점: 별도의 메모리 공간 필요하지 않음, 구현 간단한 편

단점: 수행 시간 느린 편

## 5.1.3 삽입 정렬

**삽입 정렬(insertion sort)**

- 배열을 앞에서부터 순회하면서 정렬된 부분의 적절한 위치에 값을 삽입하는 방식

![IMG_976751618169-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/7bc9892d-986c-4e87-94a5-3018ccd3bd5a)

**삽입 정렬 작동 방식**

- 인덱스 i에 있는 a를 정렬할 차례 → 인덱스 0부터 i-1까지는 이미 정렬된 상태
- 배열의 정렬된 부분에서 a보다 작거나 같은 수와 a보다 큰 수 사이에 a를 삽입

![IMG_654F5B32F0CE-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/b43058f0-0825-4757-bc0c-d64abd00eb50)

**삽입 정렬 예**

1) 배열에서 정렬된 부분이 [5]일 때 두번째 요소인 3을 적절한 위치인 5 앞에 삽입

2) 세 번째 요소인 8은 정렬된 부분인 [3,5]에서 5 뒤가 적절한 위치, 현재 위치 유지

3) 네 번째 요소인 1은 정렬된 부분인[3,5,8]에서 적절한 위치인 3 앞에 삽입

4) 다섯 번째 요소인 2는 정렬된 [1,3,5,8]에서 적절한 위치인 1과 3 사이에 삽입

5) 배열의 마지막 요소까지 정렬되어 연산 종료

전체 배열을 순회하며 각 순회에서 인덱스 i 요소를 적절한 위치에 삽입하기 위해 최대 n-i번 탐색

1 + 2 + … + (n-2) + (n-1) = n(n-1) / 2 수행

→ 시간 복잡도 O(n^2)

## 5.1.4 합병 정렬

**합병 정렬(merge sort)**

- 재귀를 이용하는 분할 정복 알고리즘
- 분할 - 배열 쪼개는 것
- 정복 - 분할한 배열을 정렬하면서 하나로 합병하는 것

**합병 정렬 작동 방식**

- 정렬하려는 배열의 크기가 0 또는 1이 될 때까지 절반씩 분할
- 분할된 각각의 배열은 다시 하나의 배열로 합쳐지면서 정렬 수행
    - 합병하려는 두 배열과, 두 배열의 합친 크기의 빈 배열 필요
    - 합병하려는 두 배열은 정렬이 완료된 상태
    - 각 배열의 앞에 있는 요소부터 비교하면서 정렬
- 오름차순이면 두 배열의 앞에 있는 요소 중 작은 숫자를 빈 배열에 넣음
- 내림차순이면 큰 숫자를 빈 배열에 넣음

![IMG_27D9E874B434-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/477e8aff-c702-48ea-aca2-16def17ba0f0)

![IMG_AA81C357C1A7-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/02195811-885e-4733-be5c-8689800e5dd1)

시간 복잡도  O(n log n)

→ O(n) - 배열이 정렬되는데 걸리는 시간 복잡도, O(log n) - 배열의 분할 또는 합병 시 걸리는 시간 복잡도

**분할 정복 알고리즘(divide and conquer algorithm)**

- 해결하기 어려운 문제를 작은 문제로 분할해 해결하는 방식
- 주로 재귀함수로 구현
- 예) 합병 정렬
    
    ![IMG_BF46CA80742D-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/ac33e8b9-4a39-487b-9c57-d5861e7186df)
    
    ![IMG_B840ECEE194B-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/3df713a2-62a9-4b75-893d-be3abe6d48b2)
    
    **분할 정복 예**
    
    1) [6,7]과 [4,5]로 된 두 배열을 정렬하려면 크기가 4인 빈 배열을 준비, 두 배열의 첫 번째 요소인 6과 4를 비교했을 때 4가 작으므로 정렬을 위한 배열에 4를 삽입
    
    2) [6,7]과 [5]에서 각 배열의 첫 번째 숫자인 6과 5를 비교했을 때 5가 작으므로 정렬을 위한 배열에 5 삽입
    
    3) [6,7]과 빈 배열만 남았으므로 정렬을 위한 배열에 6 삽입
    
    4) [7]과 빈 배열만 남았으므로 정렬을 위한 배열에 7을 삽입하고 정렬 종료
    

## 5.1.5 퀵 정렬

**퀵 정렬(quick sort)**

- 분할 정복 알고리즘
- 배열에서 피봇(pivot)이라는 특정 값을 선택해 **피봇보다 작은 값으로 구성된 배열과 피봇보다 큰 값으로 구성된 배열로 분할해 정렬**
- 피봇 - 일반적으로 배열의 첫 번째 요소나 마지막 요소를 선택

**퀵 정렬 작동방식**

- low와 high라는 변수를 두어 피봇보다 작은 수와 피봇보다 큰 수 분리
    - low - 배열의 첫번째 요소에서 시작해 오른쪽으로 한 칸씩 이동
    - high - 배열의 마지막 요소에서 시작해 왼쪽으로 한 칸씩 이동
- low가 가리키는 값이 피봇보다 작으면 오른쪽으로 한 칸을 이동하고, 피봇보다 크면 이동하지 않음
- high가 가리키는 값이 피봇보다 크면 왼쪽으로 한 칸을 이동하고, 피봇보다 작으면 이동하지 않음
- low와 high 둘 다 이동하지 않을 때 두 변수가 가리키는 값을 교환해 배열의 왼쪽에는 피봇보다 작은 값이, 배열의 오른쪽에는 피봇보다 큰 값이 위치하도록 함
- 분할은 배열의 크기가 1 이하가 될 때까지 반복 수행

![IMG_68214F5EE9F4-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/05fbbd37-9e6d-4bca-a53f-912cdf36e7da)

**퀵 정렬 분할 예**

1) 배열의 첫번째 요소 피봇 설정, low는 피봇 4를 제외하고 첫번째 요소인 3, high는 배열의 마지막 요소 5를 가리킴

2) low가 가리키는 3은 피봇 4보다 작으므로 low를 오른쪽으로 한 칸 이동, high가 가리키는 5는 4보다 크므로 high를 왼쪽으로 한 칸 이동

3) low가 가리키는 2는 피봇 4보다 작으므로 low를 오른쪽으로 한 칸 이동, high가 가리키는 1은 4보다 작으므로 high 이동하지 않음

4) low가 가리키는 6은 피봇 4보다 크므로 low는 이동하지 않음

5) low와 high 모두 이동하지 않으므로 두 변수가 가리키는 값을 교환, low는 1을, high는 6을 가리킴

6) low가 가리키는 1은 피봇 4보다 작으므로 low를 오른쪽으로 한 칸 이동, high가 가리키는 6은 4보다 크므로 high를 왼쪽으로 한 칸 이동

7) low가 가리키는 7은 피봇 4보다 크므로 low는 이동하지 않음, high가 가리키는 7은 4보다 크므로 high를 왼쪽으로 한 칸 이동하면서 low와 high가 엇갈림, 이는 피봇을 기준으로 배열이 나눠졌음을 의미

8) 피봇을 기준으로 배열을 [3,2,1]RHK [7,6,5] 두 부분으로 나눔

![IMG_26C1DFD93FD9-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/f113547a-29d0-4284-9eac-f0216dac67a2)

**퀵 정렬 전체 과정 예**

평균 시간 복잡도 O(n log n)

→ 배열을 균등하기 분할할 시

최악의 경우 O(n^2)

→ 배열이 오름차순이나 내림차순으로 정렬되어 있는 경우, 피봇이 첫번째 요소일 때

**피봇으로 어떤 값을 선택하느냐에 따라 퀵 정렬의 성능이 좌우됨**

**피봇 선택 방법**

1. 첫번째 값이나 마지막 값을 피벗으로 선정한다.
2. 첫번째 값, 가운데 값, 마지막 값 중에 중간값을 피벗으로 선정한다.(Median of Three)
3. 무작위 값을 피벗으로 선정한다.

## 5.1.6 힙 정렬

**힙 정렬(heap sort)**

- 최대 힙이나 최소 힙 자료구조를 이용해 정렬 수행
- 최대 힙으로 오름차순 정렬, 최소 힙으로 내림차순 정렬

**힙 정렬 작동 방식**

- 배열을 힙으로 만드는 힙 생성 알고리즘 과정
    - 힙 생성 알고리즘(heapify) - 특정 노드의 두 자식 노드 중 우선순위가 더 높은 자식 노드와 위치를 교환하는 방식
- 힙에서 요소를 꺼내 정렬하는 과정
    - 최대 힙에서 삭제 연산을 이용해 정렬 수행

![IMG_37BD30129BA1-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/67a42441-b6d7-4e8f-90d3-6a569c10b63c)

![IMG_BE815AEA67B7-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/7f67b6e2-d0fb-49c5-8ce3-21dc50d00f32)

![IMG_73A2F8CEB7C5-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/4e2a92d7-44e5-460f-bfe2-edd692002f78)

힙 정렬 예

1) 최대 힙에서 삭제 연산을 수행해 루트 노드의 값을 꺼내고 트리의 맨 마지막 노드인 2를 루트 노드로 가져옴, 꺼낸 7을 기존에 2가 있던 배열의 위치로 옮긴 뒤 힙에서 제외

2) 루트 노드 자리에 온 2를 6(a), 4(b)와 차례대로 위치를 교환해 최대 힙 속성 만족

3) 삭제 연산을 수행해 루트 노드에서 6을 꺼내고 루트 노드 자리에 1을 가져옴(a), 루트 노드 자리에 온 1은 5와 위치를 교환해(b) 최대 힙 속성 만족, 꺼낸 6을 기존에 1이 있던 배열의 위치로 옮긴 뒤 힙에서 제외

4) 삭제 연산 수행해 루트 노드에서 5를 꺼내고 이자리에 3을 가져옴(a), 루트 노드 자리에 온 3은 4와 위치를 교환(b),  꺼낸 5를 기존에 3이 있던 배열의 위치로 옮긴 뒤 힙에서 제외

5) 삭제 연산 수행해 루트 노드에서 4를 꺼내고 이 자리에 2를 가져옴(a). 루트 노드 자리에 온 2는 3과 위치를 교환(b). 꺼낸 4를 기존에 2가 있던 위치로 옮긴 뒤 힙에서 제외

6) 삭제 연산을 수행해 루트 노드에서 3을 꺼내고 이 자리에 1을 가져옴(a). 루트 노드 자리에 온 1은 2와 위치를 교환(b). 꺼낸 3을 기존에 1이 있던 위치로 옮긴 뒤 힙에서 제외

7) 삭제 연산을 수행해 2를 꺼내고 루트 노드 자리에 1 위치. 꺼낸 2를 기존에 1이 있던 배열의 위치로 옮긴 뒤 힙에서 제외

8) 모든 요소에 대해 정렬 완료

시간 복잡도 O(n log n)

→ 힙 생성 알고리즘 O(log n) + 전체 요소 n개 정렬 O(n)

## 5.1.7 기수 정렬

**기수 정렬(radix sort)**

- 비교하지 않는 정렬 알고리즘

**기수 정렬 작동 방식**

- 낮은 자릿수부터 정렬 수행
- 십진수에서 각 자릿수에 0부터 9까지 숫자가 올 수 있음
- 숫자별로 **버킷(bucket)**이라는 큐 생성
- 정렬하려는 숫자들의 각 자릿수에 해당하는 숫자를 각각의 버킷에 넣어 정렬, 이를 자릿수만큼 반복

![IMG_EF224FF0C20E-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/93893a3b-f0ce-4ead-856f-15a60b3a22ea)

**기수 정렬 예**

1) 각 자릿수에 오는 숫자에 맞춰 값을 저장할 수 있는 버킷 구성

2) 배열 [73,21,56,13,16,35,41,69]의 각 숫자를 일의 자릿수를 기준으로 순서대로 버킷에 넣음

3) 버킷에서 숫자들을 꺼내 배열에 넣음, 각 버킷은 큐라서 배열은 21,41,73,13,36,56,16,69]로 구성

4) 배열의 숫자들을 십의 자릿수를 기준으로 다시 버킷에 넣음

5) 버킷에서 숫자들을 꺼내 배열에 넣으면 [13,16,21,35,41,56,69,73]

시간복잡도 O(dn)

→ 데이터 개수 n, 최대 자릿수를 d

장점: 빠른 편

단점: 버킷을 구성하기 위한 추가 메모리 필요, 정렬할 수 있는 데이터 타입 한정적

## 5.1.8 계수 정렬

**계수 정렬(counting sort)**

- 비교하지 않는 정렬 알고리즘
- 데이터의 개수를 세서 정렬하는 방식

**계수 정렬 작동 방식**

- 정렬하려는 데이터의 범위를 인덱스로 갖는 빈 배열 생성
- 정렬하려는 배열을 순회하면서 데이터에 해당하는 인덱스의 값을 1 증가
- 계수 정렬은 데이터의 범위가 0 또는 양의 정수여야 한다는 제약 조건 있음

![IMG_BCDB28F8AC12-1.jpeg](https://github.com/woowacourse-study/2023-cs-study/assets/50761690/adf51d03-89d1-4bb0-b989-37b0707d37b7)

**계수 정렬 예**

1) 정렬하려는 배열 [8,3,9,2,3,4,0,5]의 데이터 범위는 0부터 9

2) 0부터 9까지 인덱스를 갖는 크기가 10인 계수 배열 생성

3) 정렬하려는 배열을 순회하면서 데이터에 해당하는 개수 배열의 인덱스 값 1 증가

4) 정렬하려는 배열의 순회가 끝나면 계수 배열을 순회하면서 값을 정렬

시간 복잡도 O(n+k)

→ 정렬하려는 데이터의 개수 n, 데이터의 최댓값 k

→ 데이터의 최댓값이 무한대에 수렴하면 시간복잡도 역시 무한대에 수렴

→ 정렬하려는 데이터가 시간 복잡도에 영향을 끼침

단점: 데이터 범위만 한 크기의 배열 생성해야하므로 추가로 사용되는 메모리 공간 존재
